!(function (a, b) {'use strict'; 'object' == typeof module && 'object' == typeof module.exports ? (module.exports = a.document ? b(a, !0) : function (a) {if (!a.document) throw new Error('jQuery requires a window with a document'); return b(a);}) : b(a);})('undefined' != typeof window ? window : this, function (a, b) {'use strict'; var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c.indexOf, j = {}, k = j.toString, l = j.hasOwnProperty, m = l.toString, n = m.call(Object), o = {}; function p(a, b) {b = b || d; var c = b.createElement('script'); (c.text = a), b.head.appendChild(c).parentNode.removeChild(c);}var q = '3.2.1', r = function (a, b) {return new r.fn.init(a, b);}, s = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, t = /^-ms-/, u = /-([a-z])/g, v = function (a, b) {return b.toUpperCase();}; (r.fn = r.prototype = {jquery: q, constructor: r, length: 0, toArray: function () {return f.call(this);}, get: function (a) {return null == a ? f.call(this) : a < 0 ? this[a + this.length] : this[a];}, pushStack: function (a) {var b = r.merge(this.constructor(), a); return (b.prevObject = this), b;}, each: function (a) {return r.each(this, a);}, map: function (a) {return this.pushStack( r.map(this, function (b, c) {return a.call(b, c, b);}), );}, slice: function () {return this.pushStack(f.apply(this, arguments));}, first: function () {return this.eq(0);}, last: function () {return this.eq(-1);}, eq: function (a) {var b = this.length, c = +a + (a < 0 ? b : 0); return this.pushStack(c >= 0 && c < b ? [this[c]] : []);}, end: function () {return this.prevObject || this.constructor();}, push: h, sort: c.sort, splice: c.splice, }), (r.extend = r.fn.extend = function () {var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1; for ( 'boolean' == typeof g && ((j = g), (g = arguments[h] || {}), h++), 'object' == typeof g || r.isFunction(g) || (g = {}), h === i && ((g = this), h--); h < i; h++ ) if (null != (a = arguments[h])) for (b in a) (c = g[b]), (d = a[b]), g !== d && (j && d && (r.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? ((e = !1), (f = c && Array.isArray(c) ? c : [])) : (f = c && r.isPlainObject(c) ? c : {}), (g[b] = r.extend(j, f, d))) : void 0 !== d && (g[b] = d)); return g;}), r.extend({expando: 'jQuery' + (q + Math.random()).replace(/\D/g, ''), isReady: !0, error: function (a) {throw new Error(a);}, noop: function () {}, isFunction: function (a) {return 'function' === r.type(a);}, isWindow: function (a) {return null != a && a === a.window;}, isNumeric: function (a) {var b = r.type(a); return ('number' === b || 'string' === b) && !isNaN(a - parseFloat(a));}, isPlainObject: function (a) {var b, c; return ( !(!a || '[object Object]' !== k.call(a)) && (!(b = e(a)) || ((c = l.call(b, 'constructor') && b.constructor), 'function' == typeof c && m.call(c) === n)) );}, isEmptyObject: function (a) {var b; for (b in a) return !1; return !0;}, type: function (a) {return null == a ? a + '' : 'object' == typeof a || 'function' == typeof a ? j[k.call(a)] || 'object' : typeof a;}, globalEval: function (a) {p(a);}, camelCase: function (a) {return a.replace(t, 'ms-').replace(u, v);}, each: function (a, b) {var c, d = 0; if (w(a)) {for (c = a.length; d < c; d++) if (b.call(a[d], d, a[d]) === !1) break;}else for (d in a) if (b.call(a[d], d, a[d]) === !1) break; return a;}, trim: function (a) {return null == a ? '' : (a + '').replace(s, '');}, makeArray: function (a, b) {var c = b || []; return null != a && (w(Object(a)) ? r.merge(c, 'string' == typeof a ? [a] : a) : h.call(c, a)), c;}, inArray: function (a, b, c) {return null == b ? -1 : i.call(b, a, c);}, merge: function (a, b) {for (var c = +b.length, d = 0, e = a.length; d < c; d++) a[e++] = b[d]; return (a.length = e), a;}, grep: function (a, b, c) {for (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) (d = !b(a[f], f)), d !== h && e.push(a[f]); return e;}, map: function (a, b, c) {var d, e, f = 0, h = []; if (w(a)) for (d = a.length; f < d; f++) (e = b(a[f], f, c)), null != e && h.push(e); else for (f in a) (e = b(a[f], f, c)), null != e && h.push(e); return g.apply([], h);}, guid: 1, proxy: function (a, b) {var c, d, e; if (('string' == typeof b && ((c = a[b]), (b = a), (a = c)), r.isFunction(a))) return ( (d = f.call(arguments, 2)), (e = function () {return a.apply(b || this, d.concat(f.call(arguments)));}), (e.guid = a.guid = a.guid || r.guid++), e );}, now: Date.now, support: o, }), 'function' == typeof Symbol && (r.fn[Symbol.iterator] = c[Symbol.iterator]), r.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (a, b) {j['[object ' + b + ']'] = b.toLowerCase();}); function w(a) {var b = !!a && 'length' in a && a.length, c = r.type(a); return 'function' !== c && !r.isWindow(a) && ('array' === c || 0 === b || ('number' == typeof b && b > 0 && b - 1 in a));}var x = (function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = 'sizzle' + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function (a, b) {return a === b && (l = !0), 0;}, C = {}.hasOwnProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, I = function (a, b) {for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c; return -1;}, J = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', K = '[\\x20\\t\\r\\n\\f]', L = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', M = '\\[' + K + '*(' + L + ')(?:' + K + '*([*^$|!~]?=)' + K + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + L + '))|)' + K + '*\\]', N = ':(' + L + ')(?:\\(((\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|' + M + ')*)|.*)\\)|)', O = new RegExp(K + '+', 'g'), P = new RegExp('^' + K + '+|((?:^|[^\\\\])(?:\\\\.)*)' + K + '+$', 'g'), Q = new RegExp('^' + K + '*,' + K + '*'), R = new RegExp('^' + K + '*([>+~]|' + K + ')' + K + '*'), S = new RegExp('=' + K + '*([^\\]\'"]*?)' + K + '*\\]', 'g'), T = new RegExp(N), U = new RegExp('^' + L + '$'), V = {ID: new RegExp('^#(' + L + ')'), CLASS: new RegExp('^\\.(' + L + ')'), TAG: new RegExp('^(' + L + '|[*])'), ATTR: new RegExp('^' + M), PSEUDO: new RegExp('^' + N), CHILD: new RegExp( '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + K + '*(even|odd|(([+-]|)(\\d*)n|)' + K + '*(?:([+-]|)' + K + '*(\\d+)|))' + K + '*\\)|)', 'i', ), bool: new RegExp('^(?:' + J + ')$', 'i'), needsContext: new RegExp('^' + K + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + K + '*((?:-\\d)?\\d*)' + K + '*\\)|)(?=[^-]|$)', 'i'), }, W = /^(?:input|select|textarea|button)$/i, X = /^h\d$/i, Y = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, $ = /[+~]/, _ = new RegExp('\\\\([\\da-f]{1,6}' + K + '?|(' + K + ')|.)', 'ig'), aa = function (a, b, c) {var d = '0x' + b - 65536; return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode((d >> 10) | 55296, (1023 & d) | 56320);}, ba = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ca = function (a, b) {return b ? ('\0' === a ? '\ufffd' : a.slice(0, -1) + '\\' + a.charCodeAt(a.length - 1).toString(16) + ' ') : '\\' + a;}, da = function () {m();}, ea = ta( function (a) {return a.disabled === !0 && ('form' in a || 'label' in a);}, {dir: 'parentNode', next: 'legend' }, ); try {G.apply((D = H.call(v.childNodes)), v.childNodes), D[v.childNodes.length].nodeType;}catch (fa) {G = {apply: D.length ? function (a, b) {F.apply(a, H.call(b));}: function (a, b) {var c = a.length, d = 0; while ((a[c++] = b[d++])); a.length = c - 1;}, };}function ga(a, b, d, e) {var f, h, j, k, l, o, r, s = b && b.ownerDocument, w = b ? b.nodeType : 9; if (((d = d || []), 'string' != typeof a || !a || (1 !== w && 9 !== w && 11 !== w))) return d; if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), (b = b || n), p)) {if (11 !== w && (l = Z.exec(a))) if ((f = l[1])) {if (9 === w) {if (!(j = b.getElementById(f))) return d; if (j.id === f) return d.push(j), d;}else if (s && (j = s.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;}else {if (l[2]) return G.apply(d, b.getElementsByTagName(a)), d; if ((f = l[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(f)), d;}if (c.qsa && !A[a + ' '] && (!q || !q.test(a))) {if (1 !== w) (s = b), (r = a); else if ('object' !== b.nodeName.toLowerCase()) {(k = b.getAttribute('id')) ? (k = k.replace(ba, ca)) : b.setAttribute('id', (k = u)), (o = g(a)), (h = o.length); while (h--) o[h] = '#' + k + ' ' + sa(o[h]); (r = o.join(',')), (s = ($.test(a) && qa(b.parentNode)) || b);}if (r) try {return G.apply(d, s.querySelectorAll(r)), d;}catch (x) {}finally {k === u && b.removeAttribute('id');}}}return i(a.replace(P, '$1'), b, d, e);}function ha() {var a = []; function b(c, e) {return a.push(c + ' ') > d.cacheLength && delete b[a.shift()], (b[c + ' '] = e);}return b;}function ia(a) {return (a[u] = !0), a;}function ja(a) {var b = n.createElement('fieldset'); try {return !!a(b);}catch (c) {return !1;}finally {b.parentNode && b.parentNode.removeChild(b), (b = null);}}function ka(a, b) {var c = a.split('|'), e = c.length; while (e--) d.attrHandle[c[e]] = b;}function la(a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex; if (d) return d; if (c) while ((c = c.nextSibling)) if (c === b) return -1; return a ? 1 : -1;}function ma(a) {return function (b) {var c = b.nodeName.toLowerCase(); return 'input' === c && b.type === a;};}function na(a) {return function (b) {var c = b.nodeName.toLowerCase(); return ('input' === c || 'button' === c) && b.type === a;};}function oa(a) {return function (b) {return 'form' in b ? b.parentNode && b.disabled === !1 ? 'label' in b ? 'label' in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || (b.isDisabled !== !a && ea(b) === a) : b.disabled === a : 'label' in b && b.disabled === a;};}function pa(a) {return ia(function (b) {return ( (b = +b), ia(function (c, d) {var e, f = a([], c.length, b), g = f.length; while (g--) c[(e = f[g])] && (c[e] = !(d[e] = c[e]));}) );});}function qa(a) {return a && 'undefined' != typeof a.getElementsByTagName && a;}(c = ga.support = {}), (f = ga.isXML = function (a) {var b = a && (a.ownerDocument || a).documentElement; return !!b && 'HTML' !== b.nodeName;}), (m = ga.setDocument = function (a) {var b, e, g = a ? a.ownerDocument || a : v; return g !== n && 9 === g.nodeType && g.documentElement ? ((n = g), (o = n.documentElement), (p = !f(n)), v !== n && (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener('unload', da, !1) : e.attachEvent && e.attachEvent('onunload', da)), (c.attributes = ja(function (a) {return (a.className = 'i'), !a.getAttribute('className');})), (c.getElementsByTagName = ja(function (a) {return a.appendChild(n.createComment('')), !a.getElementsByTagName('*').length;})), (c.getElementsByClassName = Y.test(n.getElementsByClassName)), (c.getById = ja(function (a) {return (o.appendChild(a).id = u), !n.getElementsByName || !n.getElementsByName(u).length;})), c.getById ? ((d.filter.ID = function (a) {var b = a.replace(_, aa); return function (a) {return a.getAttribute('id') === b;};}), (d.find.ID = function (a, b) {if ('undefined' != typeof b.getElementById && p) {var c = b.getElementById(a); return c ? [c] : [];}})) : ((d.filter.ID = function (a) {var b = a.replace(_, aa); return function (a) {var c = 'undefined' != typeof a.getAttributeNode && a.getAttributeNode('id'); return c && c.value === b;};}), (d.find.ID = function (a, b) {if ('undefined' != typeof b.getElementById && p) {var c, d, e, f = b.getElementById(a); if (f) {if (((c = f.getAttributeNode('id')), c && c.value === a)) return [f]; (e = b.getElementsByName(a)), (d = 0); while ((f = e[d++])) if (((c = f.getAttributeNode('id')), c && c.value === a)) return [f];}return [];}})), (d.find.TAG = c.getElementsByTagName ? function (a, b) {return 'undefined' != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName(a); if ('*' === a) {while ((c = f[e++])) 1 === c.nodeType && d.push(c); return d;}return f;}), (d.find.CLASS = c.getElementsByClassName && function (a, b) {if ('undefined' != typeof b.getElementsByClassName && p) return b.getElementsByClassName(a);}), (r = []), (q = []), (c.qsa = Y.test(n.querySelectorAll)) && (ja(function (a) {(o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>"), a.querySelectorAll("[msallowcapture^='']").length && q.push('[*^$]=' + K + '*(?:\'\'|"")'), a.querySelectorAll('[selected]').length || q.push('\\[' + K + '*(?:value|' + J + ')'), a.querySelectorAll('[id~=' + u + '-]').length || q.push('~='), a.querySelectorAll(':checked').length || q.push(':checked'), a.querySelectorAll('a#' + u + '+*').length || q.push('.#.+[+~]');}), ja(function (a) {a.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var b = n.createElement('input'); b.setAttribute('type', 'hidden'), a.appendChild(b).setAttribute('name', 'D'), a.querySelectorAll('[name=d]').length && q.push('name' + K + '*[*^$|!~]?='), 2 !== a.querySelectorAll(':enabled').length && q.push(':enabled', ':disabled'), (o.appendChild(a).disabled = !0), 2 !== a.querySelectorAll(':disabled').length && q.push(':enabled', ':disabled'), a.querySelectorAll('*,:x'), q.push(',.*:');})), (c.matchesSelector = Y.test((s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector))) && ja(function (a) {(c.disconnectedMatch = s.call(a, '*')), s.call(a, "[s!='']:x"), r.push('!=', N);}), (q = q.length && new RegExp(q.join('|'))), (r = r.length && new RegExp(r.join('|'))), (b = Y.test(o.compareDocumentPosition)), (t = b || Y.test(o.contains) ? function (a, b) {var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode; return ( a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d))) );}: function (a, b) {if (b) while ((b = b.parentNode)) if (b === a) return !0; return !1;}), (B = b ? function (a, b) {if (a === b) return (l = !0), 0; var d = !a.compareDocumentPosition - !b.compareDocumentPosition; return d ? d : ((d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1), 1 & d || (!c.sortDetached && b.compareDocumentPosition(a) === d) ? a === n || (a.ownerDocument === v && t(v, a)) ? -1 : b === n || (b.ownerDocument === v && t(v, b)) ? 1 : k ? I(k, a) - I(k, b) : 0 : 4 & d ? -1 : 1);}: function (a, b) {if (a === b) return (l = !0), 0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? I(k, a) - I(k, b) : 0; if (e === f) return la(a, b); c = a; while ((c = c.parentNode)) g.unshift(c); c = b; while ((c = c.parentNode)) h.unshift(c); while (g[d] === h[d]) d++; return d ? la(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;}), n) : n;}), (ga.matches = function (a, b) {return ga(a, null, null, b);}), (ga.matchesSelector = function (a, b) {if ( ((a.ownerDocument || a) !== n && m(a), (b = b.replace(S, "='$1']")), c.matchesSelector && p && !A[b + ' '] && (!r || !r.test(b)) && (!q || !q.test(b))) ) try {var d = s.call(a, b); if (d || c.disconnectedMatch || (a.document && 11 !== a.document.nodeType)) return d;}catch (e) {}return ga(b, n, null, [a]).length > 0;}), (ga.contains = function (a, b) {return (a.ownerDocument || a) !== n && m(a), t(a, b);}), (ga.attr = function (a, b) {(a.ownerDocument || a) !== n && m(a); var e = d.attrHandle[b.toLowerCase()], f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0; return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;}), (ga.escape = function (a) {return (a + '').replace(ba, ca);}), (ga.error = function (a) {throw new Error('Syntax error, unrecognized expression: ' + a);}), (ga.uniqueSort = function (a) {var b, d = [], e = 0, f = 0; if (((l = !c.detectDuplicates), (k = !c.sortStable && a.slice(0)), a.sort(B), l)) {while ((b = a[f++])) b === a[f] && (e = d.push(f)); while (e--) a.splice(d[e], 1);}return (k = null), a;}), (e = ga.getText = function (a) {var b, c = '', d = 0, f = a.nodeType; if (f) {if (1 === f || 9 === f || 11 === f) {if ('string' == typeof a.textContent) return a.textContent; for (a = a.firstChild; a; a = a.nextSibling) c += e(a);}else if (3 === f || 4 === f) return a.nodeValue;}else while ((b = a[d++])) c += e(b); return c;}), (d = ga.selectors = {cacheLength: 50, createPseudo: ia, match: V, attrHandle: {}, find: {}, relative: {'>': {dir: 'parentNode', first: !0 }, ' ': {dir: 'parentNode' }, '+': {dir: 'previousSibling', first: !0 }, '~': {dir: 'previousSibling' }, }, preFilter: {ATTR: function (a) {return ( (a[1] = a[1].replace(_, aa)), (a[3] = (a[3] || a[4] || a[5] || '').replace(_, aa)), '~=' === a[2] && (a[3] = ' ' + a[3] + ' '), a.slice(0, 4) );}, CHILD: function (a) {return ( (a[1] = a[1].toLowerCase()), 'nth' === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), (a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ('even' === a[3] || 'odd' === a[3]))), (a[5] = +(a[7] + a[8] || 'odd' === a[3]))) : a[3] && ga.error(a[0]), a );}, PSEUDO: function (a) {var b, c = !a[6] && a[2]; return V.CHILD.test(a[0]) ? null : (a[3] ? (a[2] = a[4] || a[5] || '') : c && T.test(c) && (b = g(c, !0)) && (b = c.indexOf(')', c.length - b) - c.length) && ((a[0] = a[0].slice(0, b)), (a[2] = c.slice(0, b))), a.slice(0, 3));}, }, filter: {TAG: function (a) {var b = a.replace(_, aa).toLowerCase(); return '*' === a ? function () {return !0;}: function (a) {return a.nodeName && a.nodeName.toLowerCase() === b;};}, CLASS: function (a) {var b = y[a + ' ']; return ( b || ((b = new RegExp('(^|' + K + ')' + a + '(' + K + '|$)')) && y(a, function (a) {return b.test(('string' == typeof a.className && a.className) || ('undefined' != typeof a.getAttribute && a.getAttribute('class')) || '');})) );}, ATTR: function (a, b, c) {return function (d) {var e = ga.attr(d, a); return null == e ? '!=' === b : !b || ((e += ''), '=' === b ? e === c : '!=' === b ? e !== c : '^=' === b ? c && 0 === e.indexOf(c) : '*=' === b ? c && e.indexOf(c) > -1 : '$=' === b ? c && e.slice(-c.length) === c : '~=' === b ? (' ' + e.replace(O, ' ') + ' ').indexOf(c) > -1 : '|=' === b && (e === c || e.slice(0, c.length + 1) === c + '-'));};}, CHILD: function (a, b, c, d, e) {var f = 'nth' !== a.slice(0, 3), g = 'last' !== a.slice(-4), h = 'of-type' === b; return 1 === d && 0 === e ? function (a) {return !!a.parentNode;}: function (b, c, i) {var j, k, l, m, n, o, p = f !== g ? 'nextSibling' : 'previousSibling', q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h, t = !1; if (q) {if (f) {while (p) {m = b; while ((m = m[p])) if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1; o = p = 'only' === a && !o && 'nextSibling';}return !0;}if (((o = [g ? q.firstChild : q.lastChild]), g && s)) {(m = q), (l = m[u] || (m[u] = {})), (k = l[m.uniqueID] || (l[m.uniqueID] = {})), (j = k[a] || []), (n = j[0] === w && j[1]), (t = n && j[2]), (m = n && q.childNodes[n]); while ((m = (++n && m && m[p]) || (t = n = 0) || o.pop())) if (1 === m.nodeType && ++t && m === b) {k[a] = [w, n, t]; break;}}else if ( (s && ((m = b), (l = m[u] || (m[u] = {})), (k = l[m.uniqueID] || (l[m.uniqueID] = {})), (j = k[a] || []), (n = j[0] === w && j[1]), (t = n)), t === !1) ) while ((m = (++n && m && m[p]) || (t = n = 0) || o.pop())) if ( (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && ((l = m[u] || (m[u] = {})), (k = l[m.uniqueID] || (l[m.uniqueID] = {})), (k[a] = [w, t])), m === b) ) break; return (t -= e), t === d || (t % d === 0 && t / d >= 0);}};}, PSEUDO: function (a, b) {var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error('unsupported pseudo: ' + a); return e[u] ? e(b) : e.length > 1 ? ((c = [a, a, '', b]), d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {var d, f = e(a, b), g = f.length; while (g--) (d = I(a, f[g])), (a[d] = !(c[d] = f[g]));}) : function (a) {return e(a, 0, c);}) : e;}, }, pseudos: {not: ia(function (a) {var b = [], c = [], d = h(a.replace(P, '$1')); return d[u] ? ia(function (a, b, c, e) {var f, g = d(a, null, e, []), h = a.length; while (h--) (f = g[h]) && (a[h] = !(b[h] = f));}) : function (a, e, f) {return (b[0] = a), d(b, null, f, c), (b[0] = null), !c.pop();};}), has: ia(function (a) {return function (b) {return ga(a, b).length > 0;};}), contains: ia(function (a) {return ( (a = a.replace(_, aa)), function (b) {return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;});}), lang: ia(function (a) {return ( U.test(a || '') || ga.error('unsupported lang: ' + a), (a = a.replace(_, aa).toLowerCase()), function (b) {var c; do if ((c = p ? b.lang : b.getAttribute('xml:lang') || b.getAttribute('lang'))) return (c = c.toLowerCase()), c === a || 0 === c.indexOf(a + '-'); while ((b = b.parentNode) && 1 === b.nodeType); return !1;});}), target: function (b) {var c = a.location && a.location.hash; return c && c.slice(1) === b.id;}, root: function (a) {return a === o;}, focus: function (a) {return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);}, enabled: oa(!1), disabled: oa(!0), checked: function (a) {var b = a.nodeName.toLowerCase(); return ('input' === b && !!a.checked) || ('option' === b && !!a.selected);}, selected: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;}, empty: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1; return !0;}, parent: function (a) {return !d.pseudos.empty(a);}, header: function (a) {return X.test(a.nodeName);}, input: function (a) {return W.test(a.nodeName);}, button: function (a) {var b = a.nodeName.toLowerCase(); return ('input' === b && 'button' === a.type) || 'button' === b;}, text: function (a) {var b; return 'input' === a.nodeName.toLowerCase() && 'text' === a.type && (null == (b = a.getAttribute('type')) || 'text' === b.toLowerCase());}, first: pa(function () {return [0];}), last: pa(function (a, b) {return [b - 1];}), eq: pa(function (a, b, c) {return [c < 0 ? c + b : c];}), even: pa(function (a, b) {for (var c = 0; c < b; c += 2) a.push(c); return a;}), odd: pa(function (a, b) {for (var c = 1; c < b; c += 2) a.push(c); return a;}), lt: pa(function (a, b, c) {for (var d = c < 0 ? c + b : c; --d >= 0; ) a.push(d); return a;}), gt: pa(function (a, b, c) {for (var d = c < 0 ? c + b : c; ++d < b; ) a.push(d); return a;}), }, }), (d.pseudos.nth = d.pseudos.eq); for (b in {radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) d.pseudos[b] = ma(b); for (b in {submit: !0, reset: !0 }) d.pseudos[b] = na(b); function ra() {}(ra.prototype = d.filters = d.pseudos), (d.setFilters = new ra()), (g = ga.tokenize = function (a, b) {var c, e, f, g, h, i, j, k = z[a + ' ']; if (k) return b ? 0 : k.slice(0); (h = a), (i = []), (j = d.preFilter); while (h) {(c && !(e = Q.exec(h))) || (e && (h = h.slice(e[0].length) || h), i.push((f = []))), (c = !1), (e = R.exec(h)) && ((c = e.shift()), f.push({value: c, type: e[0].replace(P, ' ') }), (h = h.slice(c.length))); for (g in d.filter) !(e = V[g].exec(h)) || (j[g] && !(e = j[g](e))) || ((c = e.shift()), f.push({value: c, type: g, matches: e }), (h = h.slice(c.length))); if (!c) break;}return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);}); function sa(a) {for (var b = 0, c = a.length, d = ''; b < c; b++) d += a[b].value; return d;}function ta(a, b, c) {var d = b.dir, e = b.next, f = e || d, g = c && 'parentNode' === f, h = x++; return b.first ? function (b, c, e) {while ((b = b[d])) if (1 === b.nodeType || g) return a(b, c, e); return !1;}: function (b, c, i) {var j, k, l, m = [w, h]; if (i) {while ((b = b[d])) if ((1 === b.nodeType || g) && a(b, c, i)) return !0;}else while ((b = b[d])) if (1 === b.nodeType || g) if (((l = b[u] || (b[u] = {})), (k = l[b.uniqueID] || (l[b.uniqueID] = {})), e && e === b.nodeName.toLowerCase())) b = b[d] || b; else {if ((j = k[f]) && j[0] === w && j[1] === h) return (m[2] = j[2]); if (((k[f] = m), (m[2] = a(b, c, i)))) return !0;}return !1;};}function ua(a) {return a.length > 1 ? function (b, c, d) {var e = a.length; while (e--) if (!a[e](b, c, d)) return !1; return !0;}: a[0];}function va(a, b, c) {for (var d = 0, e = b.length; d < e; d++) ga(a, b[d], c); return c;}function wa(a, b, c, d, e) {for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++) (f = a[h]) && ((c && !c(f, d, e)) || (g.push(f), j && b.push(h))); return g;}function xa(a, b, c, d, e, f) {return ( d && !d[u] && (d = xa(d)), e && !e[u] && (e = xa(e, f)), ia(function (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || va(b || '*', h.nodeType ? [h] : h, []), q = !a || (!f && b) ? p : wa(p, m, a, h, i), r = c ? (e || (f ? a : o || d) ? [] : g) : q; if ((c && c(q, r, h, i), d)) {(j = wa(r, n)), d(j, [], h, i), (k = j.length); while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));}if (f) {if (e || a) {if (e) {(j = []), (k = r.length); while (k--) (l = r[k]) && j.push((q[k] = l)); e(null, (r = []), j, i);}k = r.length; while (k--) (l = r[k]) && (j = e ? I(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));}}else (r = wa(r === g ? r.splice(o, r.length) : r)), e ? e(null, g, r, i) : G.apply(g, r);}) );}function ya(a) {for ( var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[' '], i = g ? 1 : 0, k = ta( function (a) {return a === b;}, h, !0, ), l = ta( function (a) {return I(b, a) > -1;}, h, !0, ), m = [ function (a, c, d) {var e = (!g && (d || c !== j)) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d)); return (b = null), e;}, ]; i < f; i++ ) if ((c = d.relative[a[i].type])) m = [ta(ua(m), c)]; else {if (((c = d.filter[a[i].type].apply(null, a[i].matches)), c[u])) {for (e = ++i; e < f; e++) if (d.relative[a[e].type]) break; return xa( i > 1 && ua(m), i > 1 && sa(a.slice(0, i - 1).concat({value: ' ' === a[i - 2].type ? '*' : '' })).replace(P, '$1'), c, i < e && ya(a.slice(i, e)), e < f && ya((a = a.slice(e))), e < f && sa(a), );}m.push(c);}return ua(m);}function za(a, b) {var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) {var l, o, q, r = 0, s = '0', t = f && [], u = [], v = j, x = f || (e && d.find.TAG('*', k)), y = (w += null == v ? 1 : Math.random() || 0.1), z = x.length; for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {if (e && l) {(o = 0), g || l.ownerDocument === n || (m(l), (h = !p)); while ((q = a[o++])) if (q(l, g || n, h)) {i.push(l); break;}k && (w = y);}c && ((l = !q && l) && r--, f && t.push(l));}if (((r += s), c && s !== r)) {o = 0; while ((q = b[o++])) q(t, u, g, h); if (f) {if (r > 0) while (s--) t[s] || u[s] || (u[s] = E.call(i)); u = wa(u);}G.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && ga.uniqueSort(i);}return k && ((w = y), (j = v)), t;}; return c ? ia(f) : f;}return ( (h = ga.compile = function (a, b) {var c, d = [], e = [], f = A[a + ' ']; if (!f) {b || (b = g(a)), (c = b.length); while (c--) (f = ya(b[c])), f[u] ? d.push(f) : e.push(f); (f = A(a, za(e, d))), (f.selector = a);}return f;}), (i = ga.select = function (a, b, c, e) {var f, i, j, k, l, m = 'function' == typeof a && a, n = !e && g((a = m.selector || a)); if (((c = c || []), 1 === n.length)) {if (((i = n[0] = n[0].slice(0)), i.length > 2 && 'ID' === (j = i[0]).type && 9 === b.nodeType && p && d.relative[i[1].type])) {if (((b = (d.find.ID(j.matches[0].replace(_, aa), b) || [])[0]), !b)) return c; m && (b = b.parentNode), (a = a.slice(i.shift().value.length));}f = V.needsContext.test(a) ? 0 : i.length; while (f--) {if (((j = i[f]), d.relative[(k = j.type)])) break; if ((l = d.find[k]) && (e = l(j.matches[0].replace(_, aa), ($.test(i[0].type) && qa(b.parentNode)) || b))) {if ((i.splice(f, 1), (a = e.length && sa(i)), !a)) return G.apply(c, e), c; break;}}}return (m || h(a, n))(e, b, !p, c, !b || ($.test(a) && qa(b.parentNode)) || b), c;}), (c.sortStable = u.split('').sort(B).join('') === u), (c.detectDuplicates = !!l), m(), (c.sortDetached = ja(function (a) {return 1 & a.compareDocumentPosition(n.createElement('fieldset'));})), ja(function (a) {return (a.innerHTML = "<a href='#'></a>"), '#' === a.firstChild.getAttribute('href');}) || ka('type|href|height|width', function (a, b, c) {if (!c) return a.getAttribute(b, 'type' === b.toLowerCase() ? 1 : 2);}), (c.attributes && ja(function (a) {return (a.innerHTML = '<input/>'), a.firstChild.setAttribute('value', ''), '' === a.firstChild.getAttribute('value');})) || ka('value', function (a, b, c) {if (!c && 'input' === a.nodeName.toLowerCase()) return a.defaultValue;}), ja(function (a) {return null == a.getAttribute('disabled');}) || ka(J, function (a, b, c) {var d; if (!c) return a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;}), ga );})(a); (r.find = x), (r.expr = x.selectors), (r.expr[':'] = r.expr.pseudos), (r.uniqueSort = r.unique = x.uniqueSort), (r.text = x.getText), (r.isXMLDoc = x.isXML), (r.contains = x.contains), (r.escapeSelector = x.escape); var y = function (a, b, c) {var d = [], e = void 0 !== c; while ((a = a[b]) && 9 !== a.nodeType) if (1 === a.nodeType) {if (e && r(a).is(c)) break; d.push(a);}return d;}, z = function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a); return c;}, A = r.expr.match.needsContext; function B(a, b) {return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();}var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, D = /^.[^:#\[\.,]*$/; function E(a, b, c) {return r.isFunction(b) ? r.grep(a, function (a, d) {return !!b.call(a, d, a) !== c;}) : b.nodeType ? r.grep(a, function (a) {return (a === b) !== c;}) : 'string' != typeof b ? r.grep(a, function (a) {return i.call(b, a) > -1 !== c;}) : D.test(b) ? r.filter(b, a, c) : ((b = r.filter(b, a)), r.grep(a, function (a) {return i.call(b, a) > -1 !== c && 1 === a.nodeType;}));}(r.filter = function (a, b, c) {var d = b[0]; return ( c && (a = ':not(' + a + ')'), 1 === b.length && 1 === d.nodeType ? r.find.matchesSelector(d, a) ? [d] : [] : r.find.matches( a, r.grep(b, function (a) {return 1 === a.nodeType;}), ) );}), r.fn.extend({find: function (a) {var b, c, d = this.length, e = this; if ('string' != typeof a) return this.pushStack( r(a).filter(function () {for (b = 0; b < d; b++) if (r.contains(e[b], this)) return !0;}), ); for (c = this.pushStack([]), b = 0; b < d; b++) r.find(a, e[b], c); return d > 1 ? r.uniqueSort(c) : c;}, filter: function (a) {return this.pushStack(E(this, a || [], !1));}, not: function (a) {return this.pushStack(E(this, a || [], !0));}, is: function (a) {return !!E(this, 'string' == typeof a && A.test(a) ? r(a) : a || [], !1).length;}, }); var F, G = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, H = (r.fn.init = function (a, b, c) {var e, f; if (!a) return this; if (((c = c || F), 'string' == typeof a)) {if (((e = '<' === a[0] && '>' === a[a.length - 1] && a.length >= 3 ? [null, a, null] : G.exec(a)), !e || (!e[1] && b))) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a); if (e[1]) {if ( ((b = b instanceof r ? b[0] : b), r.merge(this, r.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), C.test(e[1]) && r.isPlainObject(b)) ) for (e in b) r.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]); return this;}return (f = d.getElementById(e[2])), f && ((this[0] = f), (this.length = 1)), this;}return a.nodeType ? ((this[0] = a), (this.length = 1), this) : r.isFunction(a) ? (void 0 !== c.ready ? c.ready(a) : a(r)) : r.makeArray(a, this);}); (H.prototype = r.fn), (F = r(d)); var I = /^(?:parents|prev(?:Until|All))/, J = {children: !0, contents: !0, next: !0, prev: !0 }; r.fn.extend({has: function (a) {var b = r(a, this), c = b.length; return this.filter(function () {for (var a = 0; a < c; a++) if (r.contains(this, b[a])) return !0;});}, closest: function (a, b) {var c, d = 0, e = this.length, f = [], g = 'string' != typeof a && r(a); if (!A.test(a)) for (; d < e; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && r.find.matchesSelector(c, a))) {f.push(c); break;}return this.pushStack(f.length > 1 ? r.uniqueSort(f) : f);}, index: function (a) {return a ? 'string' == typeof a ? i.call(r(a), this[0]) : i.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;}, add: function (a, b) {return this.pushStack(r.uniqueSort(r.merge(this.get(), r(a, b))));}, addBack: function (a) {return this.add(null == a ? this.prevObject : this.prevObject.filter(a));}, }); function K(a, b) {while ((a = a[b]) && 1 !== a.nodeType); return a;}r.each( {parent: function (a) {var b = a.parentNode; return b && 11 !== b.nodeType ? b : null;}, parents: function (a) {return y(a, 'parentNode');}, parentsUntil: function (a, b, c) {return y(a, 'parentNode', c);}, next: function (a) {return K(a, 'nextSibling');}, prev: function (a) {return K(a, 'previousSibling');}, nextAll: function (a) {return y(a, 'nextSibling');}, prevAll: function (a) {return y(a, 'previousSibling');}, nextUntil: function (a, b, c) {return y(a, 'nextSibling', c);}, prevUntil: function (a, b, c) {return y(a, 'previousSibling', c);}, siblings: function (a) {return z((a.parentNode || {}).firstChild, a);}, children: function (a) {return z(a.firstChild);}, contents: function (a) {return B(a, 'iframe') ? a.contentDocument : (B(a, 'template') && (a = a.content || a), r.merge([], a.childNodes));}, }, function (a, b) {r.fn[a] = function (c, d) {var e = r.map(this, b, c); return ( 'Until' !== a.slice(-5) && (d = c), d && 'string' == typeof d && (e = r.filter(d, e)), this.length > 1 && (J[a] || r.uniqueSort(e), I.test(a) && e.reverse()), this.pushStack(e) );};}, ); var L = /[^\x20\t\r\n\f]+/g; function M(a) {var b = {}; return ( r.each(a.match(L) || [], function (a, c) {b[c] = !0;}), b );}r.Callbacks = function (a) {a = 'string' == typeof a ? M(a) : r.extend({}, a); var b, c, d, e, f = [], g = [], h = -1, i = function () {for (e = e || a.once, d = b = !0; g.length; h = -1) {c = g.shift(); while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && ((h = f.length), (c = !1));}a.memory || (c = !1), (b = !1), e && (f = c ? [] : '');}, j = {add: function () {return ( f && (c && !b && ((h = f.length - 1), g.push(c)), (function d(b) {r.each(b, function (b, c) {r.isFunction(c) ? (a.unique && j.has(c)) || f.push(c) : c && c.length && 'string' !== r.type(c) && d(c);});})(arguments), c && !b && i()), this );}, remove: function () {return ( r.each(arguments, function (a, b) {var c; while ((c = r.inArray(b, f, c)) > -1) f.splice(c, 1), c <= h && h--;}), this );}, has: function (a) {return a ? r.inArray(a, f) > -1 : f.length > 0;}, empty: function () {return f && (f = []), this;}, disable: function () {return (e = g = []), (f = c = ''), this;}, disabled: function () {return !f;}, lock: function () {return (e = g = []), c || b || (f = c = ''), this;}, locked: function () {return !!e;}, fireWith: function (a, c) {return e || ((c = c || []), (c = [a, c.slice ? c.slice() : c]), g.push(c), b || i()), this;}, fire: function () {return j.fireWith(this, arguments), this;}, fired: function () {return !!d;}, }; return j;}; function N(a) {return a;}function O(a) {throw a;}function P(a, b, c, d) {var e; try {a && r.isFunction((e = a.promise)) ? e.call(a).done(b).fail(c) : a && r.isFunction((e = a.then)) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d));}catch (a) {c.apply(void 0, [a]);}}r.extend({Deferred: function (b) {var c = [ ['notify', 'progress', r.Callbacks('memory'), r.Callbacks('memory'), 2], ['resolve', 'done', r.Callbacks('once memory'), r.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', r.Callbacks('once memory'), r.Callbacks('once memory'), 1, 'rejected'], ], d = 'pending', e = {state: function () {return d;}, always: function () {return f.done(arguments).fail(arguments), this;}, catch: function (a) {return e.then(null, a);}, pipe: function () {var a = arguments; return r .Deferred(function (b) {r.each(c, function (c, d) {var e = r.isFunction(a[d[4]]) && a[d[4]]; f[d[1]](function () {var a = e && e.apply(this, arguments); a && r.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + 'With'](this, e ? [a] : arguments);});}), (a = null);}) .promise();}, then: function (b, d, e) {var f = 0; function g(b, c, d, e) {return function () {var h = this, i = arguments, j = function () {var a, j; if (!(b < f)) {if (((a = d.apply(h, i)), a === c.promise())) throw new TypeError('Thenable self-resolution'); (j = a && ('object' == typeof a || 'function' == typeof a) && a.then), r.isFunction(j) ? e ? j.call(a, g(f, c, N, e), g(f, c, O, e)) : (f++, j.call(a, g(f, c, N, e), g(f, c, O, e), g(f, c, N, c.notifyWith))) : (d !== N && ((h = void 0), (i = [a])), (e || c.resolveWith)(h, i));}}, k = e ? j : function () {try {j();}catch (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook(a, k.stackTrace), b + 1 >= f && (d !== O && ((h = void 0), (i = [a])), c.rejectWith(h, i));}}; b ? k() : (r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook()), a.setTimeout(k));};}return r .Deferred(function (a) {c[0][3].add(g(0, a, r.isFunction(e) ? e : N, a.notifyWith)), c[1][3].add(g(0, a, r.isFunction(b) ? b : N)), c[2][3].add(g(0, a, r.isFunction(d) ? d : O));}) .promise();}, promise: function (a) {return null != a ? r.extend(a, e) : e;}, }, f = {}; return ( r.each(c, function (a, b) {var g = b[2], h = b[5]; (e[b[1]] = g.add), h && g.add( function () {d = h;}, c[3 - a][2].disable, c[0][2].lock, ), g.add(b[3].fire), (f[b[0]] = function () {return f[b[0] + 'With'](this === f ? void 0 : this, arguments), this;}), (f[b[0] + 'With'] = g.fireWith);}), e.promise(f), b && b.call(f, f), f );}, when: function (a) {var b = arguments.length, c = b, d = Array(c), e = f.call(arguments), g = r.Deferred(), h = function (a) {return function (c) {(d[a] = this), (e[a] = arguments.length > 1 ? f.call(arguments) : c), --b || g.resolveWith(d, e);};}; if (b <= 1 && (P(a, g.done(h(c)).resolve, g.reject, !b), 'pending' === g.state() || r.isFunction(e[c] && e[c].then))) return g.then(); while (c--) P(e[c], h(c), g.reject); return g.promise();}, }); var Q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; (r.Deferred.exceptionHook = function (b, c) {a.console && a.console.warn && b && Q.test(b.name) && a.console.warn('jQuery.Deferred exception: ' + b.message, b.stack, c);}), (r.readyException = function (b) {a.setTimeout(function () {throw b;});}); var R = r.Deferred(); (r.fn.ready = function (a) {return ( R.then(a)['catch'](function (a) {r.readyException(a);}), this );}), r.extend({isReady: !1, readyWait: 1, ready: function (a) {(a === !0 ? --r.readyWait : r.isReady) || ((r.isReady = !0), (a !== !0 && --r.readyWait > 0) || R.resolveWith(d, [r]));}, }), (r.ready.then = R.then); function S() {d.removeEventListener('DOMContentLoaded', S), a.removeEventListener('load', S), r.ready();}'complete' === d.readyState || ('loading' !== d.readyState && !d.documentElement.doScroll) ? a.setTimeout(r.ready) : (d.addEventListener('DOMContentLoaded', S), a.addEventListener('load', S)); var T = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ('object' === r.type(c)) {e = !0; for (h in c) T(a, b, h, c[h], !0, f, g);}else if ( void 0 !== d && ((e = !0), r.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), (b = null)) : ((j = b), (b = function (a, b, c) {return j.call(r(a), c);}))), b) ) for (; h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c))); return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;}, U = function (a) {return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;}; function V() {this.expando = r.expando + V.uid++;}(V.uid = 1), (V.prototype = {cache: function (a) {var b = a[this.expando]; return b || ((b = {}), U(a) && (a.nodeType ? (a[this.expando] = b) : Object.defineProperty(a, this.expando, {value: b, configurable: !0 }))), b;}, set: function (a, b, c) {var d, e = this.cache(a); if ('string' == typeof b) e[r.camelCase(b)] = c; else for (d in b) e[r.camelCase(d)] = b[d]; return e;}, get: function (a, b) {return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][r.camelCase(b)];}, access: function (a, b, c) {return void 0 === b || (b && 'string' == typeof b && void 0 === c) ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b);}, remove: function (a, b) {var c, d = a[this.expando]; if (void 0 !== d) {if (void 0 !== b) {Array.isArray(b) ? (b = b.map(r.camelCase)) : ((b = r.camelCase(b)), (b = b in d ? [b] : b.match(L) || [])), (c = b.length); while (c--) delete d[b[c]];}(void 0 === b || r.isEmptyObject(d)) && (a.nodeType ? (a[this.expando] = void 0) : delete a[this.expando]);}}, hasData: function (a) {var b = a[this.expando]; return void 0 !== b && !r.isEmptyObject(b);}, }); var W = new V(), X = new V(), Y = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Z = /[A-Z]/g; function $(a) {return 'true' === a || ('false' !== a && ('null' === a ? null : a === +a + '' ? +a : Y.test(a) ? JSON.parse(a) : a));}function _(a, b, c) {var d; if (void 0 === c && 1 === a.nodeType) if (((d = 'data-' + b.replace(Z, '-$&').toLowerCase()), (c = a.getAttribute(d)), 'string' == typeof c)) {try {c = $(c);}catch (e) {}X.set(a, b, c);}else c = void 0; return c;}r.extend({hasData: function (a) {return X.hasData(a) || W.hasData(a);}, data: function (a, b, c) {return X.access(a, b, c);}, removeData: function (a, b) {X.remove(a, b);}, _data: function (a, b, c) {return W.access(a, b, c);}, _removeData: function (a, b) {W.remove(a, b);}, }), r.fn.extend({data: function (a, b) {var c, d, e, f = this[0], g = f && f.attributes; if (void 0 === a) {if (this.length && ((e = X.get(f)), 1 === f.nodeType && !W.get(f, 'hasDataAttrs'))) {c = g.length; while (c--) g[c] && ((d = g[c].name), 0 === d.indexOf('data-') && ((d = r.camelCase(d.slice(5))), _(f, d, e[d]))); W.set(f, 'hasDataAttrs', !0);}return e;}return 'object' == typeof a ? this.each(function () {X.set(this, a);}) : T( this, function (b) {var c; if (f && void 0 === b) {if (((c = X.get(f, a)), void 0 !== c)) return c; if (((c = _(f, a)), void 0 !== c)) return c;}else this.each(function () {X.set(this, a, b);});}, null, b, arguments.length > 1, null, !0, );}, removeData: function (a) {return this.each(function () {X.remove(this, a);});}, }), r.extend({queue: function (a, b, c) {var d; if (a) return (b = (b || 'fx') + 'queue'), (d = W.get(a, b)), c && (!d || Array.isArray(c) ? (d = W.access(a, b, r.makeArray(c))) : d.push(c)), d || [];}, dequeue: function (a, b) {b = b || 'fx'; var c = r.queue(a, b), d = c.length, e = c.shift(), f = r._queueHooks(a, b), g = function () {r.dequeue(a, b);}; 'inprogress' === e && ((e = c.shift()), d--), e && ('fx' === b && c.unshift('inprogress'), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();}, _queueHooks: function (a, b) {var c = b + 'queueHooks'; return ( W.get(a, c) || W.access(a, c, {empty: r.Callbacks('once memory').add(function () {W.remove(a, [b + 'queue', c]);}), }) );}, }), r.fn.extend({queue: function (a, b) {var c = 2; return ( 'string' != typeof a && ((b = a), (a = 'fx'), c--), arguments.length < c ? r.queue(this[0], a) : void 0 === b ? this : this.each(function () {var c = r.queue(this, a, b); r._queueHooks(this, a), 'fx' === a && 'inprogress' !== c[0] && r.dequeue(this, a);}) );}, dequeue: function (a) {return this.each(function () {r.dequeue(this, a);});}, clearQueue: function (a) {return this.queue(a || 'fx', []);}, promise: function (a, b) {var c, d = 1, e = r.Deferred(), f = this, g = this.length, h = function () {--d || e.resolveWith(f, [f]);}; 'string' != typeof a && ((b = a), (a = void 0)), (a = a || 'fx'); while (g--) (c = W.get(f[g], a + 'queueHooks')), c && c.empty && (d++, c.empty.add(h)); return h(), e.promise(b);}, }); var aa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ba = new RegExp('^(?:([+-])=|)(' + aa + ')([a-z%]*)$', 'i'), ca = ['Top', 'Right', 'Bottom', 'Left'], da = function (a, b) {return (a = b || a), 'none' === a.style.display || ('' === a.style.display && r.contains(a.ownerDocument, a) && 'none' === r.css(a, 'display'));}, ea = function (a, b, c, d) {var e, f, g = {}; for (f in b) (g[f] = a.style[f]), (a.style[f] = b[f]); e = c.apply(a, d || []); for (f in b) a.style[f] = g[f]; return e;}; function fa(a, b, c, d) {var e, f = 1, g = 20, h = d ? function () {return d.cur();}: function () {return r.css(a, b, '');}, i = h(), j = (c && c[3]) || (r.cssNumber[b] ? '' : 'px'), k = (r.cssNumber[b] || ('px' !== j && +i)) && ba.exec(r.css(a, b)); if (k && k[3] !== j) {(j = j || k[3]), (c = c || []), (k = +i || 1); do (f = f || '.5'), (k /= f), r.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g);}return c && ((k = +k || +i || 0), (e = c[1] ? k + (c[1] + 1) * c[2] : +c[2]), d && ((d.unit = j), (d.start = k), (d.end = e))), e;}var ga = {}; function ha(a) {var b, c = a.ownerDocument, d = a.nodeName, e = ga[d]; return e ? e : ((b = c.body.appendChild(c.createElement(d))), (e = r.css(b, 'display')), b.parentNode.removeChild(b), 'none' === e && (e = 'block'), (ga[d] = e), e);}function ia(a, b) {for (var c, d, e = [], f = 0, g = a.length; f < g; f++) (d = a[f]), d.style && ((c = d.style.display), b ? ('none' === c && ((e[f] = W.get(d, 'display') || null), e[f] || (d.style.display = '')), '' === d.style.display && da(d) && (e[f] = ha(d))) : 'none' !== c && ((e[f] = 'none'), W.set(d, 'display', c))); for (f = 0; f < g; f++) null != e[f] && (a[f].style.display = e[f]); return a;}r.fn.extend({show: function () {return ia(this, !0);}, hide: function () {return ia(this);}, toggle: function (a) {return 'boolean' == typeof a ? a ? this.show() : this.hide() : this.each(function () {da(this) ? r(this).show() : r(this).hide();});}, }); var ja = /^(?:checkbox|radio)$/i, ka = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, la = /^$|\/(?:java|ecma)script/i, ma = {option: [1, "<select multiple='multiple'>", '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''], }; (ma.optgroup = ma.option), (ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead), (ma.th = ma.td); function na(a, b) {var c; return ( (c = 'undefined' != typeof a.getElementsByTagName ? a.getElementsByTagName(b || '*') : 'undefined' != typeof a.querySelectorAll ? a.querySelectorAll(b || '*') : []), void 0 === b || (b && B(a, b)) ? r.merge([a], c) : c );}function oa(a, b) {for (var c = 0, d = a.length; c < d; c++) W.set(a[c], 'globalEval', !b || W.get(b[c], 'globalEval'));}var pa = /<|&#?\w+;/; function qa(a, b, c, d, e) {for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++) if (((f = a[n]), f || 0 === f)) if ('object' === r.type(f)) r.merge(m, f.nodeType ? [f] : f); else if (pa.test(f)) {(g = g || l.appendChild(b.createElement('div'))), (h = (ka.exec(f) || ['', ''])[1].toLowerCase()), (i = ma[h] || ma._default), (g.innerHTML = i[1] + r.htmlPrefilter(f) + i[2]), (k = i[0]); while (k--) g = g.lastChild; r.merge(m, g.childNodes), (g = l.firstChild), (g.textContent = '');}else m.push(b.createTextNode(f)); (l.textContent = ''), (n = 0); while ((f = m[n++])) if (d && r.inArray(f, d) > -1) e && e.push(f); else if (((j = r.contains(f.ownerDocument, f)), (g = na(l.appendChild(f), 'script')), j && oa(g), c)) {k = 0; while ((f = g[k++])) la.test(f.type || '') && c.push(f);}return l;}!(function () {var a = d.createDocumentFragment(), b = a.appendChild(d.createElement('div')), c = d.createElement('input'); c.setAttribute('type', 'radio'), c.setAttribute('checked', 'checked'), c.setAttribute('name', 't'), b.appendChild(c), (o.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked), (b.innerHTML = '<textarea>x</textarea>'), (o.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue);})(); var ra = d.documentElement, sa = /^key/, ta = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, ua = /^([^.]*)(?:\.(.+)|)/; function va() {return !0;}function wa() {return !1;}function xa() {try {return d.activeElement;}catch (a) {}}function ya(a, b, c, d, e, f) {var g, h; if ('object' == typeof b) {'string' != typeof c && ((d = d || c), (c = void 0)); for (h in b) ya(a, h, c, d, b[h], f); return a;}if ( (null == d && null == e ? ((e = c), (d = c = void 0)) : null == e && ('string' == typeof c ? ((e = d), (d = void 0)) : ((e = d), (d = c), (c = void 0))), e === !1) ) e = wa; else if (!e) return a; return ( 1 === f && ((g = e), (e = function (a) {return r().off(a), g.apply(this, arguments);}), (e.guid = g.guid || (g.guid = r.guid++))), a.each(function () {r.event.add(this, b, e, d, c);}) );}(r.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = W.get(a); if (q) {c.handler && ((f = c), (c = f.handler), (e = f.selector)), e && r.find.matchesSelector(ra, e), c.guid || (c.guid = r.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function (b) {return 'undefined' != typeof r && r.event.triggered !== b.type ? r.event.dispatch.apply(a, arguments) : void 0;}), (b = (b || '').match(L) || ['']), (j = b.length); while (j--) (h = ua.exec(b[j]) || []), (n = p = h[1]), (o = (h[2] || '').split('.').sort()), n && ((l = r.event.special[n] || {}), (n = (e ? l.delegateType : l.bindType) || n), (l = r.event.special[n] || {}), (k = r.extend( {type: n, origType: p, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && r.expr.match.needsContext.test(e), namespace: o.join('.'), }, f, )), (m = i[n]) || ((m = i[n] = []), (m.delegateCount = 0), (l.setup && l.setup.call(a, d, o, g) !== !1) || (a.addEventListener && a.addEventListener(n, g))), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), (r.event.global[n] = !0));}}, remove: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = W.hasData(a) && W.get(a); if (q && (i = q.events)) {(b = (b || '').match(L) || ['']), (j = b.length); while (j--) if (((h = ua.exec(b[j]) || []), (n = p = h[1]), (o = (h[2] || '').split('.').sort()), n)) {(l = r.event.special[n] || {}), (n = (d ? l.delegateType : l.bindType) || n), (m = i[n] || []), (h = h[2] && new RegExp('(^|\\.)' + o.join('\\.(?:.*\\.|)') + '(\\.|$)')), (g = f = m.length); while (f--) (k = m[f]), (!e && p !== k.origType) || (c && c.guid !== k.guid) || (h && !h.test(k.namespace)) || (d && d !== k.selector && ('**' !== d || !k.selector)) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k)); g && !m.length && ((l.teardown && l.teardown.call(a, o, q.handle) !== !1) || r.removeEvent(a, n, q.handle), delete i[n]);}else for (n in i) r.event.remove(a, n + b[j], c, d, !0); r.isEmptyObject(i) && W.remove(a, 'handle events');}}, dispatch: function (a) {var b = r.event.fix(a), c, d, e, f, g, h, i = new Array(arguments.length), j = (W.get(this, 'events') || {})[b.type] || [], k = r.event.special[b.type] || {}; for (i[0] = b, c = 1; c < arguments.length; c++) i[c] = arguments[c]; if (((b.delegateTarget = this), !k.preDispatch || k.preDispatch.call(this, b) !== !1)) {(h = r.event.handlers.call(this, b, j)), (c = 0); while ((f = h[c++]) && !b.isPropagationStopped()) {(b.currentTarget = f.elem), (d = 0); while ((g = f.handlers[d++]) && !b.isImmediatePropagationStopped()) (b.rnamespace && !b.rnamespace.test(g.namespace)) || ((b.handleObj = g), (b.data = g.data), (e = ((r.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i)), void 0 !== e && (b.result = e) === !1 && (b.preventDefault(), b.stopPropagation()));}return k.postDispatch && k.postDispatch.call(this, b), b.result;}}, handlers: function (a, b) {var c, d, e, f, g, h = [], i = b.delegateCount, j = a.target; if (i && j.nodeType && !('click' === a.type && a.button >= 1)) for (; j !== this; j = j.parentNode || this) if (1 === j.nodeType && ('click' !== a.type || j.disabled !== !0)) {for (f = [], g = {}, c = 0; c < i; c++) (d = b[c]), (e = d.selector + ' '), void 0 === g[e] && (g[e] = d.needsContext ? r(e, this).index(j) > -1 : r.find(e, this, null, [j]).length), g[e] && f.push(d); f.length && h.push({elem: j, handlers: f });}return (j = this), i < b.length && h.push({elem: j, handlers: b.slice(i) }), h;}, addProp: function (a, b) {Object.defineProperty(r.Event.prototype, a, {enumerable: !0, configurable: !0, get: r.isFunction(b) ? function () {if (this.originalEvent) return b(this.originalEvent);}: function () {if (this.originalEvent) return this.originalEvent[a];}, set: function (b) {Object.defineProperty(this, a, {enumerable: !0, configurable: !0, writable: !0, value: b });}, });}, fix: function (a) {return a[r.expando] ? a : new r.Event(a);}, special: {load: {noBubble: !0 }, focus: {trigger: function () {if (this !== xa() && this.focus) return this.focus(), !1;}, delegateType: 'focusin', }, blur: {trigger: function () {if (this === xa() && this.blur) return this.blur(), !1;}, delegateType: 'focusout', }, click: {trigger: function () {if ('checkbox' === this.type && this.click && B(this, 'input')) return this.click(), !1;}, _default: function (a) {return B(a.target, 'a');}, }, beforeunload: {postDispatch: function (a) {void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);}, }, }, }), (r.removeEvent = function (a, b, c) {a.removeEventListener && a.removeEventListener(b, c);}), (r.Event = function (a, b) {return this instanceof r.Event ? (a && a.type ? ((this.originalEvent = a), (this.type = a.type), (this.isDefaultPrevented = a.defaultPrevented || (void 0 === a.defaultPrevented && a.returnValue === !1) ? va : wa), (this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target), (this.currentTarget = a.currentTarget), (this.relatedTarget = a.relatedTarget)) : (this.type = a), b && r.extend(this, b), (this.timeStamp = (a && a.timeStamp) || r.now()), void (this[r.expando] = !0)) : new r.Event(a, b);}), (r.Event.prototype = {constructor: r.Event, isDefaultPrevented: wa, isPropagationStopped: wa, isImmediatePropagationStopped: wa, isSimulated: !1, preventDefault: function () {var a = this.originalEvent; (this.isDefaultPrevented = va), a && !this.isSimulated && a.preventDefault();}, stopPropagation: function () {var a = this.originalEvent; (this.isPropagationStopped = va), a && !this.isSimulated && a.stopPropagation();}, stopImmediatePropagation: function () {var a = this.originalEvent; (this.isImmediatePropagationStopped = va), a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();}, }), r.each( {altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (a) {var b = a.button; return null == a.which && sa.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && ta.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which;}, }, r.event.addProp, ), r.each({mouseenter: 'mouseover', mouseleave: 'mouseout', pointerenter: 'pointerover', pointerleave: 'pointerout' }, function (a, b) {r.event.special[a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return (e && (e === d || r.contains(d, e))) || ((a.type = f.origType), (c = f.handler.apply(this, arguments)), (a.type = b)), c;}, };}), r.fn.extend({on: function (a, b, c, d) {return ya(this, a, b, c, d);}, one: function (a, b, c, d) {return ya(this, a, b, c, d, 1);}, off: function (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) return (d = a.handleObj), r(a.delegateTarget).off(d.namespace ? d.origType + '.' + d.namespace : d.origType, d.selector, d.handler), this; if ('object' == typeof a) {for (e in a) this.off(e, b, a[e]); return this;}return ( (b !== !1 && 'function' != typeof b) || ((c = b), (b = void 0)), c === !1 && (c = wa), this.each(function () {r.event.remove(this, a, c, b);}) );}, }); var za = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, Aa = /<script|<style|<link/i, Ba = /checked\s*(?:[^=]|=\s*.checked.)/i, Ca = /^true\/(.*)/, Da = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function Ea(a, b) {return B(a, 'table') && B(11 !== b.nodeType ? b : b.firstChild, 'tr') ? r('>tbody', a)[0] || a : a;}function Fa(a) {return (a.type = (null !== a.getAttribute('type')) + '/' + a.type), a;}function Ga(a) {var b = Ca.exec(a.type); return b ? (a.type = b[1]) : a.removeAttribute('type'), a;}function Ha(a, b) {var c, d, e, f, g, h, i, j; if (1 === b.nodeType) {if (W.hasData(a) && ((f = W.access(a)), (g = W.set(b, f)), (j = f.events))) {delete g.handle, (g.events = {}); for (e in j) for (c = 0, d = j[e].length; c < d; c++) r.event.add(b, e, j[e][c]);}X.hasData(a) && ((h = X.access(a)), (i = r.extend({}, h)), X.set(b, i));}}function Ia(a, b) {var c = b.nodeName.toLowerCase(); 'input' === c && ja.test(a.type) ? (b.checked = a.checked) : ('input' !== c && 'textarea' !== c) || (b.defaultValue = a.defaultValue);}function Ja(a, b, c, d) {b = g.apply([], b); var e, f, h, i, j, k, l = 0, m = a.length, n = m - 1, q = b[0], s = r.isFunction(q); if (s || (m > 1 && 'string' == typeof q && !o.checkClone && Ba.test(q))) return a.each(function (e) {var f = a.eq(e); s && (b[0] = q.call(this, e, f.html())), Ja(f, b, c, d);}); if (m && ((e = qa(b, a[0].ownerDocument, !1, a, d)), (f = e.firstChild), 1 === e.childNodes.length && (e = f), f || d)) {for (h = r.map(na(e, 'script'), Fa), i = h.length; l < m; l++) (j = e), l !== n && ((j = r.clone(j, !0, !0)), i && r.merge(h, na(j, 'script'))), c.call(a[l], j, l); if (i) for (k = h[h.length - 1].ownerDocument, r.map(h, Ga), l = 0; l < i; l++) (j = h[l]), la.test(j.type || '') && !W.access(j, 'globalEval') && r.contains(k, j) && (j.src ? r._evalUrl && r._evalUrl(j.src) : p(j.textContent.replace(Da, ''), k));}return a;}function Ka(a, b, c) {for (var d, e = b ? r.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || r.cleanData(na(d)), d.parentNode && (c && r.contains(d.ownerDocument, d) && oa(na(d, 'script')), d.parentNode.removeChild(d)); return a;}r.extend({htmlPrefilter: function (a) {return a.replace(za, '<$1></$2>');}, clone: function (a, b, c) {var d, e, f, g, h = a.cloneNode(!0), i = r.contains(a.ownerDocument, a); if (!(o.noCloneChecked || (1 !== a.nodeType && 11 !== a.nodeType) || r.isXMLDoc(a))) for (g = na(h), f = na(a), d = 0, e = f.length; d < e; d++) Ia(f[d], g[d]); if (b) if (c) for (f = f || na(a), g = g || na(h), d = 0, e = f.length; d < e; d++) Ha(f[d], g[d]); else Ha(a, h); return (g = na(h, 'script')), g.length > 0 && oa(g, !i && na(a, 'script')), h;}, cleanData: function (a) {for (var b, c, d, e = r.event.special, f = 0; void 0 !== (c = a[f]); f++) if (U(c)) {if ((b = c[W.expando])) {if (b.events) for (d in b.events) e[d] ? r.event.remove(c, d) : r.removeEvent(c, d, b.handle); c[W.expando] = void 0;}c[X.expando] && (c[X.expando] = void 0);}}, }), r.fn.extend({detach: function (a) {return Ka(this, a, !0);}, remove: function (a) {return Ka(this, a);}, text: function (a) {return T( this, function (a) {return void 0 === a ? r.text(this) : this.empty().each(function () {(1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType) || (this.textContent = a);});}, null, a, arguments.length, );}, append: function () {return Ja(this, arguments, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea(this, a); b.appendChild(a);}});}, prepend: function () {return Ja(this, arguments, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea(this, a); b.insertBefore(a, b.firstChild);}});}, before: function () {return Ja(this, arguments, function (a) {this.parentNode && this.parentNode.insertBefore(a, this);});}, after: function () {return Ja(this, arguments, function (a) {this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);});}, empty: function () {for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (r.cleanData(na(a, !1)), (a.textContent = '')); return this;}, clone: function (a, b) {return ( (a = null != a && a), (b = null == b ? a : b), this.map(function () {return r.clone(this, a, b);}) );}, html: function (a) {return T( this, function (a) {var b = this[0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) return b.innerHTML; if ('string' == typeof a && !Aa.test(a) && !ma[(ka.exec(a) || ['', ''])[1].toLowerCase()]) {a = r.htmlPrefilter(a); try {for (; c < d; c++) (b = this[c] || {}), 1 === b.nodeType && (r.cleanData(na(b, !1)), (b.innerHTML = a)); b = 0;}catch (e) {}}b && this.empty().append(a);}, null, a, arguments.length, );}, replaceWith: function () {var a = []; return Ja( this, arguments, function (b) {var c = this.parentNode; r.inArray(this, a) < 0 && (r.cleanData(na(this)), c && c.replaceChild(b, this));}, a, );}, }), r.each({appendTo: 'append', prependTo: 'prepend', insertBefore: 'before', insertAfter: 'after', replaceAll: 'replaceWith' }, function (a, b) {r.fn[a] = function (a) {for (var c, d = [], e = r(a), f = e.length - 1, g = 0; g <= f; g++) (c = g === f ? this : this.clone(!0)), r(e[g])[b](c), h.apply(d, c.get()); return this.pushStack(d);};}); var La = /^margin/, Ma = new RegExp('^(' + aa + ')(?!px)[a-z%]+$', 'i'), Na = function (b) {var c = b.ownerDocument.defaultView; return (c && c.opener) || (c = a), c.getComputedStyle(b);}; !(function () {function b() {if (i) {(i.style.cssText = 'box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%'), (i.innerHTML = ''), ra.appendChild(h); var b = a.getComputedStyle(i); (c = '1%' !== b.top), (g = '2px' === b.marginLeft), (e = '4px' === b.width), (i.style.marginRight = '50%'), (f = '4px' === b.marginRight), ra.removeChild(h), (i = null);}}var c, e, f, g, h = d.createElement('div'), i = d.createElement('div'); i.style && ((i.style.backgroundClip = 'content-box'), (i.cloneNode(!0).style.backgroundClip = ''), (o.clearCloneStyle = 'content-box' === i.style.backgroundClip), (h.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute'), h.appendChild(i), r.extend(o, {pixelPosition: function () {return b(), c;}, boxSizingReliable: function () {return b(), e;}, pixelMarginRight: function () {return b(), f;}, reliableMarginLeft: function () {return b(), g;}, }));})(); function Oa(a, b, c) {var d, e, f, g, h = a.style; return ( (c = c || Na(a)), c && ((g = c.getPropertyValue(b) || c[b]), '' !== g || r.contains(a.ownerDocument, a) || (g = r.style(a, b)), !o.pixelMarginRight() && Ma.test(g) && La.test(b) && ((d = h.width), (e = h.minWidth), (f = h.maxWidth), (h.minWidth = h.maxWidth = h.width = g), (g = c.width), (h.width = d), (h.minWidth = e), (h.maxWidth = f))), void 0 !== g ? g + '' : g );}function Pa(a, b) {return {get: function () {return a() ? void delete this.get : (this.get = b).apply(this, arguments);}, };}var Qa = /^(none|table(?!-c[ea]).+)/, Ra = /^--/, Sa = {position: 'absolute', visibility: 'hidden', display: 'block' }, Ta = {letterSpacing: '0', fontWeight: '400' }, Ua = ['Webkit', 'Moz', 'ms'], Va = d.createElement('div').style; function Wa(a) {if (a in Va) return a; var b = a[0].toUpperCase() + a.slice(1), c = Ua.length; while (c--) if (((a = Ua[c] + b), a in Va)) return a;}function Xa(a) {var b = r.cssProps[a]; return b || (b = r.cssProps[a] = Wa(a) || a), b;}function Ya(a, b, c) {var d = ba.exec(b); return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || 'px') : b;}function Za(a, b, c, d, e) {var f, g = 0; for (f = c === (d ? 'border' : 'content') ? 4 : 'width' === b ? 1 : 0; f < 4; f += 2) 'margin' === c && (g += r.css(a, c + ca[f], !0, e)), d ? ('content' === c && (g -= r.css(a, 'padding' + ca[f], !0, e)), 'margin' !== c && (g -= r.css(a, 'border' + ca[f] + 'Width', !0, e))) : ((g += r.css(a, 'padding' + ca[f], !0, e)), 'padding' !== c && (g += r.css(a, 'border' + ca[f] + 'Width', !0, e))); return g;}function $a(a, b, c) {var d, e = Na(a), f = Oa(a, b, e), g = 'border-box' === r.css(a, 'boxSizing', !1, e); return Ma.test(f) ? f : ((d = g && (o.boxSizingReliable() || f === a.style[b])), 'auto' === f && (f = a['offset' + b[0].toUpperCase() + b.slice(1)]), (f = parseFloat(f) || 0), f + Za(a, b, c || (g ? 'border' : 'content'), d, e) + 'px');}r.extend({cssHooks: {opacity: {get: function (a, b) {if (b) {var c = Oa(a, 'opacity'); return '' === c ? '1' : c;}}, }, }, cssNumber: {animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0, }, cssProps: {float: 'cssFloat' }, style: function (a, b, c, d) {if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {var e, f, g, h = r.camelCase(b), i = Ra.test(b), j = a.style; return ( i || (b = Xa(h)), (g = r.cssHooks[b] || r.cssHooks[h]), void 0 === c ? g && 'get' in g && void 0 !== (e = g.get(a, !1, d)) ? e : j[b] : ((f = typeof c), 'string' === f && (e = ba.exec(c)) && e[1] && ((c = fa(a, b, e)), (f = 'number')), null != c && c === c && ('number' === f && (c += (e && e[3]) || (r.cssNumber[h] ? '' : 'px')), o.clearCloneStyle || '' !== c || 0 !== b.indexOf('background') || (j[b] = 'inherit'), (g && 'set' in g && void 0 === (c = g.set(a, c, d))) || (i ? j.setProperty(b, c) : (j[b] = c))), void 0) );}}, css: function (a, b, c, d) {var e, f, g, h = r.camelCase(b), i = Ra.test(b); return ( i || (b = Xa(h)), (g = r.cssHooks[b] || r.cssHooks[h]), g && 'get' in g && (e = g.get(a, !0, c)), void 0 === e && (e = Oa(a, b, d)), 'normal' === e && b in Ta && (e = Ta[b]), '' === c || c ? ((f = parseFloat(e)), c === !0 || isFinite(f) ? f || 0 : e) : e );}, }), r.each(['height', 'width'], function (a, b) {r.cssHooks[b] = {get: function (a, c, d) {if (c) return !Qa.test(r.css(a, 'display')) || (a.getClientRects().length && a.getBoundingClientRect().width) ? $a(a, b, d) : ea(a, Sa, function () {return $a(a, b, d);});}, set: function (a, c, d) {var e, f = d && Na(a), g = d && Za(a, b, d, 'border-box' === r.css(a, 'boxSizing', !1, f), f); return g && (e = ba.exec(c)) && 'px' !== (e[3] || 'px') && ((a.style[b] = c), (c = r.css(a, b))), Ya(a, c, g);}, };}), (r.cssHooks.marginLeft = Pa(o.reliableMarginLeft, function (a, b) {if (b) return ( (parseFloat(Oa(a, 'marginLeft')) || a.getBoundingClientRect().left - ea(a, {marginLeft: 0 }, function () {return a.getBoundingClientRect().left;})) + 'px' );})), r.each({margin: '', padding: '', border: 'Width' }, function (a, b) {(r.cssHooks[a + b] = {expand: function (c) {for (var d = 0, e = {}, f = 'string' == typeof c ? c.split(' ') : [c]; d < 4; d++) e[a + ca[d] + b] = f[d] || f[d - 2] || f[0]; return e;}, }), La.test(a) || (r.cssHooks[a + b].set = Ya);}), r.fn.extend({css: function (a, b) {return T( this, function (a, b, c) {var d, e, f = {}, g = 0; if (Array.isArray(b)) {for (d = Na(a), e = b.length; g < e; g++) f[b[g]] = r.css(a, b[g], !1, d); return f;}return void 0 !== c ? r.style(a, b, c) : r.css(a, b);}, a, b, arguments.length > 1, );}, }); function _a(a, b, c, d, e) {return new _a.prototype.init(a, b, c, d, e);}(r.Tween = _a), (_a.prototype = {constructor: _a, init: function (a, b, c, d, e, f) {(this.elem = a), (this.prop = c), (this.easing = e || r.easing._default), (this.options = b), (this.start = this.now = this.cur()), (this.end = d), (this.unit = f || (r.cssNumber[c] ? '' : 'px'));}, cur: function () {var a = _a.propHooks[this.prop]; return a && a.get ? a.get(this) : _a.propHooks._default.get(this);}, run: function (a) {var b, c = _a.propHooks[this.prop]; return ( this.options.duration ? (this.pos = b = r.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration)) : (this.pos = b = a), (this.now = (this.end - this.start) * b + this.start), this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : _a.propHooks._default.set(this), this );}, }), (_a.prototype.init.prototype = _a.prototype), (_a.propHooks = {_default: {get: function (a) {var b; return 1 !== a.elem.nodeType || (null != a.elem[a.prop] && null == a.elem.style[a.prop]) ? a.elem[a.prop] : ((b = r.css(a.elem, a.prop, '')), b && 'auto' !== b ? b : 0);}, set: function (a) {r.fx.step[a.prop] ? r.fx.step[a.prop](a) : 1 !== a.elem.nodeType || (null == a.elem.style[r.cssProps[a.prop]] && !r.cssHooks[a.prop]) ? (a.elem[a.prop] = a.now) : r.style(a.elem, a.prop, a.now + a.unit);}, }, }), (_a.propHooks.scrollTop = _a.propHooks.scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);}, }), (r.easing = {linear: function (a) {return a;}, swing: function (a) {return 0.5 - Math.cos(a * Math.PI) / 2;}, _default: 'swing', }), (r.fx = _a.prototype.init), (r.fx.step = {}); var ab, bb, cb = /^(?:toggle|show|hide)$/, db = /queueHooks$/; function eb() {bb && (d.hidden === !1 && a.requestAnimationFrame ? a.requestAnimationFrame(eb) : a.setTimeout(eb, r.fx.interval), r.fx.tick());}function fb() {return ( a.setTimeout(function () {ab = void 0;}), (ab = r.now()) );}function gb(a, b) {var c, d = 0, e = {height: a }; for (b = b ? 1 : 0; d < 4; d += 2 - b) (c = ca[d]), (e['margin' + c] = e['padding' + c] = a); return b && (e.opacity = e.width = a), e;}function hb(a, b, c) {for (var d, e = (kb.tweeners[b] || []).concat(kb.tweeners['*']), f = 0, g = e.length; f < g; f++) if ((d = e[f].call(c, b, a))) return d;}function ib(a, b, c) {var d, e, f, g, h, i, j, k, l = 'width' in b || 'height' in b, m = this, n = {}, o = a.style, p = a.nodeType && da(a), q = W.get(a, 'fxshow'); c.queue || ((g = r._queueHooks(a, 'fx')), null == g.unqueued && ((g.unqueued = 0), (h = g.empty.fire), (g.empty.fire = function () {g.unqueued || h();})), g.unqueued++, m.always(function () {m.always(function () {g.unqueued--, r.queue(a, 'fx').length || g.empty.fire();});})); for (d in b) if (((e = b[d]), cb.test(e))) {if ((delete b[d], (f = f || 'toggle' === e), e === (p ? 'hide' : 'show'))) {if ('show' !== e || !q || void 0 === q[d]) continue; p = !0;}n[d] = (q && q[d]) || r.style(a, d);}if (((i = !r.isEmptyObject(b)), i || !r.isEmptyObject(n))) {l && 1 === a.nodeType && ((c.overflow = [o.overflow, o.overflowX, o.overflowY]), (j = q && q.display), null == j && (j = W.get(a, 'display')), (k = r.css(a, 'display')), 'none' === k && (j ? (k = j) : (ia([a], !0), (j = a.style.display || j), (k = r.css(a, 'display')), ia([a]))), ('inline' === k || ('inline-block' === k && null != j)) && 'none' === r.css(a, 'float') && (i || (m.done(function () {o.display = j;}), null == j && ((k = o.display), (j = 'none' === k ? '' : k))), (o.display = 'inline-block'))), c.overflow && ((o.overflow = 'hidden'), m.always(function () {(o.overflow = c.overflow[0]), (o.overflowX = c.overflow[1]), (o.overflowY = c.overflow[2]);})), (i = !1); for (d in n) i || (q ? 'hidden' in q && (p = q.hidden) : (q = W.access(a, 'fxshow', {display: j })), f && (q.hidden = !p), p && ia([a], !0), m.done(function () {p || ia([a]), W.remove(a, 'fxshow'); for (d in n) r.style(a, d, n[d]);})), (i = hb(p ? q[d] : 0, d, m)), d in q || ((q[d] = i.start), p && ((i.end = i.start), (i.start = 0)));}}function jb(a, b) {var c, d, e, f, g; for (c in a) if ( ((d = r.camelCase(c)), (e = b[d]), (f = a[c]), Array.isArray(f) && ((e = f[1]), (f = a[c] = f[0])), c !== d && ((a[d] = f), delete a[c]), (g = r.cssHooks[d]), g && 'expand' in g) ) {(f = g.expand(f)), delete a[d]; for (c in f) c in a || ((a[c] = f[c]), (b[c] = e));}else b[d] = e;}function kb(a, b, c) {var d, e, f = 0, g = kb.prefilters.length, h = r.Deferred().always(function () {delete i.elem;}), i = function () {if (e) return !1; for (var b = ab || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; g < i; g++) j.tweens[g].run(f); return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), !1);}, j = h.promise({elem: a, props: r.extend({}, b), opts: r.extend(!0, {specialEasing: {}, easing: r.easing._default }, c), originalProperties: b, originalOptions: c, startTime: ab || fb(), duration: c.duration, tweens: [], createTween: function (b, c) {var d = r.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing); return j.tweens.push(d), d;}, stop: function (b) {var c = 0, d = b ? j.tweens.length : 0; if (e) return this; for (e = !0; c < d; c++) j.tweens[c].run(1); return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;}, }), k = j.props; for (jb(k, j.opts.specialEasing); f < g; f++) if ((d = kb.prefilters[f].call(j, a, k, j.opts))) return r.isFunction(d.stop) && (r._queueHooks(j.elem, j.opts.queue).stop = r.proxy(d.stop, d)), d; return ( r.map(k, hb, j), r.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), r.fx.timer(r.extend(i, {elem: a, anim: j, queue: j.opts.queue })), j );}(r.Animation = r.extend(kb, {tweeners: {'*': [ function (a, b) {var c = this.createTween(a, b); return fa(c.elem, a, ba.exec(b), c), c;}, ], }, tweener: function (a, b) {r.isFunction(a) ? ((b = a), (a = ['*'])) : (a = a.match(L)); for (var c, d = 0, e = a.length; d < e; d++) (c = a[d]), (kb.tweeners[c] = kb.tweeners[c] || []), kb.tweeners[c].unshift(b);}, prefilters: [ib], prefilter: function (a, b) {b ? kb.prefilters.unshift(a) : kb.prefilters.push(a);}, })), (r.speed = function (a, b, c) {var d = a && 'object' == typeof a ? r.extend({}, a) : {complete: c || (!c && b) || (r.isFunction(a) && a), duration: a, easing: (c && b) || (b && !r.isFunction(b) && b) }; return ( r.fx.off ? (d.duration = 0) : 'number' != typeof d.duration && (d.duration in r.fx.speeds ? (d.duration = r.fx.speeds[d.duration]) : (d.duration = r.fx.speeds._default)), (null != d.queue && d.queue !== !0) || (d.queue = 'fx'), (d.old = d.complete), (d.complete = function () {r.isFunction(d.old) && d.old.call(this), d.queue && r.dequeue(this, d.queue);}), d );}), r.fn.extend({fadeTo: function (a, b, c, d) {return this.filter(da).css('opacity', 0).show().end().animate({opacity: b }, a, c, d);}, animate: function (a, b, c, d) {var e = r.isEmptyObject(a), f = r.speed(b, c, d), g = function () {var b = kb(this, r.extend({}, a), f); (e || W.get(this, 'finish')) && b.stop(!0);}; return (g.finish = g), e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);}, stop: function (a, b, c) {var d = function (a) {var b = a.stop; delete a.stop, b(c);}; return ( 'string' != typeof a && ((c = b), (b = a), (a = void 0)), b && a !== !1 && this.queue(a || 'fx', []), this.each(function () {var b = !0, e = null != a && a + 'queueHooks', f = r.timers, g = W.get(this); if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && db.test(e) && d(g[e]); for (e = f.length; e--; ) f[e].elem !== this || (null != a && f[e].queue !== a) || (f[e].anim.stop(c), (b = !1), f.splice(e, 1)); (!b && c) || r.dequeue(this, a);}) );}, finish: function (a) {return ( a !== !1 && (a = a || 'fx'), this.each(function () {var b, c = W.get(this), d = c[a + 'queue'], e = c[a + 'queueHooks'], f = r.timers, g = d ? d.length : 0; for (c.finish = !0, r.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1)); for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this); delete c.finish;}) );}, }), r.each(['toggle', 'show', 'hide'], function (a, b) {var c = r.fn[b]; r.fn[b] = function (a, d, e) {return null == a || 'boolean' == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);};}), r.each( {slideDown: gb('show'), slideUp: gb('hide'), slideToggle: gb('toggle'), fadeIn: {opacity: 'show' }, fadeOut: {opacity: 'hide' }, fadeToggle: {opacity: 'toggle' }, }, function (a, b) {r.fn[a] = function (a, c, d) {return this.animate(b, a, c, d);};}, ), (r.timers = []), (r.fx.tick = function () {var a, b = 0, c = r.timers; for (ab = r.now(); b < c.length; b++) (a = c[b]), a() || c[b] !== a || c.splice(b--, 1); c.length || r.fx.stop(), (ab = void 0);}), (r.fx.timer = function (a) {r.timers.push(a), r.fx.start();}), (r.fx.interval = 13), (r.fx.start = function () {bb || ((bb = !0), eb());}), (r.fx.stop = function () {bb = null;}), (r.fx.speeds = {slow: 600, fast: 200, _default: 400 }), (r.fn.delay = function (b, c) {return ( (b = r.fx ? r.fx.speeds[b] || b : b), (c = c || 'fx'), this.queue(c, function (c, d) {var e = a.setTimeout(c, b); d.stop = function () {a.clearTimeout(e);};}) );}), (function () {var a = d.createElement('input'), b = d.createElement('select'), c = b.appendChild(d.createElement('option')); (a.type = 'checkbox'), (o.checkOn = '' !== a.value), (o.optSelected = c.selected), (a = d.createElement('input')), (a.value = 't'), (a.type = 'radio'), (o.radioValue = 't' === a.value);})(); var lb, mb = r.expr.attrHandle; r.fn.extend({attr: function (a, b) {return T(this, r.attr, a, b, arguments.length > 1);}, removeAttr: function (a) {return this.each(function () {r.removeAttr(this, a);});}, }), r.extend({attr: function (a, b, c) {var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return 'undefined' == typeof a.getAttribute ? r.prop(a, b, c) : ((1 === f && r.isXMLDoc(a)) || (e = r.attrHooks[b.toLowerCase()] || (r.expr.match.bool.test(b) ? lb : void 0)), void 0 !== c ? null === c ? void r.removeAttr(a, b) : e && 'set' in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ''), c) : e && 'get' in e && null !== (d = e.get(a, b)) ? d : ((d = r.find.attr(a, b)), null == d ? void 0 : d));}, attrHooks: {type: {set: function (a, b) {if (!o.radioValue && 'radio' === b && B(a, 'input')) {var c = a.value; return a.setAttribute('type', b), c && (a.value = c), b;}}, }, }, removeAttr: function (a, b) {var c, d = 0, e = b && b.match(L); if (e && 1 === a.nodeType) while ((c = e[d++])) a.removeAttribute(c);}, }), (lb = {set: function (a, b, c) {return b === !1 ? r.removeAttr(a, c) : a.setAttribute(c, c), c;}, }), r.each(r.expr.match.bool.source.match(/\w+/g), function (a, b) {var c = mb[b] || r.find.attr; mb[b] = function (a, b, d) {var e, f, g = b.toLowerCase(); return d || ((f = mb[g]), (mb[g] = e), (e = null != c(a, b, d) ? g : null), (mb[g] = f)), e;};}); var nb = /^(?:input|select|textarea|button)$/i, ob = /^(?:a|area)$/i; r.fn.extend({prop: function (a, b) {return T(this, r.prop, a, b, arguments.length > 1);}, removeProp: function (a) {return this.each(function () {delete this[r.propFix[a] || a];});}, }), r.extend({prop: function (a, b, c) {var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return ( (1 === f && r.isXMLDoc(a)) || ((b = r.propFix[b] || b), (e = r.propHooks[b])), void 0 !== c ? (e && 'set' in e && void 0 !== (d = e.set(a, c, b)) ? d : (a[b] = c)) : e && 'get' in e && null !== (d = e.get(a, b)) ? d : a[b] );}, propHooks: {tabIndex: {get: function (a) {var b = r.find.attr(a, 'tabindex'); return b ? parseInt(b, 10) : nb.test(a.nodeName) || (ob.test(a.nodeName) && a.href) ? 0 : -1;}, }, }, propFix: {for: 'htmlFor', class: 'className' }, }), o.optSelected || (r.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null;}, set: function (a) {var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);}, }), r.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () {r.propFix[this.toLowerCase()] = this;}); function pb(a) {var b = a.match(L) || []; return b.join(' ');}function qb(a) {return (a.getAttribute && a.getAttribute('class')) || '';}r.fn.extend({addClass: function (a) {var b, c, d, e, f, g, h, i = 0; if (r.isFunction(a)) return this.each(function (b) {r(this).addClass(a.call(this, b, qb(this)));}); if ('string' == typeof a && a) {b = a.match(L) || []; while ((c = this[i++])) if (((e = qb(c)), (d = 1 === c.nodeType && ' ' + pb(e) + ' '))) {g = 0; while ((f = b[g++])) d.indexOf(' ' + f + ' ') < 0 && (d += f + ' '); (h = pb(d)), e !== h && c.setAttribute('class', h);}}return this;}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; if (r.isFunction(a)) return this.each(function (b) {r(this).removeClass(a.call(this, b, qb(this)));}); if (!arguments.length) return this.attr('class', ''); if ('string' == typeof a && a) {b = a.match(L) || []; while ((c = this[i++])) if (((e = qb(c)), (d = 1 === c.nodeType && ' ' + pb(e) + ' '))) {g = 0; while ((f = b[g++])) while (d.indexOf(' ' + f + ' ') > -1) d = d.replace(' ' + f + ' ', ' '); (h = pb(d)), e !== h && c.setAttribute('class', h);}}return this;}, toggleClass: function (a, b) {var c = typeof a; return 'boolean' == typeof b && 'string' === c ? b ? this.addClass(a) : this.removeClass(a) : r.isFunction(a) ? this.each(function (c) {r(this).toggleClass(a.call(this, c, qb(this), b), b);}) : this.each(function () {var b, d, e, f; if ('string' === c) {(d = 0), (e = r(this)), (f = a.match(L) || []); while ((b = f[d++])) e.hasClass(b) ? e.removeClass(b) : e.addClass(b);}else (void 0 !== a && 'boolean' !== c) || ((b = qb(this)), b && W.set(this, '__className__', b), this.setAttribute && this.setAttribute('class', b || a === !1 ? '' : W.get(this, '__className__') || ''));});}, hasClass: function (a) {var b, c, d = 0; b = ' ' + a + ' '; while ((c = this[d++])) if (1 === c.nodeType && (' ' + pb(qb(c)) + ' ').indexOf(b) > -1) return !0; return !1;}, }); var rb = /\r/g; r.fn.extend({val: function (a) {var b, c, d, e = this[0]; {if (arguments.length) return ( (d = r.isFunction(a)), this.each(function (c) {var e; 1 === this.nodeType && ((e = d ? a.call(this, c, r(this).val()) : a), null == e ? (e = '') : 'number' == typeof e ? (e += '') : Array.isArray(e) && (e = r.map(e, function (a) {return null == a ? '' : a + '';})), (b = r.valHooks[this.type] || r.valHooks[this.nodeName.toLowerCase()]), (b && 'set' in b && void 0 !== b.set(this, e, 'value')) || (this.value = e));}) ); if (e) return ( (b = r.valHooks[e.type] || r.valHooks[e.nodeName.toLowerCase()]), b && 'get' in b && void 0 !== (c = b.get(e, 'value')) ? c : ((c = e.value), 'string' == typeof c ? c.replace(rb, '') : null == c ? '' : c) );}}, }), r.extend({valHooks: {option: {get: function (a) {var b = r.find.attr(a, 'value'); return null != b ? b : pb(r.text(a));}, }, select: {get: function (a) {var b, c, d, e = a.options, f = a.selectedIndex, g = 'select-one' === a.type, h = g ? null : [], i = g ? f + 1 : e.length; for (d = f < 0 ? i : g ? f : 0; d < i; d++) if (((c = e[d]), (c.selected || d === f) && !c.disabled && (!c.parentNode.disabled || !B(c.parentNode, 'optgroup')))) {if (((b = r(c).val()), g)) return b; h.push(b);}return h;}, set: function (a, b) {var c, d, e = a.options, f = r.makeArray(b), g = e.length; while (g--) (d = e[g]), (d.selected = r.inArray(r.valHooks.option.get(d), f) > -1) && (c = !0); return c || (a.selectedIndex = -1), f;}, }, }, }), r.each(['radio', 'checkbox'], function () {(r.valHooks[this] = {set: function (a, b) {if (Array.isArray(b)) return (a.checked = r.inArray(r(a).val(), b) > -1);}, }), o.checkOn || (r.valHooks[this].get = function (a) {return null === a.getAttribute('value') ? 'on' : a.value;});}); var sb = /^(?:focusinfocus|focusoutblur)$/; r.extend(r.event, {trigger: function (b, c, e, f) {var g, h, i, j, k, m, n, o = [e || d], p = l.call(b, 'type') ? b.type : b, q = l.call(b, 'namespace') ? b.namespace.split('.') : []; if ( ((h = i = e = e || d), 3 !== e.nodeType && 8 !== e.nodeType && !sb.test(p + r.event.triggered) && (p.indexOf('.') > -1 && ((q = p.split('.')), (p = q.shift()), q.sort()), (k = p.indexOf(':') < 0 && 'on' + p), (b = b[r.expando] ? b : new r.Event(p, 'object' == typeof b && b)), (b.isTrigger = f ? 2 : 3), (b.namespace = q.join('.')), (b.rnamespace = b.namespace ? new RegExp('(^|\\.)' + q.join('\\.(?:.*\\.|)') + '(\\.|$)') : null), (b.result = void 0), b.target || (b.target = e), (c = null == c ? [b] : r.makeArray(c, [b])), (n = r.event.special[p] || {}), f || !n.trigger || n.trigger.apply(e, c) !== !1)) ) {if (!f && !n.noBubble && !r.isWindow(e)) {for (j = n.delegateType || p, sb.test(j + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), (i = h); i === (e.ownerDocument || d) && o.push(i.defaultView || i.parentWindow || a);}g = 0; while ((h = o[g++]) && !b.isPropagationStopped()) (b.type = g > 1 ? j : n.bindType || p), (m = (W.get(h, 'events') || {})[b.type] && W.get(h, 'handle')), m && m.apply(h, c), (m = k && h[k]), m && m.apply && U(h) && ((b.result = m.apply(h, c)), b.result === !1 && b.preventDefault()); return ( (b.type = p), f || b.isDefaultPrevented() || (n._default && n._default.apply(o.pop(), c) !== !1) || !U(e) || (k && r.isFunction(e[p]) && !r.isWindow(e) && ((i = e[k]), i && (e[k] = null), (r.event.triggered = p), e[p](), (r.event.triggered = void 0), i && (e[k] = i))), b.result );}}, simulate: function (a, b, c) {var d = r.extend(new r.Event(), c, {type: a, isSimulated: !0 }); r.event.trigger(d, null, b);}, }), r.fn.extend({trigger: function (a, b) {return this.each(function () {r.event.trigger(a, b, this);});}, triggerHandler: function (a, b) {var c = this[0]; if (c) return r.event.trigger(a, b, c, !0);}, }), r.each( 'blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split( ' ', ), function (a, b) {r.fn[b] = function (a, c) {return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);};}, ), r.fn.extend({hover: function (a, b) {return this.mouseenter(a).mouseleave(b || a);}, }), (o.focusin = 'onfocusin' in a), o.focusin || r.each({focus: 'focusin', blur: 'focusout' }, function (a, b) {var c = function (a) {r.event.simulate(b, a.target, r.event.fix(a));}; r.event.special[b] = {setup: function () {var d = this.ownerDocument || this, e = W.access(d, b); e || d.addEventListener(a, c, !0), W.access(d, b, (e || 0) + 1);}, teardown: function () {var d = this.ownerDocument || this, e = W.access(d, b) - 1; e ? W.access(d, b, e) : (d.removeEventListener(a, c, !0), W.remove(d, b));}, };}); var tb = a.location, ub = r.now(), vb = /\?/; r.parseXML = function (b) {var c; if (!b || 'string' != typeof b) return null; try {c = new a.DOMParser().parseFromString(b, 'text/xml');}catch (d) {c = void 0;}return (c && !c.getElementsByTagName('parsererror').length) || r.error('Invalid XML: ' + b), c;}; var wb = /\[\]$/, xb = /\r?\n/g, yb = /^(?:submit|button|image|reset|file)$/i, zb = /^(?:input|select|textarea|keygen)/i; function Ab(a, b, c, d) {var e; if (Array.isArray(b)) r.each(b, function (b, e) {c || wb.test(a) ? d(a, e) : Ab(a + '[' + ('object' == typeof e && null != e ? b : '') + ']', e, c, d);}); else if (c || 'object' !== r.type(b)) d(a, b); else for (e in b) Ab(a + '[' + e + ']', b[e], c, d);}(r.param = function (a, b) {var c, d = [], e = function (a, b) {var c = r.isFunction(b) ? b() : b; d[d.length] = encodeURIComponent(a) + '=' + encodeURIComponent(null == c ? '' : c);}; if (Array.isArray(a) || (a.jquery && !r.isPlainObject(a))) r.each(a, function () {e(this.name, this.value);}); else for (c in a) Ab(c, a[c], b, e); return d.join('&');}), r.fn.extend({serialize: function () {return r.param(this.serializeArray());}, serializeArray: function () {return this.map(function () {var a = r.prop(this, 'elements'); return a ? r.makeArray(a) : this;}) .filter(function () {var a = this.type; return this.name && !r(this).is(':disabled') && zb.test(this.nodeName) && !yb.test(a) && (this.checked || !ja.test(a));}) .map(function (a, b) {var c = r(this).val(); return null == c ? null : Array.isArray(c) ? r.map(c, function (a) {return {name: b.name, value: a.replace(xb, '\r\n') };}) : {name: b.name, value: c.replace(xb, '\r\n') };}) .get();}, }); var Bb = /%20/g, Cb = /#.*$/, Db = /([?&])_=[^&]*/, Eb = /^(.*?):[ \t]*([^\r\n]*)$/gm, Fb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Gb = /^(?:GET|HEAD)$/, Hb = /^\/\ Ib = {}, Jb = {}, Kb = '*/'.concat('*'), Lb = d.createElement('a'); Lb.href = tb.href; function Mb(a) {return function (b, c) {'string' != typeof b && ((c = b), (b = '*')); var d, e = 0, f = b.toLowerCase().match(L) || []; if (r.isFunction(c)) while ((d = f[e++])) '+' === d[0] ? ((d = d.slice(1) || '*'), (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);};}function Nb(a, b, c, d) {var e = {}, f = a === Jb; function g(h) {var i; return ( (e[h] = !0), r.each(a[h] || [], function (a, h) {var j = h(b, c, d); return 'string' != typeof j || f || e[j] ? (f ? !(i = j) : void 0) : (b.dataTypes.unshift(j), g(j), !1);}), i );}return g(b.dataTypes[0]) || (!e['*'] && g('*'));}function Ob(a, b) {var c, d, e = r.ajaxSettings.flatOptions || {}; for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]); return d && r.extend(!0, a, d), a;}function Pb(a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ('*' === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader('Content-Type')); if (d) for (e in h) if (h[e] && h[e].test(d)) {i.unshift(e); break;}if (i[0] in c) f = i[0]; else {for (e in c) {if (!i[0] || a.converters[e + ' ' + i[0]]) {f = e; break;}g || (g = e);}f = f || g;}if (f) return f !== i[0] && i.unshift(f), c[f];}function Qb(a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice(); if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g]; f = k.shift(); while (f) if ((a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), (i = f), (f = k.shift()))) if ('*' === f) f = i; else if ('*' !== i && i !== f) {if (((g = j[i + ' ' + f] || j['* ' + f]), !g)) for (e in j) if (((h = e.split(' ')), h[1] === f && (g = j[i + ' ' + h[0]] || j['* ' + h[0]]))) {g === !0 ? (g = j[e]) : j[e] !== !0 && ((f = h[0]), k.unshift(h[1])); break;}if (g !== !0) if (g && a['throws']) b = g(b); else try {b = g(b);}catch (l) {return {state: 'parsererror', error: g ? l : 'No conversion from ' + i + ' to ' + f };}}return {state: 'success', data: b };}r.extend({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: tb.href, type: 'GET', isLocal: Fb.test(tb.protocol), global: !0, processData: !0, async: !0, contentType: 'application/x-www-form-urlencoded; charset=UTF-8', accepts: {'*': Kb, text: 'text/plain', html: 'text/html', xml: 'application/xml, text/xml', json: 'application/json, text/javascript' }, contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: {xml: 'responseXML', text: 'responseText', json: 'responseJSON' }, converters: {'* text': String, 'text html': !0, 'text json': JSON.parse, 'text xml': r.parseXML }, flatOptions: {url: !0, context: !0 }, }, ajaxSetup: function (a, b) {return b ? Ob(Ob(a, r.ajaxSettings), b) : Ob(r.ajaxSettings, a);}, ajaxPrefilter: Mb(Ib), ajaxTransport: Mb(Jb), ajax: function (b, c) {'object' == typeof b && ((c = b), (b = void 0)), (c = c || {}); var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup({}, c), p = o.context || o, q = o.context && (p.nodeType || p.jquery) ? r(p) : r.event, s = r.Deferred(), t = r.Callbacks('once memory'), u = o.statusCode || {}, v = {}, w = {}, x = 'canceled', y = {readyState: 0, getResponseHeader: function (a) {var b; if (k) {if (!h) {h = {}; while ((b = Eb.exec(g))) h[b[1].toLowerCase()] = b[2];}b = h[a.toLowerCase()];}return null == b ? null : b;}, getAllResponseHeaders: function () {return k ? g : null;}, setRequestHeader: function (a, b) {return null == k && ((a = w[a.toLowerCase()] = w[a.toLowerCase()] || a), (v[a] = b)), this;}, overrideMimeType: function (a) {return null == k && (o.mimeType = a), this;}, statusCode: function (a) {var b; if (a) if (k) y.always(a[y.status]); else for (b in a) u[b] = [u[b], a[b]]; return this;}, abort: function (a) {var b = a || x; return e && e.abort(b), A(0, b), this;}, }; if ( (s.promise(y), (o.url = ((b || o.url || tb.href) + '').replace(Hb, tb.protocol + ' (o.type = c.method || c.type || o.method || o.type), (o.dataTypes = (o.dataType || '*').toLowerCase().match(L) || ['']), null == o.crossDomain) ) {j = d.createElement('a'); try {(j.href = o.url), (j.href = j.href), (o.crossDomain = Lb.protocol + ' }catch (z) {o.crossDomain = !0;}}if ((o.data && o.processData && 'string' != typeof o.data && (o.data = r.param(o.data, o.traditional)), Nb(Ib, o, c, y), k)) return y; (l = r.event && o.global), l && 0 === r.active++ && r.event.trigger('ajaxStart'), (o.type = o.type.toUpperCase()), (o.hasContent = !Gb.test(o.type)), (f = o.url.replace(Cb, '')), o.hasContent ? o.data && o.processData && 0 === (o.contentType || '').indexOf('application/x-www-form-urlencoded') && (o.data = o.data.replace(Bb, '+')) : ((n = o.url.slice(f.length)), o.data && ((f += (vb.test(f) ? '&' : '?') + o.data), delete o.data), o.cache === !1 && ((f = f.replace(Db, '$1')), (n = (vb.test(f) ? '&' : '?') + '_=' + ub++ + n)), (o.url = f + n)), o.ifModified && (r.lastModified[f] && y.setRequestHeader('If-Modified-Since', r.lastModified[f]), r.etag[f] && y.setRequestHeader('If-None-Match', r.etag[f])), ((o.data && o.hasContent && o.contentType !== !1) || c.contentType) && y.setRequestHeader('Content-Type', o.contentType), y.setRequestHeader( 'Accept', o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ('*' !== o.dataTypes[0] ? ', ' + Kb + '; q=0.01' : '') : o.accepts['*'], ); for (m in o.headers) y.setRequestHeader(m, o.headers[m]); if (o.beforeSend && (o.beforeSend.call(p, y, o) === !1 || k)) return y.abort(); if (((x = 'abort'), t.add(o.complete), y.done(o.success), y.fail(o.error), (e = Nb(Jb, o, c, y)))) {if (((y.readyState = 1), l && q.trigger('ajaxSend', [y, o]), k)) return y; o.async && o.timeout > 0 && (i = a.setTimeout(function () {y.abort('timeout');}, o.timeout)); try {(k = !1), e.send(v, A);}catch (z) {if (k) throw z; A(-1, z);}}else A(-1, 'No Transport'); function A(b, c, d, h) {var j, m, n, v, w, x = c; k || ((k = !0), i && a.clearTimeout(i), (e = void 0), (g = h || ''), (y.readyState = b > 0 ? 4 : 0), (j = (b >= 200 && b < 300) || 304 === b), d && (v = Pb(o, y, d)), (v = Qb(o, v, y, j)), j ? (o.ifModified && ((w = y.getResponseHeader('Last-Modified')), w && (r.lastModified[f] = w), (w = y.getResponseHeader('etag')), w && (r.etag[f] = w)), 204 === b || 'HEAD' === o.type ? (x = 'nocontent') : 304 === b ? (x = 'notmodified') : ((x = v.state), (m = v.data), (n = v.error), (j = !n))) : ((n = x), (!b && x) || ((x = 'error'), b < 0 && (b = 0))), (y.status = b), (y.statusText = (c || x) + ''), j ? s.resolveWith(p, [m, x, y]) : s.rejectWith(p, [y, x, n]), y.statusCode(u), (u = void 0), l && q.trigger(j ? 'ajaxSuccess' : 'ajaxError', [y, o, j ? m : n]), t.fireWith(p, [y, x]), l && (q.trigger('ajaxComplete', [y, o]), --r.active || r.event.trigger('ajaxStop')));}return y;}, getJSON: function (a, b, c) {return r.get(a, b, c, 'json');}, getScript: function (a, b) {return r.get(a, void 0, b, 'script');}, }), r.each(['get', 'post'], function (a, b) {r[b] = function (a, c, d, e) {return ( r.isFunction(c) && ((e = e || d), (d = c), (c = void 0)), r.ajax(r.extend({url: a, type: b, dataType: e, data: c, success: d }, r.isPlainObject(a) && a)) );};}), (r._evalUrl = function (a) {return r.ajax({url: a, type: 'GET', dataType: 'script', cache: !0, async: !1, global: !1, throws: !0 });}), r.fn.extend({wrapAll: function (a) {var b; return ( this[0] && (r.isFunction(a) && (a = a.call(this[0])), (b = r(a, this[0].ownerDocument).eq(0).clone(!0)), this[0].parentNode && b.insertBefore(this[0]), b .map(function () {var a = this; while (a.firstElementChild) a = a.firstElementChild; return a;}) .append(this)), this );}, wrapInner: function (a) {return r.isFunction(a) ? this.each(function (b) {r(this).wrapInner(a.call(this, b));}) : this.each(function () {var b = r(this), c = b.contents(); c.length ? c.wrapAll(a) : b.append(a);});}, wrap: function (a) {var b = r.isFunction(a); return this.each(function (c) {r(this).wrapAll(b ? a.call(this, c) : a);});}, unwrap: function (a) {return ( this.parent(a) .not('body') .each(function () {r(this).replaceWith(this.childNodes);}), this );}, }), (r.expr.pseudos.hidden = function (a) {return !r.expr.pseudos.visible(a);}), (r.expr.pseudos.visible = function (a) {return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length);}), (r.ajaxSettings.xhr = function () {try {return new a.XMLHttpRequest();}catch (b) {}}); var Rb = {0: 200, 1223: 204 }, Sb = r.ajaxSettings.xhr(); (o.cors = !!Sb && 'withCredentials' in Sb), (o.ajax = Sb = !!Sb), r.ajaxTransport(function (b) {var c, d; if (o.cors || (Sb && !b.crossDomain)) return {send: function (e, f) {var g, h = b.xhr(); if ((h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)) for (g in b.xhrFields) h[g] = b.xhrFields[g]; b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e['X-Requested-With'] || (e['X-Requested-With'] = 'XMLHttpRequest'); for (g in e) h.setRequestHeader(g, e[g]); (c = function (a) {return function () {c && ((c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null), 'abort' === a ? h.abort() : 'error' === a ? 'number' != typeof h.status ? f(0, 'error') : f(h.status, h.statusText) : f( Rb[h.status] || h.status, h.statusText, 'text' !== (h.responseType || 'text') || 'string' != typeof h.responseText ? {binary: h.response }: {text: h.responseText }, h.getAllResponseHeaders(), ));};}), (h.onload = c()), (d = h.onerror = c('error')), void 0 !== h.onabort ? (h.onabort = d) : (h.onreadystatechange = function () {4 === h.readyState && a.setTimeout(function () {c && d();});}), (c = c('abort')); try {h.send((b.hasContent && b.data) || null);}catch (i) {if (c) throw i;}}, abort: function () {c && c();}, };}), r.ajaxPrefilter(function (a) {a.crossDomain && (a.contents.script = !1);}), r.ajaxSetup({accepts: {script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' }, contents: {script: /\b(?:java|ecma)script\b/ }, converters: {'text script': function (a) {return r.globalEval(a), a;}, }, }), r.ajaxPrefilter('script', function (a) {void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = 'GET');}), r.ajaxTransport('script', function (a) {if (a.crossDomain) {var b, c; return {send: function (e, f) {(b = r('<script>') .prop({charset: a.scriptCharset, src: a.url }) .on( 'load error', (c = function (a) {b.remove(), (c = null), a && f('error' === a.type ? 404 : 200, a.type);}), )), d.head.appendChild(b[0]);}, abort: function () {c && c();}, };}}); var Tb = [], Ub = /(=)\?(?=&|$)|\?\?/; r.ajaxSetup({jsonp: 'callback', jsonpCallback: function () {var a = Tb.pop() || r.expando + '_' + ub++; return (this[a] = !0), a;}, }), r.ajaxPrefilter('json jsonp', function (b, c, d) {var e, f, g, h = b.jsonp !== !1 && (Ub.test(b.url) ? 'url' : 'string' == typeof b.data && 0 === (b.contentType || '').indexOf('application/x-www-form-urlencoded') && Ub.test(b.data) && 'data'); if (h || 'jsonp' === b.dataTypes[0]) return ( (e = b.jsonpCallback = r.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback), h ? (b[h] = b[h].replace(Ub, '$1' + e)) : b.jsonp !== !1 && (b.url += (vb.test(b.url) ? '&' : '?') + b.jsonp + '=' + e), (b.converters['script json'] = function () {return g || r.error(e + ' was not called'), g[0];}), (b.dataTypes[0] = 'json'), (f = a[e]), (a[e] = function () {g = arguments;}), d.always(function () {void 0 === f ? r(a).removeProp(e) : (a[e] = f), b[e] && ((b.jsonpCallback = c.jsonpCallback), Tb.push(e)), g && r.isFunction(f) && f(g[0]), (g = f = void 0);}), 'script' );}), (o.createHTMLDocument = (function () {var a = d.implementation.createHTMLDocument('').body; return (a.innerHTML = '<form></form><form></form>'), 2 === a.childNodes.length;})()), (r.parseHTML = function (a, b, c) {if ('string' != typeof a) return []; 'boolean' == typeof b && ((c = b), (b = !1)); var e, f, g; return ( b || (o.createHTMLDocument ? ((b = d.implementation.createHTMLDocument('')), (e = b.createElement('base')), (e.href = d.location.href), b.head.appendChild(e)) : (b = d)), (f = C.exec(a)), (g = !c && []), f ? [b.createElement(f[1])] : ((f = qa([a], b, g)), g && g.length && r(g).remove(), r.merge([], f.childNodes)) );}), (r.fn.load = function (a, b, c) {var d, e, f, g = this, h = a.indexOf(' '); return ( h > -1 && ((d = pb(a.slice(h))), (a = a.slice(0, h))), r.isFunction(b) ? ((c = b), (b = void 0)) : b && 'object' == typeof b && (e = 'POST'), g.length > 0 && r .ajax({url: a, type: e || 'GET', dataType: 'html', data: b }) .done(function (a) {(f = arguments), g.html(d ? r('<div>').append(r.parseHTML(a)).find(d) : a);}) .always( c && function (a, b) {g.each(function () {c.apply(this, f || [a.responseText, b, a]);});}, ), this );}), r.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (a, b) {r.fn[b] = function (a) {return this.on(b, a);};}), (r.expr.pseudos.animated = function (a) {return r.grep(r.timers, function (b) {return a === b.elem;}).length;}), (r.offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = r.css(a, 'position'), l = r(a), m = {}; 'static' === k && (a.style.position = 'relative'), (h = l.offset()), (f = r.css(a, 'top')), (i = r.css(a, 'left')), (j = ('absolute' === k || 'fixed' === k) && (f + i).indexOf('auto') > -1), j ? ((d = l.position()), (g = d.top), (e = d.left)) : ((g = parseFloat(f) || 0), (e = parseFloat(i) || 0)), r.isFunction(b) && (b = b.call(a, c, r.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), 'using' in b ? b.using.call(a, m) : l.css(m);}, }), r.fn.extend({offset: function (a) {if (arguments.length) return void 0 === a ? this : this.each(function (b) {r.offset.setOffset(this, a, b);}); var b, c, d, e, f = this[0]; if (f) return f.getClientRects().length ? ((d = f.getBoundingClientRect()), (b = f.ownerDocument), (c = b.documentElement), (e = b.defaultView), {top: d.top + e.pageYOffset - c.clientTop, left: d.left + e.pageXOffset - c.clientLeft }) : {top: 0, left: 0 };}, position: function () {if (this[0]) {var a, b, c = this[0], d = {top: 0, left: 0 }; return ( 'fixed' === r.css(c, 'position') ? (b = c.getBoundingClientRect()) : ((a = this.offsetParent()), (b = this.offset()), B(a[0], 'html') || (d = a.offset()), (d = {top: d.top + r.css(a[0], 'borderTopWidth', !0), left: d.left + r.css(a[0], 'borderLeftWidth', !0) })), {top: b.top - d.top - r.css(c, 'marginTop', !0), left: b.left - d.left - r.css(c, 'marginLeft', !0) });}}, offsetParent: function () {return this.map(function () {var a = this.offsetParent; while (a && 'static' === r.css(a, 'position')) a = a.offsetParent; return a || ra;});}, }), r.each({scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (a, b) {var c = 'pageYOffset' === b; r.fn[a] = function (d) {return T( this, function (a, d, e) {var f; return ( r.isWindow(a) ? (f = a) : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? (f ? f[b] : a[d]) : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : (a[d] = e)) );}, a, d, arguments.length, );};}), r.each(['top', 'left'], function (a, b) {r.cssHooks[b] = Pa(o.pixelPosition, function (a, c) {if (c) return (c = Oa(a, b)), Ma.test(c) ? r(a).position()[b] + 'px' : c;});}), r.each({Height: 'height', Width: 'width' }, function (a, b) {r.each({padding: 'inner' + a, content: b, '': 'outer' + a }, function (c, d) {r.fn[d] = function (e, f) {var g = arguments.length && (c || 'boolean' != typeof e), h = c || (e === !0 || f === !0 ? 'margin' : 'border'); return T( this, function (b, c, e) {var f; return r.isWindow(b) ? 0 === d.indexOf('outer') ? b['inner' + a] : b.document.documentElement['client' + a] : 9 === b.nodeType ? ((f = b.documentElement), Math.max(b.body['scroll' + a], f['scroll' + a], b.body['offset' + a], f['offset' + a], f['client' + a])) : void 0 === e ? r.css(b, c, h) : r.style(b, c, e, h);}, b, g ? e : void 0, g, );};});}), r.fn.extend({bind: function (a, b, c) {return this.on(a, null, b, c);}, unbind: function (a, b) {return this.off(a, null, b);}, delegate: function (a, b, c, d) {return this.on(b, a, c, d);}, undelegate: function (a, b, c) {return 1 === arguments.length ? this.off(a, '**') : this.off(b, a || '**', c);}, }), (r.holdReady = function (a) {a ? r.readyWait++ : r.ready(!0);}), (r.isArray = Array.isArray), (r.parseJSON = JSON.parse), (r.nodeName = B), 'function' == typeof define && define.amd && define('jquery', [], function () {return r;}); var Vb = a.jQuery, Wb = a.$; return ( (r.noConflict = function (b) {return a.$ === r && (a.$ = Wb), b && a.jQuery === r && (a.jQuery = Vb), r;}), b || (a.jQuery = a.$ = r), r );}); (function (window) {'use strict'; var minErrConfig = {objectMaxDepth: 5, }; function errorHandlingConfig(config) {if (isObject(config)) {if (isDefined(config.objectMaxDepth)) {minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;}}else {return minErrConfig;}}function isValidObjectMaxDepth(maxDepth) {return isNumber(maxDepth) && maxDepth > 0;}function minErr(module, ErrorConstructor) {ErrorConstructor = ErrorConstructor || Error; return function () {var code = arguments[0], template = arguments[1], message = '[' + (module ? module + ':' : '') + code + '] ', templateArgs = sliceArgs(arguments, 2).map(function (arg) {return toDebugString(arg, minErrConfig.objectMaxDepth);}), paramPrefix, i; message += template.replace(/\{\d+\}/g, function (match) {var index = +match.slice(1, -1); if (index < templateArgs.length) {return templateArgs[index];}return match;}); message += '\nhttp: for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);}return new ErrorConstructor(message);};}var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/; var VALIDITY_STATE_PROPERTY = 'validity'; var hasOwnProperty = Object.prototype.hasOwnProperty; var lowercase = function (string) {return isString(string) ? string.toLowerCase() : string;}; var uppercase = function (string) {return isString(string) ? string.toUpperCase() : string;}; var manualLowercase = function (s) {return isString(s) ? s.replace(/[A-Z]/g, function (ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);}) : s;}; var manualUppercase = function (s) {return isString(s) ? s.replace(/[a-z]/g, function (ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);}) : s;}; if ('i' !== 'I'.toLowerCase()) {lowercase = manualLowercase; uppercase = manualUppercase;}var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr('ng'), angular = window.angular || (window.angular = {}), angularModule, uid = 0; msie = window.document.documentMode; function isArrayLike(obj) {if (obj == null || isWindow(obj)) return false; if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true; var length = 'length' in Object(obj) && obj.length; return isNumber(length) && ((length >= 0 && (length - 1 in obj || obj instanceof Array)) || typeof obj.item === 'function');}function forEach(obj, iterator, context) {var key, length; if (obj) {if (isFunction(obj)) {for (key in obj) {if (key !== 'prototype' && key !== 'length' && key !== 'name' && obj.hasOwnProperty(key)) {iterator.call(context, obj[key], key, obj);}}}else if (isArray(obj) || isArrayLike(obj)) {var isPrimitive = typeof obj !== 'object'; for (key = 0, length = obj.length; key < length; key++) {if (isPrimitive || key in obj) {iterator.call(context, obj[key], key, obj);}}}else if (obj.forEach && obj.forEach !== forEach) {obj.forEach(iterator, context, obj);}else if (isBlankObject(obj)) {for (key in obj) {iterator.call(context, obj[key], key, obj);}}else if (typeof obj.hasOwnProperty === 'function') {for (key in obj) {if (obj.hasOwnProperty(key)) {iterator.call(context, obj[key], key, obj);}}}else {for (key in obj) {if (hasOwnProperty.call(obj, key)) {iterator.call(context, obj[key], key, obj);}}}}return obj;}function forEachSorted(obj, iterator, context) {var keys = Object.keys(obj).sort(); for (var i = 0; i < keys.length; i++) {iterator.call(context, obj[keys[i]], keys[i]);}return keys;}function reverseParams(iteratorFn) {return function (value, key) {iteratorFn(key, value);};}function nextUid() {return ++uid;}function setHashKey(obj, h) {if (h) {obj.$$hashKey = h;}else {delete obj.$$hashKey;}}function baseExtend(dst, objs, deep) {var h = dst.$$hashKey; for (var i = 0, ii = objs.length; i < ii; ++i) {var obj = objs[i]; if (!isObject(obj) && !isFunction(obj)) continue; var keys = Object.keys(obj); for (var j = 0, jj = keys.length; j < jj; j++) {var key = keys[j]; var src = obj[key]; if (deep && isObject(src)) {if (isDate(src)) {dst[key] = new Date(src.valueOf());}else if (isRegExp(src)) {dst[key] = new RegExp(src);}else if (src.nodeName) {dst[key] = src.cloneNode(true);}else if (isElement(src)) {dst[key] = src.clone();}else {if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {}; baseExtend(dst[key], [src], true);}}else {dst[key] = src;}}}setHashKey(dst, h); return dst;}function extend(dst) {return baseExtend(dst, slice.call(arguments, 1), false);}function merge(dst) {return baseExtend(dst, slice.call(arguments, 1), true);}function toInt(str) {return parseInt(str, 10);}var isNumberNaN = Number.isNaN || function isNumberNaN(num) {return num !== num;}; function inherit(parent, extra) {return extend(Object.create(parent), extra);}function noop() {}noop.$inject = []; function identity($) {return $;}identity.$inject = []; function valueFn(value) {return function valueRef() {return value;};}function hasCustomToString(obj) {return isFunction(obj.toString) && obj.toString !== toString;}function isUndefined(value) {return typeof value === 'undefined';}function isDefined(value) {return typeof value !== 'undefined';}function isObject(value) {return value !== null && typeof value === 'object';}function isBlankObject(value) {return value !== null && typeof value === 'object' && !getPrototypeOf(value);}function isString(value) {return typeof value === 'string';}function isNumber(value) {return typeof value === 'number';}function isDate(value) {return toString.call(value) === '[object Date]';}var isArray = Array.isArray; function isError(value) {var tag = toString.call(value); switch (tag) {case '[object Error]': return true; case '[object Exception]': return true; case '[object DOMException]': return true; default: return value instanceof Error;}}function isFunction(value) {return typeof value === 'function';}function isRegExp(value) {return toString.call(value) === '[object RegExp]';}function isWindow(obj) {return obj && obj.window === obj;}function isScope(obj) {return obj && obj.$evalAsync && obj.$watch;}function isFile(obj) {return toString.call(obj) === '[object File]';}function isFormData(obj) {return toString.call(obj) === '[object FormData]';}function isBlob(obj) {return toString.call(obj) === '[object Blob]';}function isBoolean(value) {return typeof value === 'boolean';}function isPromiseLike(obj) {return obj && isFunction(obj.then);}var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/; function isTypedArray(value) {return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));}function isArrayBuffer(obj) {return toString.call(obj) === '[object ArrayBuffer]';}var trim = function (value) {return isString(value) ? value.trim() : value;}; var escapeForRegexp = function (s) {return ( s .replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1') .replace(/\x08/g, '\\x08') );}; function isElement(node) {return !!( node && (node.nodeName || (node.prop && node.attr && node.find)) );}function makeMap(str) {var obj = {}, items = str.split(','), i; for (i = 0; i < items.length; i++) {obj[items[i]] = true;}return obj;}function nodeName_(element) {return lowercase(element.nodeName || (element[0] && element[0].nodeName));}function includes(array, obj) {return Array.prototype.indexOf.call(array, obj) !== -1;}function arrayRemove(array, value) {var index = array.indexOf(value); if (index >= 0) {array.splice(index, 1);}return index;}function copy(source, destination, maxDepth) {var stackSource = []; var stackDest = []; maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN; if (destination) {if (isTypedArray(destination) || isArrayBuffer(destination)) {throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");}if (source === destination) {throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");}if (isArray(destination)) {destination.length = 0;}else {forEach(destination, function (value, key) {if (key !== '$$hashKey') {delete destination[key];}});}stackSource.push(source); stackDest.push(destination); return copyRecurse(source, destination, maxDepth);}return copyElement(source, maxDepth); function copyRecurse(source, destination, maxDepth) {maxDepth--; if (maxDepth < 0) {return '...';}var h = destination.$$hashKey; var key; if (isArray(source)) {for (var i = 0, ii = source.length; i < ii; i++) {destination.push(copyElement(source[i], maxDepth));}}else if (isBlankObject(source)) {for (key in source) {destination[key] = copyElement(source[key], maxDepth);}}else if (source && typeof source.hasOwnProperty === 'function') {for (key in source) {if (source.hasOwnProperty(key)) {destination[key] = copyElement(source[key], maxDepth);}}}else {for (key in source) {if (hasOwnProperty.call(source, key)) {destination[key] = copyElement(source[key], maxDepth);}}}setHashKey(destination, h); return destination;}function copyElement(source, maxDepth) {if (!isObject(source)) {return source;}var index = stackSource.indexOf(source); if (index !== -1) {return stackDest[index];}if (isWindow(source) || isScope(source)) {throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");}var needsRecurse = false; var destination = copyType(source); if (destination === undefined) {destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)); needsRecurse = true;}stackSource.push(source); stackDest.push(destination); return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;}function copyType(source) {switch (toString.call(source)) {case '[object Int8Array]': case '[object Int16Array]': case '[object Int32Array]': case '[object Float32Array]': case '[object Float64Array]': case '[object Uint8Array]': case '[object Uint8ClampedArray]': case '[object Uint16Array]': case '[object Uint32Array]': return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length); case '[object ArrayBuffer]': if (!source.slice) {var copied = new ArrayBuffer(source.byteLength); new Uint8Array(copied).set(new Uint8Array(source)); return copied;}return source.slice(0); case '[object Boolean]': case '[object Number]': case '[object String]': case '[object Date]': return new source.constructor(source.valueOf()); case '[object RegExp]': var re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]); re.lastIndex = source.lastIndex; return re; case '[object Blob]': return new source.constructor([source], {type: source.type });}if (isFunction(source.cloneNode)) {return source.cloneNode(true);}}}function simpleCompare(a, b) {return a === b || (a !== a && b !== b);}function equals(o1, o2) {if (o1 === o2) return true; if (o1 === null || o2 === null) return false; if (o1 !== o1 && o2 !== o2) return true; var t1 = typeof o1, t2 = typeof o2, length, key, keySet; if (t1 === t2 && t1 === 'object') {if (isArray(o1)) {if (!isArray(o2)) return false; if ((length = o1.length) === o2.length) {for (key = 0; key < length; key++) {if (!equals(o1[key], o2[key])) return false;}return true;}}else if (isDate(o1)) {if (!isDate(o2)) return false; return simpleCompare(o1.getTime(), o2.getTime());}else if (isRegExp(o1)) {if (!isRegExp(o2)) return false; return o1.toString() === o2.toString();}else {if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false; keySet = createMap(); for (key in o1) {if (key.charAt(0) === '$' || isFunction(o1[key])) continue; if (!equals(o1[key], o2[key])) return false; keySet[key] = true;}for (key in o2) {if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key])) return false;}return true;}}return false;}var csp = function () {if (!isDefined(csp.rules)) {var ngCspElement = window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'); if (ngCspElement) {var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp'); csp.rules = {noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1, noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1, };}else {csp.rules = {noUnsafeEval: noUnsafeEval(), noInlineStyle: false, };}}return csp.rules; function noUnsafeEval() {try {new Function(''); return false;}catch (e) {return true;}}}; var jq = function () {if (isDefined(jq.name_)) return jq.name_; var el; var i, ii = ngAttrPrefixes.length, prefix, name; for (i = 0; i < ii; ++i) {prefix = ngAttrPrefixes[i]; el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]'); if (el) {name = el.getAttribute(prefix + 'jq'); break;}}return (jq.name_ = name);}; function concat(array1, array2, index) {return array1.concat(slice.call(array2, index));}function sliceArgs(args, startIndex) {return slice.call(args, startIndex || 0);}function bind(self, fn) {var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : []; if (isFunction(fn) && !(fn instanceof RegExp)) {return curryArgs.length ? function () {return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);}: function () {return arguments.length ? fn.apply(self, arguments) : fn.call(self);};}else {return fn;}}function toJsonReplacer(key, value) {var val = value; if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {val = undefined;}else if (isWindow(value)) {val = '$WINDOW';}else if (value && window.document === value) {val = '$DOCUMENT';}else if (isScope(value)) {val = '$SCOPE';}return val;}function toJson(obj, pretty) {if (isUndefined(obj)) return undefined; if (!isNumber(pretty)) {pretty = pretty ? 2 : null;}return JSON.stringify(obj, toJsonReplacer, pretty);}function fromJson(json) {return isString(json) ? JSON.parse(json) : json;}var ALL_COLONS = /:/g; function timezoneToOffset(timezone, fallback) {timezone = timezone.replace(ALL_COLONS, ''); var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000; return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;}function addDateMinutes(date, minutes) {date = new Date(date.getTime()); date.setMinutes(date.getMinutes() + minutes); return date;}function convertTimezoneToLocal(date, timezone, reverse) {reverse = reverse ? -1 : 1; var dateTimezoneOffset = date.getTimezoneOffset(); var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset); return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));}function startingTag(element) {element = jqLite(element).clone().empty(); var elemHtml = jqLite('<div>').append(element).html(); try {return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (match, nodeName) {return '<' + lowercase(nodeName);});}catch (e) {return lowercase(elemHtml);}}function tryDecodeURIComponent(value) {try {return decodeURIComponent(value);}catch (e) {}}function parseKeyValue( keyValue) {var obj = {}; forEach((keyValue || '').split('&'), function (keyValue) {var splitPoint, key, val; if (keyValue) {key = keyValue = keyValue.replace(/\+/g, '%20'); splitPoint = keyValue.indexOf('='); if (splitPoint !== -1) {key = keyValue.substring(0, splitPoint); val = keyValue.substring(splitPoint + 1);}key = tryDecodeURIComponent(key); if (isDefined(key)) {val = isDefined(val) ? tryDecodeURIComponent(val) : true; if (!hasOwnProperty.call(obj, key)) {obj[key] = val;}else if (isArray(obj[key])) {obj[key].push(val);}else {obj[key] = [obj[key], val];}}}}); return obj;}function toKeyValue(obj) {var parts = []; forEach(obj, function (value, key) {if (isArray(value)) {forEach(value, function (arrayValue) {parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));});}else {parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));}}); return parts.length ? parts.join('&') : '';}function encodeUriSegment(val) {return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');}function encodeUriQuery(val, pctEncodeSpaces) {return encodeURIComponent(val) .replace(/%40/gi, '@') .replace(/%3A/gi, ':') .replace(/%24/g, '$') .replace(/%2C/gi, ',') .replace(/%3B/gi, ';') .replace(/%20/g, pctEncodeSpaces ? '%20' : '+');}var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-']; function getNgAttribute(element, ngAttr) {var attr, i, ii = ngAttrPrefixes.length; for (i = 0; i < ii; ++i) {attr = ngAttrPrefixes[i] + ngAttr; if (isString((attr = element.getAttribute(attr)))) {return attr;}}return null;}function allowAutoBootstrap(document) {var script = document.currentScript; if (!script) {return true;}if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {return false;}var attributes = script.attributes; var srcs = [attributes.getNamedItem('src'), attributes.getNamedItem('href'), attributes.getNamedItem('xlink:href')]; return srcs.every(function (src) {if (!src) {return true;}if (!src.value) {return false;}var link = document.createElement('a'); link.href = src.value; if (document.location.origin === link.origin) {return true;}switch (link.protocol) {case 'http:': case 'https:': case 'ftp:': case 'blob:': case 'file:': case 'data:': return true; default: return false;}});}var isAutoBootstrapAllowed = allowAutoBootstrap(window.document); function angularInit(element, bootstrap) {var appElement, module, config = {}; forEach(ngAttrPrefixes, function (prefix) {var name = prefix + 'app'; if (!appElement && element.hasAttribute && element.hasAttribute(name)) {appElement = element; module = element.getAttribute(name);}}); forEach(ngAttrPrefixes, function (prefix) {var name = prefix + 'app'; var candidate; if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {appElement = candidate; module = candidate.getAttribute(name);}}); if (appElement) {if (!isAutoBootstrapAllowed) {window.console.error('Angular: disabling automatic bootstrap. <script> protocol indicates ' + 'an extension, document.location.href does not match.'); return;}config.strictDi = getNgAttribute(appElement, 'strict-di') !== null; bootstrap(appElement, module ? [module] : [], config);}}function bootstrap(element, modules, config) {if (!isObject(config)) config = {}; var defaultConfig = {strictDi: false, }; config = extend(defaultConfig, config); var doBootstrap = function () {element = jqLite(element); if (element.injector()) {var tag = element[0] === window.document ? 'document' : startingTag(element); throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));}modules = modules || []; modules.unshift([ '$provide', function ($provide) {$provide.value('$rootElement', element);}, ]); if (config.debugInfoEnabled) {modules.push([ '$compileProvider', function ($compileProvider) {$compileProvider.debugInfoEnabled(true);}, ]);}modules.unshift('ng'); var injector = createInjector(modules, config.strictDi); injector.invoke([ '$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {scope.$apply(function () {element.data('$injector', injector); compile(element)(scope);});}, ]); return injector;}; var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/; var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/; if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {config.debugInfoEnabled = true; window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');}if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {return doBootstrap();}window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ''); angular.resumeBootstrap = function (extraModules) {forEach(extraModules, function (module) {modules.push(module);}); return doBootstrap();}; if (isFunction(angular.resumeDeferredBootstrap)) {angular.resumeDeferredBootstrap();}}function reloadWithDebugInfo() {window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name; window.location.reload();}function getTestability(rootElement) {var injector = angular.element(rootElement).injector(); if (!injector) {throw ngMinErr('test', 'no injector found for element argument to getTestability');}return injector.get('$$testability');}var SNAKE_CASE_REGEXP = /[A-Z]/g; function snake_case(name, separator) {separator = separator || '_'; return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {return (pos ? separator : '') + letter.toLowerCase();});}var bindJQueryFired = false; function bindJQuery() {var originalCleanData; if (bindJQueryFired) {return;}var jqName = jq(); jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName]; if (jQuery && jQuery.fn.on) {jqLite = jQuery; extend(jQuery.fn, {scope: JQLitePrototype.scope, isolateScope: JQLitePrototype.isolateScope, controller: (JQLitePrototype).controller, injector: JQLitePrototype.injector, inheritedData: JQLitePrototype.inheritedData, }); originalCleanData = jQuery.cleanData; jQuery.cleanData = function (elems) {var events; for (var i = 0, elem; (elem = elems[i]) != null; i++) {events = jQuery._data(elem, 'events'); if (events && events.$destroy) {jQuery(elem).triggerHandler('$destroy');}}originalCleanData(elems);};}else {jqLite = JQLite;}angular.element = jqLite; bindJQueryFired = true;}function assertArg(arg, name, reason) {if (!arg) {throw ngMinErr('areq', "Argument '{0}' is {1}", name || '?', reason || 'required');}return arg;}function assertArgFn(arg, name, acceptArrayAnnotation) {if (acceptArrayAnnotation && isArray(arg)) {arg = arg[arg.length - 1];}assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg)); return arg;}function assertNotHasOwnProperty(name, context) {if (name === 'hasOwnProperty') {throw ngMinErr('badname', 'hasOwnProperty is not a valid {0}name', context);}}function getter(obj, path, bindFnToScope) {if (!path) return obj; var keys = path.split('.'); var key; var lastInstance = obj; var len = keys.length; for (var i = 0; i < len; i++) {key = keys[i]; if (obj) {obj = (lastInstance = obj)[key];}}if (!bindFnToScope && isFunction(obj)) {return bind(lastInstance, obj);}return obj;}function getBlockNodes(nodes) {var node = nodes[0]; var endNode = nodes[nodes.length - 1]; var blockNodes; for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {if (blockNodes || nodes[i] !== node) {if (!blockNodes) {blockNodes = jqLite(slice.call(nodes, 0, i));}blockNodes.push(node);}}return blockNodes || nodes;}function createMap() {return Object.create(null);}function stringify(value) {if (value == null) {return '';}switch (typeof value) {case 'string': break; case 'number': value = '' + value; break; default: if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {value = value.toString();}else {value = toJson(value);}}return value;}var NODE_TYPE_ELEMENT = 1; var NODE_TYPE_ATTRIBUTE = 2; var NODE_TYPE_TEXT = 3; var NODE_TYPE_COMMENT = 8; var NODE_TYPE_DOCUMENT = 9; var NODE_TYPE_DOCUMENT_FRAGMENT = 11; function setupModuleLoader(window) {var $injectorMinErr = minErr('$injector'); var ngMinErr = minErr('ng'); function ensure(obj, name, factory) {return obj[name] || (obj[name] = factory());}var angular = ensure(window, 'angular', Object); angular.$$minErr = angular.$$minErr || minErr; return ensure(angular, 'module', function () {var modules = {}; return function module(name, requires, configFn) {var info = {}; var assertNotHasOwnProperty = function (name, context) {if (name === 'hasOwnProperty') {throw ngMinErr('badname', 'hasOwnProperty is not a valid {0}name', context);}}; assertNotHasOwnProperty(name, 'module'); if (requires && modules.hasOwnProperty(name)) {modules[name] = null;}return ensure(modules, name, function () {if (!requires) {throw $injectorMinErr( 'nomod', "Module '{0}' is not available! You either misspelled " + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name, );}var invokeQueue = []; var configBlocks = []; var runBlocks = []; var config = invokeLater('$injector', 'invoke', 'push', configBlocks); var moduleInstance = {_invokeQueue: invokeQueue, _configBlocks: configBlocks, _runBlocks: runBlocks, info: function (value) {if (isDefined(value)) {if (!isObject(value)) throw ngMinErr('aobj', "Argument '{0}' must be an object", 'value'); info = value; return this;}return info;}, requires: requires, name: name, provider: invokeLaterAndSetModuleName('$provide', 'provider'), factory: invokeLaterAndSetModuleName('$provide', 'factory'), service: invokeLaterAndSetModuleName('$provide', 'service'), value: invokeLater('$provide', 'value'), constant: invokeLater('$provide', 'constant', 'unshift'), decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks), animation: invokeLaterAndSetModuleName('$animateProvider', 'register'), filter: invokeLaterAndSetModuleName('$filterProvider', 'register'), controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'), directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'), component: invokeLaterAndSetModuleName('$compileProvider', 'component'), config: config, run: function (block) {runBlocks.push(block); return this;}, }; if (configFn) {config(configFn);}return moduleInstance; function invokeLater(provider, method, insertMethod, queue) {if (!queue) queue = invokeQueue; return function () {queue[insertMethod || 'push']([provider, method, arguments]); return moduleInstance;};}function invokeLaterAndSetModuleName(provider, method, queue) {if (!queue) queue = invokeQueue; return function (recipeName, factoryFunction) {if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name; queue.push([provider, method, arguments]); return moduleInstance;};}});};});}function shallowCopy(src, dst) {if (isArray(src)) {dst = dst || []; for (var i = 0, ii = src.length; i < ii; i++) {dst[i] = src[i];}}else if (isObject(src)) {dst = dst || {}; for (var key in src) {if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {dst[key] = src[key];}}}return dst || src;}function serializeObject(obj, maxDepth) {var seen = []; if (isValidObjectMaxDepth(maxDepth)) {obj = angular.copy(obj, null, maxDepth);}return JSON.stringify(obj, function (key, val) {val = toJsonReplacer(key, val); if (isObject(val)) {if (seen.indexOf(val) >= 0) return '...'; seen.push(val);}return val;});}function toDebugString(obj, maxDepth) {if (typeof obj === 'function') {return obj.toString().replace(/ \{[\s\S]*$/, '');}else if (isUndefined(obj)) {return 'undefined';}else if (typeof obj !== 'string') {return serializeObject(obj, maxDepth);}return obj;}var version = {full: '1.6.6', major: 1, minor: 6, dot: 6, codeName: 'interdimensional-cable', }; function publishExternalAPI(angular) {extend(angular, {errorHandlingConfig: errorHandlingConfig, bootstrap: bootstrap, copy: copy, extend: extend, merge: merge, equals: equals, element: jqLite, forEach: forEach, injector: createInjector, noop: noop, bind: bind, toJson: toJson, fromJson: fromJson, identity: identity, isUndefined: isUndefined, isDefined: isDefined, isString: isString, isFunction: isFunction, isObject: isObject, isNumber: isNumber, isElement: isElement, isArray: isArray, version: version, isDate: isDate, lowercase: lowercase, uppercase: uppercase, callbacks: {$$counter: 0 }, getTestability: getTestability, reloadWithDebugInfo: reloadWithDebugInfo, $$minErr: minErr, $$csp: csp, $$encodeUriSegment: encodeUriSegment, $$encodeUriQuery: encodeUriQuery, $$stringify: stringify, }); angularModule = setupModuleLoader(window); angularModule( 'ng', ['ngLocale'], [ '$provide', function ngModule($provide) {$provide.provider({$$sanitizeUri: $$SanitizeUriProvider, }); $provide .provider('$compile', $CompileProvider) .directive({a: htmlAnchorDirective, input: inputDirective, textarea: inputDirective, form: formDirective, script: scriptDirective, select: selectDirective, option: optionDirective, ngBind: ngBindDirective, ngBindHtml: ngBindHtmlDirective, ngBindTemplate: ngBindTemplateDirective, ngClass: ngClassDirective, ngClassEven: ngClassEvenDirective, ngClassOdd: ngClassOddDirective, ngCloak: ngCloakDirective, ngController: ngControllerDirective, ngForm: ngFormDirective, ngHide: ngHideDirective, ngIf: ngIfDirective, ngInclude: ngIncludeDirective, ngInit: ngInitDirective, ngNonBindable: ngNonBindableDirective, ngPluralize: ngPluralizeDirective, ngRepeat: ngRepeatDirective, ngShow: ngShowDirective, ngStyle: ngStyleDirective, ngSwitch: ngSwitchDirective, ngSwitchWhen: ngSwitchWhenDirective, ngSwitchDefault: ngSwitchDefaultDirective, ngOptions: ngOptionsDirective, ngTransclude: ngTranscludeDirective, ngModel: ngModelDirective, ngList: ngListDirective, ngChange: ngChangeDirective, pattern: patternDirective, ngPattern: patternDirective, required: requiredDirective, ngRequired: requiredDirective, minlength: minlengthDirective, ngMinlength: minlengthDirective, maxlength: maxlengthDirective, ngMaxlength: maxlengthDirective, ngValue: ngValueDirective, ngModelOptions: ngModelOptionsDirective, }) .directive({ngInclude: ngIncludeFillContentDirective, }) .directive(ngAttributeAliasDirectives) .directive(ngEventDirectives); $provide.provider({$anchorScroll: $AnchorScrollProvider, $animate: $AnimateProvider, $animateCss: $CoreAnimateCssProvider, $$animateJs: $$CoreAnimateJsProvider, $$animateQueue: $$CoreAnimateQueueProvider, $$AnimateRunner: $$AnimateRunnerFactoryProvider, $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider, $browser: $BrowserProvider, $cacheFactory: $CacheFactoryProvider, $controller: $ControllerProvider, $document: $DocumentProvider, $$isDocumentHidden: $$IsDocumentHiddenProvider, $exceptionHandler: $ExceptionHandlerProvider, $filter: $FilterProvider, $$forceReflow: $$ForceReflowProvider, $interpolate: $InterpolateProvider, $interval: $IntervalProvider, $http: $HttpProvider, $httpParamSerializer: $HttpParamSerializerProvider, $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider, $httpBackend: $HttpBackendProvider, $xhrFactory: $xhrFactoryProvider, $jsonpCallbacks: $jsonpCallbacksProvider, $location: $LocationProvider, $log: $LogProvider, $parse: $ParseProvider, $rootScope: $RootScopeProvider, $q: $QProvider, $$q: $$QProvider, $sce: $SceProvider, $sceDelegate: $SceDelegateProvider, $sniffer: $SnifferProvider, $templateCache: $TemplateCacheProvider, $templateRequest: $TemplateRequestProvider, $$testability: $$TestabilityProvider, $timeout: $TimeoutProvider, $window: $WindowProvider, $$rAF: $$RAFProvider, $$jqLite: $$jqLiteProvider, $$Map: $$MapProvider, $$cookieReader: $$CookieReaderProvider, });}, ], ).info({angularVersion: '1.6.6' });}JQLite.expando = 'ng339'; var jqCache = (JQLite.cache = {}), jqId = 1; JQLite._data = function (node) {return this.cache[node[this.expando]] || {};}; function jqNextId() {return ++jqId;}var DASH_LOWERCASE_REGEXP = /-([a-z])/g; var MS_HACK_REGEXP = /^-ms-/; var MOUSE_EVENT_MAP = {mouseleave: 'mouseout', mouseenter: 'mouseover' }; var jqLiteMinErr = minErr('jqLite'); function cssKebabToCamel(name) {return kebabToCamel(name.replace(MS_HACK_REGEXP, 'ms-'));}function fnCamelCaseReplace(all, letter) {return letter.toUpperCase();}function kebabToCamel(name) {return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);}var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/; var HTML_REGEXP = /<|&#?\w+;/; var TAG_NAME_REGEXP = /<([\w:-]+)/; var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi; var wrapMap = {option: [1, '<select multiple="multiple">', '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''], }; wrapMap.optgroup = wrapMap.option; wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead; wrapMap.th = wrapMap.td; function jqLiteIsTextNode(html) {return !HTML_REGEXP.test(html);}function jqLiteAcceptsData(node) {var nodeType = node.nodeType; return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;}function jqLiteHasData(node) {for (var key in jqCache[node.ng339]) {return true;}return false;}function jqLiteBuildFragment(html, context) {var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i; if (jqLiteIsTextNode(html)) {nodes.push(context.createTextNode(html));}else {tmp = fragment.appendChild(context.createElement('div')); tag = (TAG_NAME_REGEXP.exec(html) || ['', ''])[1].toLowerCase(); wrap = wrapMap[tag] || wrapMap._default; tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2]; i = wrap[0]; while (i--) {tmp = tmp.lastChild;}nodes = concat(nodes, tmp.childNodes); tmp = fragment.firstChild; tmp.textContent = '';}fragment.textContent = ''; fragment.innerHTML = ''; forEach(nodes, function (node) {fragment.appendChild(node);}); return fragment;}function jqLiteParseHTML(html, context) {context = context || window.document; var parsed; if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {return [context.createElement(parsed[1])];}if ((parsed = jqLiteBuildFragment(html, context))) {return parsed.childNodes;}return [];}function jqLiteWrapNode(node, wrapper) {var parent = node.parentNode; if (parent) {parent.replaceChild(wrapper, node);}wrapper.appendChild(node);}var jqLiteContains = window.Node.prototype.contains || function (arg) {return !!(this.compareDocumentPosition(arg) & 16);}; function JQLite(element) {if (element instanceof JQLite) {return element;}var argIsString; if (isString(element)) {element = trim(element); argIsString = true;}if (!(this instanceof JQLite)) {if (argIsString && element.charAt(0) !== '<') {throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http: }return new JQLite(element);}if (argIsString) {jqLiteAddNodes(this, jqLiteParseHTML(element));}else if (isFunction(element)) {jqLiteReady(element);}else {jqLiteAddNodes(this, element);}}function jqLiteClone(element) {return element.cloneNode(true);}function jqLiteDealoc(element, onlyDescendants) {if (!onlyDescendants && jqLiteAcceptsData(element)) jqLite.cleanData([element]); if (element.querySelectorAll) {jqLite.cleanData(element.querySelectorAll('*'));}}function jqLiteOff(element, type, fn, unsupported) {if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument'); var expandoStore = jqLiteExpandoStore(element); var events = expandoStore && expandoStore.events; var handle = expandoStore && expandoStore.handle; if (!handle) return; if (!type) {for (type in events) {if (type !== '$destroy') {element.removeEventListener(type, handle);}delete events[type];}}else {var removeHandler = function (type) {var listenerFns = events[type]; if (isDefined(fn)) {arrayRemove(listenerFns || [], fn);}if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {element.removeEventListener(type, handle); delete events[type];}}; forEach(type.split(' '), function (type) {removeHandler(type); if (MOUSE_EVENT_MAP[type]) {removeHandler(MOUSE_EVENT_MAP[type]);}});}}function jqLiteRemoveData(element, name) {var expandoId = element.ng339; var expandoStore = expandoId && jqCache[expandoId]; if (expandoStore) {if (name) {delete expandoStore.data[name]; return;}if (expandoStore.handle) {if (expandoStore.events.$destroy) {expandoStore.handle({}, '$destroy');}jqLiteOff(element);}delete jqCache[expandoId]; element.ng339 = undefined;}}function jqLiteExpandoStore(element, createIfNecessary) {var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId]; if (createIfNecessary && !expandoStore) {element.ng339 = expandoId = jqNextId(); expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined };}return expandoStore;}function jqLiteData(element, key, value) {if (jqLiteAcceptsData(element)) {var prop; var isSimpleSetter = isDefined(value); var isSimpleGetter = !isSimpleSetter && key && !isObject(key); var massGetter = !key; var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter); var data = expandoStore && expandoStore.data; if (isSimpleSetter) {data[kebabToCamel(key)] = value;}else {if (massGetter) {return data;}else {if (isSimpleGetter) {return data && data[kebabToCamel(key)];}else {for (prop in key) {data[kebabToCamel(prop)] = key[prop];}}}}}}function jqLiteHasClass(element, selector) {if (!element.getAttribute) return false; return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;}function jqLiteRemoveClass(element, cssClasses) {if (cssClasses && element.setAttribute) {forEach(cssClasses.split(' '), function (cssClass) {element.setAttribute( 'class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')), );});}}function jqLiteAddClass(element, cssClasses) {if (cssClasses && element.setAttribute) {var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' '); forEach(cssClasses.split(' '), function (cssClass) {cssClass = trim(cssClass); if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {existingClasses += cssClass + ' ';}}); element.setAttribute('class', trim(existingClasses));}}function jqLiteAddNodes(root, elements) {if (elements) {if (elements.nodeType) {root[root.length++] = elements;}else {var length = elements.length; if (typeof length === 'number' && elements.window !== elements) {if (length) {for (var i = 0; i < length; i++) {root[root.length++] = elements[i];}}}else {root[root.length++] = elements;}}}}function jqLiteController(element, name) {return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');}function jqLiteInheritedData(element, name, value) {if (element.nodeType === NODE_TYPE_DOCUMENT) {element = element.documentElement;}var names = isArray(name) ? name : [name]; while (element) {for (var i = 0, ii = names.length; i < ii; i++) {if (isDefined((value = jqLite.data(element, names[i])))) return value;}element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);}}function jqLiteEmpty(element) {jqLiteDealoc(element, true); while (element.firstChild) {element.removeChild(element.firstChild);}}function jqLiteRemove(element, keepData) {if (!keepData) jqLiteDealoc(element); var parent = element.parentNode; if (parent) parent.removeChild(element);}function jqLiteDocumentLoaded(action, win) {win = win || window; if (win.document.readyState === 'complete') {win.setTimeout(action);}else {jqLite(win).on('load', action);}}function jqLiteReady(fn) {function trigger() {window.document.removeEventListener('DOMContentLoaded', trigger); window.removeEventListener('load', trigger); fn();}if (window.document.readyState === 'complete') {window.setTimeout(fn);}else {window.document.addEventListener('DOMContentLoaded', trigger); window.addEventListener('load', trigger);}}var JQLitePrototype = (JQLite.prototype = {ready: jqLiteReady, toString: function () {var value = []; forEach(this, function (e) {value.push('' + e);}); return '[' + value.join(', ') + ']';}, eq: function (index) {return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);}, length: 0, push: push, sort: [].sort, splice: [].splice, }); var BOOLEAN_ATTR = {}; forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {BOOLEAN_ATTR[lowercase(value)] = value;}); var BOOLEAN_ELEMENTS = {}; forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {BOOLEAN_ELEMENTS[value] = true;}); var ALIASED_ATTR = {ngMinlength: 'minlength', ngMaxlength: 'maxlength', ngMin: 'min', ngMax: 'max', ngPattern: 'pattern', ngStep: 'step', }; function getBooleanAttrName(element, name) {var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()]; return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;}function getAliasedAttrName(name) {return ALIASED_ATTR[name];}forEach( {data: jqLiteData, removeData: jqLiteRemoveData, hasData: jqLiteHasData, cleanData: function jqLiteCleanData(nodes) {for (var i = 0, ii = nodes.length; i < ii; i++) {jqLiteRemoveData(nodes[i]);}}, }, function (fn, name) {JQLite[name] = fn;}, ); forEach( {data: jqLiteData, inheritedData: jqLiteInheritedData, scope: function (element) {return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);}, isolateScope: function (element) {return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');}, controller: jqLiteController, injector: function (element) {return jqLiteInheritedData(element, '$injector');}, removeAttr: function (element, name) {element.removeAttribute(name);}, hasClass: jqLiteHasClass, css: function (element, name, value) {name = cssKebabToCamel(name); if (isDefined(value)) {element.style[name] = value;}else {return element.style[name];}}, attr: function (element, name, value) {var ret; var nodeType = element.nodeType; if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {return;}var lowercasedName = lowercase(name); var isBooleanAttr = BOOLEAN_ATTR[lowercasedName]; if (isDefined(value)) {if (value === null || (value === false && isBooleanAttr)) {element.removeAttribute(name);}else {element.setAttribute(name, isBooleanAttr ? lowercasedName : value);}}else {ret = element.getAttribute(name); if (isBooleanAttr && ret !== null) {ret = lowercasedName;}return ret === null ? undefined : ret;}}, prop: function (element, name, value) {if (isDefined(value)) {element[name] = value;}else {return element[name];}}, text: (function () {getText.$dv = ''; return getText; function getText(element, value) {if (isUndefined(value)) {var nodeType = element.nodeType; return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';}element.textContent = value;}})(), val: function (element, value) {if (isUndefined(value)) {if (element.multiple && nodeName_(element) === 'select') {var result = []; forEach(element.options, function (option) {if (option.selected) {result.push(option.value || option.text);}}); return result;}return element.value;}element.value = value;}, html: function (element, value) {if (isUndefined(value)) {return element.innerHTML;}jqLiteDealoc(element, true); element.innerHTML = value;}, empty: jqLiteEmpty, }, function (fn, name) {JQLite.prototype[name] = function (arg1, arg2) {var i, key; var nodeCount = this.length; if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {if (isObject(arg1)) {for (i = 0; i < nodeCount; i++) {if (fn === jqLiteData) {fn(this[i], arg1);}else {for (key in arg1) {fn(this[i], key, arg1[key]);}}}return this;}else {var value = fn.$dv; var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount; for (var j = 0; j < jj; j++) {var nodeValue = fn(this[j], arg1, arg2); value = value ? value + nodeValue : nodeValue;}return value;}}else {for (i = 0; i < nodeCount; i++) {fn(this[i], arg1, arg2);}return this;}};}, ); function createEventHandler(element, events) {var eventHandler = function (event, type) {event.isDefaultPrevented = function () {return event.defaultPrevented;}; var eventFns = events[type || event.type]; var eventFnsLength = eventFns ? eventFns.length : 0; if (!eventFnsLength) return; if (isUndefined(event.immediatePropagationStopped)) {var originalStopImmediatePropagation = event.stopImmediatePropagation; event.stopImmediatePropagation = function () {event.immediatePropagationStopped = true; if (event.stopPropagation) {event.stopPropagation();}if (originalStopImmediatePropagation) {originalStopImmediatePropagation.call(event);}};}event.isImmediatePropagationStopped = function () {return event.immediatePropagationStopped === true;}; var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper; if (eventFnsLength > 1) {eventFns = shallowCopy(eventFns);}for (var i = 0; i < eventFnsLength; i++) {if (!event.isImmediatePropagationStopped()) {handlerWrapper(element, event, eventFns[i]);}}}; eventHandler.elem = element; return eventHandler;}function defaultHandlerWrapper(element, event, handler) {handler.call(element, event);}function specialMouseHandlerWrapper(target, event, handler) {var related = event.relatedTarget; if (!related || (related !== target && !jqLiteContains.call(target, related))) {handler.call(target, event);}}forEach( {removeData: jqLiteRemoveData, on: function jqLiteOn(element, type, fn, unsupported) {if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters'); if (!jqLiteAcceptsData(element)) {return;}var expandoStore = jqLiteExpandoStore(element, true); var events = expandoStore.events; var handle = expandoStore.handle; if (!handle) {handle = expandoStore.handle = createEventHandler(element, events);}var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type]; var i = types.length; var addHandler = function (type, specialHandlerWrapper, noEventListener) {var eventFns = events[type]; if (!eventFns) {eventFns = events[type] = []; eventFns.specialHandlerWrapper = specialHandlerWrapper; if (type !== '$destroy' && !noEventListener) {element.addEventListener(type, handle);}}eventFns.push(fn);}; while (i--) {type = types[i]; if (MOUSE_EVENT_MAP[type]) {addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper); addHandler(type, undefined, true);}else {addHandler(type);}}}, off: jqLiteOff, one: function (element, type, fn) {element = jqLite(element); element.on(type, function onFn() {element.off(type, fn); element.off(type, onFn);}); element.on(type, fn);}, replaceWith: function (element, replaceNode) {var index, parent = element.parentNode; jqLiteDealoc(element); forEach(new JQLite(replaceNode), function (node) {if (index) {parent.insertBefore(node, index.nextSibling);}else {parent.replaceChild(node, element);}index = node;});}, children: function (element) {var children = []; forEach(element.childNodes, function (element) {if (element.nodeType === NODE_TYPE_ELEMENT) {children.push(element);}}); return children;}, contents: function (element) {return element.contentDocument || element.childNodes || [];}, append: function (element, node) {var nodeType = element.nodeType; if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return; node = new JQLite(node); for (var i = 0, ii = node.length; i < ii; i++) {var child = node[i]; element.appendChild(child);}}, prepend: function (element, node) {if (element.nodeType === NODE_TYPE_ELEMENT) {var index = element.firstChild; forEach(new JQLite(node), function (child) {element.insertBefore(child, index);});}}, wrap: function (element, wrapNode) {jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);}, remove: jqLiteRemove, detach: function (element) {jqLiteRemove(element, true);}, after: function (element, newElement) {var index = element, parent = element.parentNode; if (parent) {newElement = new JQLite(newElement); for (var i = 0, ii = newElement.length; i < ii; i++) {var node = newElement[i]; parent.insertBefore(node, index.nextSibling); index = node;}}}, addClass: jqLiteAddClass, removeClass: jqLiteRemoveClass, toggleClass: function (element, selector, condition) {if (selector) {forEach(selector.split(' '), function (className) {var classCondition = condition; if (isUndefined(classCondition)) {classCondition = !jqLiteHasClass(element, className);}(classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);});}}, parent: function (element) {var parent = element.parentNode; return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;}, next: function (element) {return element.nextElementSibling;}, find: function (element, selector) {if (element.getElementsByTagName) {return element.getElementsByTagName(selector);}else {return [];}}, clone: jqLiteClone, triggerHandler: function (element, event, extraParameters) {var dummyEvent, eventFnsCopy, handlerArgs; var eventName = event.type || event; var expandoStore = jqLiteExpandoStore(element); var events = expandoStore && expandoStore.events; var eventFns = events && events[eventName]; if (eventFns) {dummyEvent = {preventDefault: function () {this.defaultPrevented = true;}, isDefaultPrevented: function () {return this.defaultPrevented === true;}, stopImmediatePropagation: function () {this.immediatePropagationStopped = true;}, isImmediatePropagationStopped: function () {return this.immediatePropagationStopped === true;}, stopPropagation: noop, type: eventName, target: element, }; if (event.type) {dummyEvent = extend(dummyEvent, event);}eventFnsCopy = shallowCopy(eventFns); handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent]; forEach(eventFnsCopy, function (fn) {if (!dummyEvent.isImmediatePropagationStopped()) {fn.apply(element, handlerArgs);}});}}, }, function (fn, name) {JQLite.prototype[name] = function (arg1, arg2, arg3) {var value; for (var i = 0, ii = this.length; i < ii; i++) {if (isUndefined(value)) {value = fn(this[i], arg1, arg2, arg3); if (isDefined(value)) {value = jqLite(value);}}else {jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));}}return isDefined(value) ? value : this;};}, ); JQLite.prototype.bind = JQLite.prototype.on; JQLite.prototype.unbind = JQLite.prototype.off; function $$jqLiteProvider() {this.$get = function $$jqLite() {return extend(JQLite, {hasClass: function (node, classes) {if (node.attr) node = node[0]; return jqLiteHasClass(node, classes);}, addClass: function (node, classes) {if (node.attr) node = node[0]; return jqLiteAddClass(node, classes);}, removeClass: function (node, classes) {if (node.attr) node = node[0]; return jqLiteRemoveClass(node, classes);}, });};}function hashKey(obj, nextUidFn) {var key = obj && obj.$$hashKey; if (key) {if (typeof key === 'function') {key = obj.$$hashKey();}return key;}var objType = typeof obj; if (objType === 'function' || (objType === 'object' && obj !== null)) {key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();}else {key = objType + ':' + obj;}return key;}var nanKey = Object.create(null); function NgMapShim() {this._keys = []; this._values = []; this._lastKey = NaN; this._lastIndex = -1;}NgMapShim.prototype = {_idx: function (key) {if (key === this._lastKey) {return this._lastIndex;}this._lastKey = key; this._lastIndex = this._keys.indexOf(key); return this._lastIndex;}, _transformKey: function (key) {return isNumberNaN(key) ? nanKey : key;}, get: function (key) {key = this._transformKey(key); var idx = this._idx(key); if (idx !== -1) {return this._values[idx];}}, set: function (key, value) {key = this._transformKey(key); var idx = this._idx(key); if (idx === -1) {idx = this._lastIndex = this._keys.length;}this._keys[idx] = key; this._values[idx] = value;}, delete: function (key) {key = this._transformKey(key); var idx = this._idx(key); if (idx === -1) {return false;}this._keys.splice(idx, 1); this._values.splice(idx, 1); this._lastKey = NaN; this._lastIndex = -1; return true;}, }; var NgMap = NgMapShim; var $$MapProvider = [ function () {this.$get = [ function () {return NgMap;}, ];}, ]; var ARROW_ARG = /^([^(]+?)=>/; var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m; var FN_ARG_SPLIT = /,/; var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/; var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm; var $injectorMinErr = minErr('$injector'); function stringifyFn(fn) {return Function.prototype.toString.call(fn);}function extractArgs(fn) {var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS); return args;}function anonFn(fn) {var args = extractArgs(fn); if (args) {return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';}return 'fn';}function annotate(fn, strictDi, name) {var $inject, argDecl, last; if (typeof fn === 'function') {if (!($inject = fn.$inject)) {$inject = []; if (fn.length) {if (strictDi) {if (!isString(name) || !name) {name = fn.name || anonFn(fn);}throw $injectorMinErr('strictdi', '{0}is not using explicit annotation and cannot be invoked in strict mode', name);}argDecl = extractArgs(fn); forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {arg.replace(FN_ARG, function (all, underscore, name) {$inject.push(name);});});}fn.$inject = $inject;}}else if (isArray(fn)) {last = fn.length - 1; assertArgFn(fn[last], 'fn'); $inject = fn.slice(0, last);}else {assertArgFn(fn, 'fn', true);}return $inject;}function createInjector(modulesToLoad, strictDi) {strictDi = strictDi === true; var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new NgMap(), providerCache = {$provide: {provider: supportObject(provider), factory: supportObject(factory), service: supportObject(service), value: supportObject(value), constant: supportObject(constant), decorator: decorator, }, }, providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {if (angular.isString(caller)) {path.push(caller);}throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));})), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {var provider = providerInjector.get(serviceName + providerSuffix, caller); return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);}), instanceInjector = protoInstanceInjector; providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector) }; instanceInjector.modules = providerInjector.modules = createMap(); var runBlocks = loadModules(modulesToLoad); instanceInjector = protoInstanceInjector.get('$injector'); instanceInjector.strictDi = strictDi; forEach(runBlocks, function (fn) {if (fn) instanceInjector.invoke(fn);}); return instanceInjector; function supportObject(delegate) {return function (key, value) {if (isObject(key)) {forEach(key, reverseParams(delegate));}else {return delegate(key, value);}};}function provider(name, provider_) {assertNotHasOwnProperty(name, 'service'); if (isFunction(provider_) || isArray(provider_)) {provider_ = providerInjector.instantiate(provider_);}if (!provider_.$get) {throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);}return (providerCache[name + providerSuffix] = provider_);}function enforceReturnValue(name, factory) {return function enforcedReturnValue() {var result = instanceInjector.invoke(factory, this); if (isUndefined(result)) {throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);}return result;};}function factory(name, factoryFn, enforce) {return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn, });}function service(name, constructor) {return factory(name, [ '$injector', function ($injector) {return $injector.instantiate(constructor);}, ]);}function value(name, val) {return factory(name, valueFn(val), false);}function constant(name, value) {assertNotHasOwnProperty(name, 'constant'); providerCache[name] = value; instanceCache[name] = value;}function decorator(serviceName, decorFn) {var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get; origProvider.$get = function () {var origInstance = instanceInjector.invoke(orig$get, origProvider); return instanceInjector.invoke(decorFn, null, {$delegate: origInstance });};}function loadModules(modulesToLoad) {assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array'); var runBlocks = [], moduleFn; forEach(modulesToLoad, function (module) {if (loadedModules.get(module)) return; loadedModules.set(module, true); function runInvokeQueue(queue) {var i, ii; for (i = 0, ii = queue.length; i < ii; i++) {var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]); provider[invokeArgs[1]].apply(provider, invokeArgs[2]);}}try {if (isString(module)) {moduleFn = angularModule(module); instanceInjector.modules[module] = moduleFn; runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks); runInvokeQueue(moduleFn._invokeQueue); runInvokeQueue(moduleFn._configBlocks);}else if (isFunction(module)) {runBlocks.push(providerInjector.invoke(module));}else if (isArray(module)) {runBlocks.push(providerInjector.invoke(module));}else {assertArgFn(module, 'module');}}catch (e) {if (isArray(module)) {module = module[module.length - 1];}if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {e = e.message + '\n' + e.stack;}throw $injectorMinErr('modulerr', 'Failed to instantiate module {0}due to:\n{1}', module, e.stack || e.message || e);}}); return runBlocks;}function createInternalInjector(cache, factory) {function getService(serviceName, caller) {if (cache.hasOwnProperty(serviceName)) {if (cache[serviceName] === INSTANTIATING) {throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));}return cache[serviceName];}else {try {path.unshift(serviceName); cache[serviceName] = INSTANTIATING; cache[serviceName] = factory(serviceName, caller); return cache[serviceName];}catch (err) {if (cache[serviceName] === INSTANTIATING) {delete cache[serviceName];}throw err;}finally {path.shift();}}}function injectionArgs(fn, locals, serviceName) {var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName); for (var i = 0, length = $inject.length; i < length; i++) {var key = $inject[i]; if (typeof key !== 'string') {throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);}args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));}return args;}function isClass(func) {if (msie || typeof func !== 'function') {return false;}var result = func.$$ngIsClass; if (!isBoolean(result)) {result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func));}return result;}function invoke(fn, self, locals, serviceName) {if (typeof locals === 'string') {serviceName = locals; locals = null;}var args = injectionArgs(fn, locals, serviceName); if (isArray(fn)) {fn = fn[fn.length - 1];}if (!isClass(fn)) {return fn.apply(self, args);}else {args.unshift(null); return new (Function.prototype.bind.apply(fn, args))();}}function instantiate(Type, locals, serviceName) {var ctor = isArray(Type) ? Type[Type.length - 1] : Type; var args = injectionArgs(Type, locals, serviceName); args.unshift(null); return new (Function.prototype.bind.apply(ctor, args))();}return {invoke: invoke, instantiate: instantiate, get: getService, annotate: createInjector.$$annotate, has: function (name) {return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);}, };}}createInjector.$$annotate = annotate; function $AnchorScrollProvider() {var autoScrollingEnabled = true; this.disableAutoScrolling = function () {autoScrollingEnabled = false;}; this.$get = [ '$window', '$location', '$rootScope', function ($window, $location, $rootScope) {var document = $window.document; function getFirstAnchor(list) {var result = null; Array.prototype.some.call(list, function (element) {if (nodeName_(element) === 'a') {result = element; return true;}}); return result;}function getYOffset() {var offset = scroll.yOffset; if (isFunction(offset)) {offset = offset();}else if (isElement(offset)) {var elem = offset[0]; var style = $window.getComputedStyle(elem); if (style.position !== 'fixed') {offset = 0;}else {offset = elem.getBoundingClientRect().bottom;}}else if (!isNumber(offset)) {offset = 0;}return offset;}function scrollTo(elem) {if (elem) {elem.scrollIntoView(); var offset = getYOffset(); if (offset) {var elemTop = elem.getBoundingClientRect().top; $window.scrollBy(0, elemTop - offset);}}else {$window.scrollTo(0, 0);}}function scroll(hash) {hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash(); var elm; if (!hash) scrollTo(null); else if ((elm = document.getElementById(hash))) scrollTo(elm); else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm); else if (hash === 'top') scrollTo(null);}if (autoScrollingEnabled) {$rootScope.$watch( function autoScrollWatch() {return $location.hash();}, function autoScrollWatchAction(newVal, oldVal) {if (newVal === oldVal && newVal === '') return; jqLiteDocumentLoaded(function () {$rootScope.$evalAsync(scroll);});}, );}return scroll;}, ];}var $animateMinErr = minErr('$animate'); var ELEMENT_NODE = 1; var NG_ANIMATE_CLASSNAME = 'ng-animate'; function mergeClasses(a, b) {if (!a && !b) return ''; if (!a) return b; if (!b) return a; if (isArray(a)) a = a.join(' '); if (isArray(b)) b = b.join(' '); return a + ' ' + b;}function extractElementNode(element) {for (var i = 0; i < element.length; i++) {var elm = element[i]; if (elm.nodeType === ELEMENT_NODE) {return elm;}}}function splitClasses(classes) {if (isString(classes)) {classes = classes.split(' ');}var obj = createMap(); forEach(classes, function (klass) {if (klass.length) {obj[klass] = true;}}); return obj;}function prepareAnimateOptions(options) {return isObject(options) ? options : {};}var $$CoreAnimateJsProvider = function () {this.$get = noop;}; var $$CoreAnimateQueueProvider = function () {var postDigestQueue = new NgMap(); var postDigestElements = []; this.$get = [ '$$AnimateRunner', '$rootScope', function ($$AnimateRunner, $rootScope) {return {enabled: noop, on: noop, off: noop, pin: noop, push: function (element, event, options, domOperation) {if (domOperation) {domOperation();}options = options || {}; if (options.from) {element.css(options.from);}if (options.to) {element.css(options.to);}if (options.addClass || options.removeClass) {addRemoveClassesPostDigest(element, options.addClass, options.removeClass);}var runner = new $$AnimateRunner(); runner.complete(); return runner;}, }; function updateData(data, classes, value) {var changed = false; if (classes) {classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : []; forEach(classes, function (className) {if (className) {changed = true; data[className] = value;}});}return changed;}function handleCSSClassChanges() {forEach(postDigestElements, function (element) {var data = postDigestQueue.get(element); if (data) {var existing = splitClasses(element.attr('class')); var toAdd = ''; var toRemove = ''; forEach(data, function (status, className) {var hasClass = !!existing[className]; if (status !== hasClass) {if (status) {toAdd += (toAdd.length ? ' ' : '') + className;}else {toRemove += (toRemove.length ? ' ' : '') + className;}}}); forEach(element, function (elm) {if (toAdd) {jqLiteAddClass(elm, toAdd);}if (toRemove) {jqLiteRemoveClass(elm, toRemove);}}); postDigestQueue.delete(element);}}); postDigestElements.length = 0;}function addRemoveClassesPostDigest(element, add, remove) {var data = postDigestQueue.get(element) || {}; var classesAdded = updateData(data, add, true); var classesRemoved = updateData(data, remove, false); if (classesAdded || classesRemoved) {postDigestQueue.set(element, data); postDigestElements.push(element); if (postDigestElements.length === 1) {$rootScope.$$postDigest(handleCSSClassChanges);}}}}, ];}; var $AnimateProvider = [ '$provide', function ($provide) {var provider = this; var classNameFilter = null; var customFilter = null; this.$$registeredAnimations = Object.create(null); this.register = function (name, factory) {if (name && name.charAt(0) !== '.') {throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);}var key = name + '-animation'; provider.$$registeredAnimations[name.substr(1)] = key; $provide.factory(key, factory);}; this.customFilter = function (filterFn) {if (arguments.length === 1) {customFilter = isFunction(filterFn) ? filterFn : null;}return customFilter;}; this.classNameFilter = function (expression) {if (arguments.length === 1) {classNameFilter = expression instanceof RegExp ? expression : null; if (classNameFilter) {var reservedRegex = new RegExp('[(\\s|\\/)]' + NG_ANIMATE_CLASSNAME + '[(\\s|\\/)]'); if (reservedRegex.test(classNameFilter.toString())) {classNameFilter = null; throw $animateMinErr( 'nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME, );}}}return classNameFilter;}; this.$get = [ '$$animateQueue', function ($$animateQueue) {function domInsert(element, parentElement, afterElement) {if (afterElement) {var afterNode = extractElementNode(afterElement); if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {afterElement = null;}}if (afterElement) {afterElement.after(element);}else {parentElement.prepend(element);}}return {on: $$animateQueue.on, off: $$animateQueue.off, pin: $$animateQueue.pin, enabled: $$animateQueue.enabled, cancel: function (runner) {if (runner.end) {runner.end();}}, enter: function (element, parent, after, options) {parent = parent && jqLite(parent); after = after && jqLite(after); parent = parent || after.parent(); domInsert(element, parent, after); return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));}, move: function (element, parent, after, options) {parent = parent && jqLite(parent); after = after && jqLite(after); parent = parent || after.parent(); domInsert(element, parent, after); return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));}, leave: function (element, options) {return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {element.remove();});}, addClass: function (element, className, options) {options = prepareAnimateOptions(options); options.addClass = mergeClasses(options.addclass, className); return $$animateQueue.push(element, 'addClass', options);}, removeClass: function (element, className, options) {options = prepareAnimateOptions(options); options.removeClass = mergeClasses(options.removeClass, className); return $$animateQueue.push(element, 'removeClass', options);}, setClass: function (element, add, remove, options) {options = prepareAnimateOptions(options); options.addClass = mergeClasses(options.addClass, add); options.removeClass = mergeClasses(options.removeClass, remove); return $$animateQueue.push(element, 'setClass', options);}, animate: function (element, from, to, className, options) {options = prepareAnimateOptions(options); options.from = options.from ? extend(options.from, from) : from; options.to = options.to ? extend(options.to, to) : to; className = className || 'ng-inline-animate'; options.tempClasses = mergeClasses(options.tempClasses, className); return $$animateQueue.push(element, 'animate', options);}, };}, ];}, ]; var $$AnimateAsyncRunFactoryProvider = function () {this.$get = [ '$$rAF', function ($$rAF) {var waitQueue = []; function waitForTick(fn) {waitQueue.push(fn); if (waitQueue.length > 1) return; $$rAF(function () {for (var i = 0; i < waitQueue.length; i++) {waitQueue[i]();}waitQueue = [];});}return function () {var passed = false; waitForTick(function () {passed = true;}); return function (callback) {if (passed) {callback();}else {waitForTick(callback);}};};}, ];}; var $$AnimateRunnerFactoryProvider = function () {this.$get = [ '$q', '$sniffer', '$$animateAsyncRun', '$$isDocumentHidden', '$timeout', function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {var INITIAL_STATE = 0; var DONE_PENDING_STATE = 1; var DONE_COMPLETE_STATE = 2; AnimateRunner.chain = function (chain, callback) {var index = 0; next(); function next() {if (index === chain.length) {callback(true); return;}chain[index](function (response) {if (response === false) {callback(false); return;}index++; next();});}}; AnimateRunner.all = function (runners, callback) {var count = 0; var status = true; forEach(runners, function (runner) {runner.done(onProgress);}); function onProgress(response) {status = status && response; if (++count === runners.length) {callback(status);}}}; function AnimateRunner(host) {this.setHost(host); var rafTick = $$animateAsyncRun(); var timeoutTick = function (fn) {$timeout(fn, 0, false);}; this._doneCallbacks = []; this._tick = function (fn) {if ($$isDocumentHidden()) {timeoutTick(fn);}else {rafTick(fn);}}; this._state = 0;}AnimateRunner.prototype = {setHost: function (host) {this.host = host || {};}, done: function (fn) {if (this._state === DONE_COMPLETE_STATE) {fn();}else {this._doneCallbacks.push(fn);}}, progress: noop, getPromise: function () {if (!this.promise) {var self = this; this.promise = $q(function (resolve, reject) {self.done(function (status) {if (status === false) {reject();}else {resolve();}});});}return this.promise;}, then: function (resolveHandler, rejectHandler) {return this.getPromise().then(resolveHandler, rejectHandler);}, catch: function (handler) {return this.getPromise()['catch'](handler);}, finally: function (handler) {return this.getPromise()['finally'](handler);}, pause: function () {if (this.host.pause) {this.host.pause();}}, resume: function () {if (this.host.resume) {this.host.resume();}}, end: function () {if (this.host.end) {this.host.end();}this._resolve(true);}, cancel: function () {if (this.host.cancel) {this.host.cancel();}this._resolve(false);}, complete: function (response) {var self = this; if (self._state === INITIAL_STATE) {self._state = DONE_PENDING_STATE; self._tick(function () {self._resolve(response);});}}, _resolve: function (response) {if (this._state !== DONE_COMPLETE_STATE) {forEach(this._doneCallbacks, function (fn) {fn(response);}); this._doneCallbacks.length = 0; this._state = DONE_COMPLETE_STATE;}}, }; return AnimateRunner;}, ];}; var $CoreAnimateCssProvider = function () {this.$get = [ '$$rAF', '$q', '$$AnimateRunner', function ($$rAF, $q, $$AnimateRunner) {return function (element, initialOptions) {var options = initialOptions || {}; if (!options.$$prepared) {options = copy(options);}if (options.cleanupStyles) {options.from = options.to = null;}if (options.from) {element.css(options.from); options.from = null;}var closed, runner = new $$AnimateRunner(); return {start: run, end: run, }; function run() {$$rAF(function () {applyAnimationContents(); if (!closed) {runner.complete();}closed = true;}); return runner;}function applyAnimationContents() {if (options.addClass) {element.addClass(options.addClass); options.addClass = null;}if (options.removeClass) {element.removeClass(options.removeClass); options.removeClass = null;}if (options.to) {element.css(options.to); options.to = null;}}};}, ];}; function Browser(window, document, $log, $sniffer) {var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}; self.isMock = false; var outstandingRequestCount = 0; var outstandingRequestCallbacks = []; self.$$completeOutstandingRequest = completeOutstandingRequest; self.$$incOutstandingRequestCount = function () {outstandingRequestCount++;}; function completeOutstandingRequest(fn) {try {fn.apply(null, sliceArgs(arguments, 1));}finally {outstandingRequestCount--; if (outstandingRequestCount === 0) {while (outstandingRequestCallbacks.length) {try {outstandingRequestCallbacks.pop()();}catch (e) {$log.error(e);}}}}}function getHash(url) {var index = url.indexOf('#'); return index === -1 ? '' : url.substr(index);}self.notifyWhenNoOutstandingRequests = function (callback) {if (outstandingRequestCount === 0) {callback();}else {outstandingRequestCallbacks.push(callback);}}; var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find('base'), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {try {return history.state;}catch (e) {}}; cacheState(); self.url = function (url, replace, state) {if (isUndefined(state)) {state = null;}if (location !== window.location) location = window.location; if (history !== window.history) history = window.history; if (url) {var sameState = lastHistoryState === state; if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {return self;}var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url); lastBrowserUrl = url; lastHistoryState = state; if ($sniffer.history && (!sameBase || !sameState)) {history[replace ? 'replaceState' : 'pushState'](state, '', url); cacheState();}else {if (!sameBase) {pendingLocation = url;}if (replace) {location.replace(url);}else if (!sameBase) {location.href = url;}else {location.hash = getHash(url);}if (location.href !== url) {pendingLocation = url;}}if (pendingLocation) {pendingLocation = url;}return self;}else {return pendingLocation || location.href.replace(/%27/g, "'");}}; self.state = function () {return cachedState;}; var urlChangeListeners = [], urlChangeInit = false; function cacheStateAndFireUrlChange() {pendingLocation = null; fireStateOrUrlChange();}var lastCachedState = null; function cacheState() {cachedState = getCurrentState(); cachedState = isUndefined(cachedState) ? null : cachedState; if (equals(cachedState, lastCachedState)) {cachedState = lastCachedState;}lastCachedState = cachedState; lastHistoryState = cachedState;}function fireStateOrUrlChange() {var prevLastHistoryState = lastHistoryState; cacheState(); if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {return;}lastBrowserUrl = self.url(); lastHistoryState = cachedState; forEach(urlChangeListeners, function (listener) {listener(self.url(), cachedState);});}self.onUrlChange = function (callback) {if (!urlChangeInit) {if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange); jqLite(window).on('hashchange', cacheStateAndFireUrlChange); urlChangeInit = true;}urlChangeListeners.push(callback); return callback;}; self.$$applicationDestroyed = function () {jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);}; self.$$checkUrlChange = fireStateOrUrlChange; self.baseHref = function () {var href = baseElement.attr('href'); return href ? href.replace(/^(https?:)?\/\/[^/]*/, '') : '';}; self.defer = function (fn, delay) {var timeoutId; outstandingRequestCount++; timeoutId = setTimeout(function () {delete pendingDeferIds[timeoutId]; completeOutstandingRequest(fn);}, delay || 0); pendingDeferIds[timeoutId] = true; return timeoutId;}; self.defer.cancel = function (deferId) {if (pendingDeferIds[deferId]) {delete pendingDeferIds[deferId]; clearTimeout(deferId); completeOutstandingRequest(noop); return true;}return false;};}function $BrowserProvider() {this.$get = [ '$window', '$log', '$sniffer', '$document', function ($window, $log, $sniffer, $document) {return new Browser($window, $document, $log, $sniffer);}, ];}function $CacheFactoryProvider() {this.$get = function () {var caches = {}; function cacheFactory(cacheId, options) {if (cacheId in caches) {throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);}var size = 0, stats = extend({}, options, {id: cacheId }), data = createMap(), capacity = (options && options.capacity) || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null; return (caches[cacheId] = {put: function (key, value) {if (isUndefined(value)) return; if (capacity < Number.MAX_VALUE) {var lruEntry = lruHash[key] || (lruHash[key] = {key: key }); refresh(lruEntry);}if (!(key in data)) size++; data[key] = value; if (size > capacity) {this.remove(staleEnd.key);}return value;}, get: function (key) {if (capacity < Number.MAX_VALUE) {var lruEntry = lruHash[key]; if (!lruEntry) return; refresh(lruEntry);}return data[key];}, remove: function (key) {if (capacity < Number.MAX_VALUE) {var lruEntry = lruHash[key]; if (!lruEntry) return; if (lruEntry === freshEnd) freshEnd = lruEntry.p; if (lruEntry === staleEnd) staleEnd = lruEntry.n; link(lruEntry.n, lruEntry.p); delete lruHash[key];}if (!(key in data)) return; delete data[key]; size--;}, removeAll: function () {data = createMap(); size = 0; lruHash = createMap(); freshEnd = staleEnd = null;}, destroy: function () {data = null; stats = null; lruHash = null; delete caches[cacheId];}, info: function () {return extend({}, stats, {size: size });}, }); function refresh(entry) {if (entry !== freshEnd) {if (!staleEnd) {staleEnd = entry;}else if (staleEnd === entry) {staleEnd = entry.n;}link(entry.n, entry.p); link(entry, freshEnd); freshEnd = entry; freshEnd.n = null;}}function link(nextEntry, prevEntry) {if (nextEntry !== prevEntry) {if (nextEntry) nextEntry.p = prevEntry; if (prevEntry) prevEntry.n = nextEntry;}}}cacheFactory.info = function () {var info = {}; forEach(caches, function (cache, cacheId) {info[cacheId] = cache.info();}); return info;}; cacheFactory.get = function (cacheId) {return caches[cacheId];}; return cacheFactory;};}function $TemplateCacheProvider() {this.$get = [ '$cacheFactory', function ($cacheFactory) {return $cacheFactory('templates');}, ];}var $compileMinErr = minErr('$compile'); function UNINITIALIZED_VALUE() {}var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE(); $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider']; function $CompileProvider($provide, $$sanitizeUriProvider) {var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/; var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/; var bindingCache = createMap(); function parseIsolateBindings(scope, directiveName, isController) {var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/; var bindings = createMap(); forEach(scope, function (definition, scopeName) {if (definition in bindingCache) {bindings[scopeName] = bindingCache[definition]; return;}var match = definition.match(LOCAL_REGEXP); if (!match) {throw $compileMinErr( 'iscp', "Invalid {3}for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition', );}bindings[scopeName] = {mode: match[1][0], collection: match[2] === '*', optional: match[3] === '?', attrName: match[4] || scopeName, }; if (match[4]) {bindingCache[definition] = bindings[scopeName];}}); return bindings;}function parseDirectiveBindings(directive, directiveName) {var bindings = {isolateScope: null, bindToController: null, }; if (isObject(directive.scope)) {if (directive.bindToController === true) {bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true); bindings.isolateScope = {};}else {bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);}}if (isObject(directive.bindToController)) {bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);}if (bindings.bindToController && !directive.controller) {throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);}return bindings;}function assertValidDirectiveName(name) {var letter = name.charAt(0); if (!letter || letter !== lowercase(letter)) {throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);}if (name !== name.trim()) {throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);}}function getDirectiveRequire(directive) {var require = directive.require || (directive.controller && directive.name); if (!isArray(require) && isObject(require)) {forEach(require, function (value, key) {var match = value.match(REQUIRE_PREFIX_REGEXP); var name = value.substring(match[0].length); if (!name) require[key] = match[0] + key;});}return require;}function getDirectiveRestrict(restrict, name) {if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {throw $compileMinErr('badrestrict', "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);}return restrict || 'EA';}this.directive = function registerDirective(name, directiveFactory) {assertArg(name, 'name'); assertNotHasOwnProperty(name, 'directive'); if (isString(name)) {assertValidDirectiveName(name); assertArg(directiveFactory, 'directiveFactory'); if (!hasDirectives.hasOwnProperty(name)) {hasDirectives[name] = []; $provide.factory(name + Suffix, [ '$injector', '$exceptionHandler', function ($injector, $exceptionHandler) {var directives = []; forEach(hasDirectives[name], function (directiveFactory, index) {try {var directive = $injector.invoke(directiveFactory); if (isFunction(directive)) {directive = {compile: valueFn(directive) };}else if (!directive.compile && directive.link) {directive.compile = valueFn(directive.link);}directive.priority = directive.priority || 0; directive.index = index; directive.name = directive.name || name; directive.require = getDirectiveRequire(directive); directive.restrict = getDirectiveRestrict(directive.restrict, name); directive.$$moduleName = directiveFactory.$$moduleName; directives.push(directive);}catch (e) {$exceptionHandler(e);}}); return directives;}, ]);}hasDirectives[name].push(directiveFactory);}else {forEach(name, reverseParams(registerDirective));}return this;}; this.component = function registerComponent(name, options) {if (!isString(name)) {forEach(name, reverseParams(bind(this, registerComponent))); return this;}var controller = options.controller || function () {}; function factory($injector) {function makeInjectable(fn) {if (isFunction(fn) || isArray(fn)) {return function (tElement, tAttrs) {return $injector.invoke(fn, this, {$element: tElement, $attrs: tAttrs });};}else {return fn;}}var template = !options.template && !options.templateUrl ? '' : options.template; var ddo = {controller: controller, controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl', template: makeInjectable(template), templateUrl: makeInjectable(options.templateUrl), transclude: options.transclude, scope: {}, bindToController: options.bindings || {}, restrict: 'E', require: options.require, }; forEach(options, function (val, key) {if (key.charAt(0) === '$') ddo[key] = val;}); return ddo;}forEach(options, function (val, key) {if (key.charAt(0) === '$') {factory[key] = val; if (isFunction(controller)) controller[key] = val;}}); factory.$inject = ['$injector']; return this.directive(name, factory);}; this.aHrefSanitizationWhitelist = function (regexp) {if (isDefined(regexp)) {$$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp); return this;}else {return $$sanitizeUriProvider.aHrefSanitizationWhitelist();}}; this.imgSrcSanitizationWhitelist = function (regexp) {if (isDefined(regexp)) {$$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp); return this;}else {return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();}}; var debugInfoEnabled = true; this.debugInfoEnabled = function (enabled) {if (isDefined(enabled)) {debugInfoEnabled = enabled; return this;}return debugInfoEnabled;}; var preAssignBindingsEnabled = false; this.preAssignBindingsEnabled = function (enabled) {if (isDefined(enabled)) {preAssignBindingsEnabled = enabled; return this;}return preAssignBindingsEnabled;}; var strictComponentBindingsEnabled = false; this.strictComponentBindingsEnabled = function (enabled) {if (isDefined(enabled)) {strictComponentBindingsEnabled = enabled; return this;}return strictComponentBindingsEnabled;}; var TTL = 10; this.onChangesTtl = function (value) {if (arguments.length) {TTL = value; return this;}return TTL;}; var commentDirectivesEnabledConfig = true; this.commentDirectivesEnabled = function (value) {if (arguments.length) {commentDirectivesEnabledConfig = value; return this;}return commentDirectivesEnabledConfig;}; var cssClassDirectivesEnabledConfig = true; this.cssClassDirectivesEnabled = function (value) {if (arguments.length) {cssClassDirectivesEnabledConfig = value; return this;}return cssClassDirectivesEnabledConfig;}; this.$get = [ '$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {var SIMPLE_ATTR_NAME = /^\w/; var specialAttrHolder = window.document.createElement('div'); var commentDirectivesEnabled = commentDirectivesEnabledConfig; var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig; var onChangesTtl = TTL; var onChangesQueue; function flushOnChangesQueue() {try {if (!--onChangesTtl) {onChangesQueue = undefined; throw $compileMinErr('infchng', '{0}$onChanges() iterations reached. Aborting!\n', TTL);}$rootScope.$apply(function () {var errors = []; for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {try {onChangesQueue[i]();}catch (e) {errors.push(e);}}onChangesQueue = undefined; if (errors.length) {throw errors;}});}finally {onChangesTtl++;}}function Attributes(element, attributesToCopy) {if (attributesToCopy) {var keys = Object.keys(attributesToCopy); var i, l, key; for (i = 0, l = keys.length; i < l; i++) {key = keys[i]; this[key] = attributesToCopy[key];}}else {this.$attr = {};}this.$$element = element;}Attributes.prototype = {$normalize: directiveNormalize, $addClass: function (classVal) {if (classVal && classVal.length > 0) {$animate.addClass(this.$$element, classVal);}}, $removeClass: function (classVal) {if (classVal && classVal.length > 0) {$animate.removeClass(this.$$element, classVal);}}, $updateClass: function (newClasses, oldClasses) {var toAdd = tokenDifference(newClasses, oldClasses); if (toAdd && toAdd.length) {$animate.addClass(this.$$element, toAdd);}var toRemove = tokenDifference(oldClasses, newClasses); if (toRemove && toRemove.length) {$animate.removeClass(this.$$element, toRemove);}}, $set: function (key, value, writeAttr, attrName) {var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName; if (booleanKey) {this.$$element.prop(key, value); attrName = booleanKey;}else if (aliasedKey) {this[aliasedKey] = value; observer = aliasedKey;}this[key] = value; if (attrName) {this.$attr[key] = attrName;}else {attrName = this.$attr[key]; if (!attrName) {this.$attr[key] = attrName = snake_case(key, '-');}}nodeName = nodeName_(this.$$element); if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {this[key] = value = $$sanitizeUri(value, key === 'src');}else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {var result = ''; var trimmedSrcset = trim(value); var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/; var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/; var rawUris = trimmedSrcset.split(pattern); var nbrUrisWith2parts = Math.floor(rawUris.length / 2); for (var i = 0; i < nbrUrisWith2parts; i++) {var innerIdx = i * 2; result += $$sanitizeUri(trim(rawUris[innerIdx]), true); result += ' ' + trim(rawUris[innerIdx + 1]);}var lastTuple = trim(rawUris[i * 2]).split(/\s/); result += $$sanitizeUri(trim(lastTuple[0]), true); if (lastTuple.length === 2) {result += ' ' + trim(lastTuple[1]);}this[key] = value = result;}if (writeAttr !== false) {if (value === null || isUndefined(value)) {this.$$element.removeAttr(attrName);}else {if (SIMPLE_ATTR_NAME.test(attrName)) {this.$$element.attr(attrName, value);}else {setSpecialAttr(this.$$element[0], attrName, value);}}}var $$observers = this.$$observers; if ($$observers) {forEach($$observers[observer], function (fn) {try {fn(value);}catch (e) {$exceptionHandler(e);}});}}, $observe: function (key, fn) {var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []); listeners.push(fn); $rootScope.$evalAsync(function () {if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {fn(attrs[key]);}}); return function () {arrayRemove(listeners, fn);};}, }; function setSpecialAttr(element, attrName, value) {specialAttrHolder.innerHTML = '<span ' + attrName + '>'; var attributes = specialAttrHolder.firstChild.attributes; var attribute = attributes[0]; attributes.removeNamedItem(attribute.name); attribute.value = value; element.attributes.setNamedItem(attribute);}function safeAddClass($element, className) {try {$element.addClass(className);}catch (e) {}}var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === '{{' && endSymbol === '}}' ? identity : function denormalizeTemplate(template) {return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);}, NG_ATTR_BINDING = /^ngAttr[A-Z]/; var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/; compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {var bindings = $element.data('$binding') || []; if (isArray(binding)) {bindings = bindings.concat(binding);}else {bindings.push(binding);}$element.data('$binding', bindings);}: noop; compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {safeAddClass($element, 'ng-binding');}: noop; compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope'; $element.data(dataName, scope);}: noop; compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');}: noop; compile.$$createComment = function (directiveName, comment) {var content = ''; if (debugInfoEnabled) {content = ' ' + (directiveName || '') + ': '; if (comment) content += comment + ' ';}return window.document.createComment(content);}; return compile; function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {if (!($compileNodes instanceof jqLite)) {$compileNodes = jqLite($compileNodes);}var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext); compile.$$addScopeClass($compileNodes); var namespace = null; return function publicLinkFn(scope, cloneConnectFn, options) {if (!$compileNodes) {throw $compileMinErr('multilink', 'This element has already been linked.');}assertArg(scope, 'scope'); if (previousCompileContext && previousCompileContext.needsNewScope) {scope = scope.$parent.$new();}options = options || {}; var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement; if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;}if (!namespace) {namespace = detectNamespaceForChildElements(futureParentElement);}var $linkNode; if (namespace !== 'html') {$linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));}else if (cloneConnectFn) {$linkNode = JQLitePrototype.clone.call($compileNodes);}else {$linkNode = $compileNodes;}if (transcludeControllers) {for (var controllerName in transcludeControllers) {$linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);}}compile.$$addScopeInfo($linkNode, scope); if (cloneConnectFn) cloneConnectFn($linkNode, scope); if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn); if (!cloneConnectFn) {$compileNodes = compositeLinkFn = null;}return $linkNode;};}function detectNamespaceForChildElements(parentElement) {var node = parentElement && parentElement[0]; if (!node) {return 'html';}else {return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';}}function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {var linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound; for (var i = 0; i < nodeList.length; i++) {attrs = new Attributes(); if (msie === 11) {mergeConsecutiveTextNodes(nodeList, i, notLiveList);}directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective); nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null; if (nodeLinkFn && nodeLinkFn.scope) {compile.$$addScopeClass(attrs.$$element);}childLinkFn = (nodeLinkFn && nodeLinkFn.terminal) || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes( childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn, ); if (nodeLinkFn || childLinkFn) {linkFns.push(i, nodeLinkFn, childLinkFn); linkFnFound = true; nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;}previousCompileContext = null;}return linkFnFound ? compositeLinkFn : null; function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn; var stableNodeList; if (nodeLinkFnFound) {var nodeListLength = nodeList.length; stableNodeList = new Array(nodeListLength); for (i = 0; i < linkFns.length; i += 3) {idx = linkFns[i]; stableNodeList[idx] = nodeList[idx];}}else {stableNodeList = nodeList;}for (i = 0, ii = linkFns.length; i < ii; ) {node = stableNodeList[linkFns[i++]]; nodeLinkFn = linkFns[i++]; childLinkFn = linkFns[i++]; if (nodeLinkFn) {if (nodeLinkFn.scope) {childScope = scope.$new(); compile.$$addScopeInfo(jqLite(node), childScope);}else {childScope = scope;}if (nodeLinkFn.transcludeOnThisElement) {childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);}else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {childBoundTranscludeFn = parentBoundTranscludeFn;}else if (!parentBoundTranscludeFn && transcludeFn) {childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);}else {childBoundTranscludeFn = null;}nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);}else if (childLinkFn) {childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);}}}}function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {var node = nodeList[idx]; var parent = node.parentNode; var sibling; if (node.nodeType !== NODE_TYPE_TEXT) {return;}while (true) {sibling = parent ? node.nextSibling : nodeList[idx + 1]; if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {break;}node.nodeValue = node.nodeValue + sibling.nodeValue; if (sibling.parentNode) {sibling.parentNode.removeChild(sibling);}if (notLiveList && sibling === nodeList[idx + 1]) {nodeList.splice(idx + 1, 1);}}}function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {if (!transcludedScope) {transcludedScope = scope.$new(false, containingScope); transcludedScope.$$transcluded = true;}return transcludeFn(transcludedScope, cloneFn, {parentBoundTranscludeFn: previousBoundTranscludeFn, transcludeControllers: controllers, futureParentElement: futureParentElement, });}var boundSlots = (boundTranscludeFn.$$slots = createMap()); for (var slotName in transcludeFn.$$slots) {if (transcludeFn.$$slots[slotName]) {boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);}else {boundSlots[slotName] = null;}}return boundTranscludeFn;}function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className; switch (nodeType) {case NODE_TYPE_ELEMENT : nodeName = nodeName_(node); addDirective(directives, directiveNormalize(nodeName), 'E', maxPriority, ignoreDirective); for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {var attrStartName = false; var attrEndName = false; attr = nAttrs[j]; name = attr.name; value = attr.value; ngAttrName = directiveNormalize(name); isNgAttr = NG_ATTR_BINDING.test(ngAttrName); if (isNgAttr) {name = name .replace(PREFIX_REGEXP, '') .substr(8) .replace(/_(.)/g, function (match, letter) {return letter.toUpperCase();});}var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE); if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {attrStartName = name; attrEndName = name.substr(0, name.length - 5) + 'end'; name = name.substr(0, name.length - 6);}nName = directiveNormalize(name.toLowerCase()); attrsMap[nName] = name; if (isNgAttr || !attrs.hasOwnProperty(nName)) {attrs[nName] = value; if (getBooleanAttrName(node, nName)) {attrs[nName] = true;}}addAttrInterpolateDirective(node, directives, value, nName, isNgAttr); addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);}if (nodeName === 'input' && node.getAttribute('type') === 'hidden') {node.setAttribute('autocomplete', 'off');}if (!cssClassDirectivesEnabled) break; className = node.className; if (isObject(className)) {className = className.animVal;}if (isString(className) && className !== '') {while ((match = CLASS_DIRECTIVE_REGEXP.exec(className))) {nName = directiveNormalize(match[2]); if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {attrs[nName] = trim(match[3]);}className = className.substr(match.index + match[0].length);}}break; case NODE_TYPE_TEXT : addTextInterpolateDirective(directives, node.nodeValue); break; case NODE_TYPE_COMMENT : if (!commentDirectivesEnabled) break; collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective); break;}directives.sort(byPriority); return directives;}function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {try {var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue); if (match) {var nName = directiveNormalize(match[1]); if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {attrs[nName] = trim(match[2]);}}}catch (e) {}}function groupScan(node, attrStart, attrEnd) {var nodes = []; var depth = 0; if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {do {if (!node) {throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);}if (node.nodeType === NODE_TYPE_ELEMENT) {if (node.hasAttribute(attrStart)) depth++; if (node.hasAttribute(attrEnd)) depth--;}nodes.push(node); node = node.nextSibling;}while (depth > 0);}else {nodes.push(node);}return jqLite(nodes);}function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {element = groupScan(element[0], attrStart, attrEnd); return linkFn(scope, element, attrs, controllers, transcludeFn);};}function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {var compiled; if (eager) {return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);}return function lazyCompilation() {if (!compiled) {compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext); $compileNodes = transcludeFn = previousCompileContext = null;}return compiled.apply(this, arguments);};}function applyDirectivesToNode( directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext, ) {previousCompileContext = previousCompileContext || {}; var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = (templateAttrs.$$element = jqLite(compileNode)), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue; for (var i = 0, ii = directives.length; i < ii; i++) {directive = directives[i]; var attrStart = directive.$$start; var attrEnd = directive.$$end; if (attrStart) {$compileNode = groupScan(compileNode, attrStart, attrEnd);}$template = undefined; if (terminalPriority > directive.priority) {break;}directiveValue = directive.scope; if (directiveValue) {if (!directive.templateUrl) {if (isObject(directiveValue)) {assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode); newIsolateScopeDirective = directive;}else {assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);}}newScopeDirective = newScopeDirective || directive;}directiveName = directive.name; if ( !didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb)) ) {var candidateDirective; for (var scanningIndex = i + 1; (candidateDirective = directives[scanningIndex++]); ) {if ( (candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) ) {mightHaveMultipleTransclusionError = true; break;}}didScanForMultipleTransclusion = true;}if (!directive.templateUrl && directive.controller) {controllerDirectives = controllerDirectives || createMap(); assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode); controllerDirectives[directiveName] = directive;}directiveValue = directive.transclude; if (directiveValue) {hasTranscludeDirective = true; if (!directive.$$tlb) {assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode); nonTlbTranscludeDirective = directive;}if (directiveValue === 'element') {hasElementTranscludeDirective = true; terminalPriority = directive.priority; $template = $compileNode; $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])); compileNode = $compileNode[0]; replaceWith(jqCollection, sliceArgs($template), compileNode); $template[0].$$parentNode = $template[0].parentNode; childTranscludeFn = compilationGenerator( mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective, }, );}else {var slots = createMap(); if (!isObject(directiveValue)) {$template = jqLite(jqLiteClone(compileNode)).contents();}else {$template = []; var slotMap = createMap(); var filledSlots = createMap(); forEach(directiveValue, function (elementSelector, slotName) {var optional = elementSelector.charAt(0) === '?'; elementSelector = optional ? elementSelector.substring(1) : elementSelector; slotMap[elementSelector] = slotName; slots[slotName] = null; filledSlots[slotName] = optional;}); forEach($compileNode.contents(), function (node) {var slotName = slotMap[directiveNormalize(nodeName_(node))]; if (slotName) {filledSlots[slotName] = true; slots[slotName] = slots[slotName] || []; slots[slotName].push(node);}else {$template.push(node);}}); forEach(filledSlots, function (filled, slotName) {if (!filled) {throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);}}); for (var slotName in slots) {if (slots[slotName]) {slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);}}}$compileNode.empty(); childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope, }); childTranscludeFn.$$slots = slots;}}if (directive.template) {hasTemplate = true; assertNoDuplicate('template', templateDirective, directive, $compileNode); templateDirective = directive; directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template; directiveValue = denormalizeTemplate(directiveValue); if (directive.replace) {replaceDirective = directive; if (jqLiteIsTextNode(directiveValue)) {$template = [];}else {$template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));}compileNode = $template[0]; if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');}replaceWith(jqCollection, $compileNode, compileNode); var newTemplateAttrs = {$attr: {}}; var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs); var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1)); if (newIsolateScopeDirective || newScopeDirective) {markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);}directives = directives.concat(templateDirectives).concat(unprocessedDirectives); mergeTemplateAttributes(templateAttrs, newTemplateAttrs); ii = directives.length;}else {$compileNode.html(directiveValue);}}if (directive.templateUrl) {hasTemplate = true; assertNoDuplicate('template', templateDirective, directive, $compileNode); templateDirective = directive; if (directive.replace) {replaceDirective = directive;}nodeLinkFn = compileTemplateUrl( directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {controllerDirectives: controllerDirectives, newScopeDirective: newScopeDirective !== directive && newScopeDirective, newIsolateScopeDirective: newIsolateScopeDirective, templateDirective: templateDirective, nonTlbTranscludeDirective: nonTlbTranscludeDirective, }, ); ii = directives.length;}else if (directive.compile) {try {linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn); var context = directive.$$originalDirective || directive; if (isFunction(linkFn)) {addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);}else if (linkFn) {addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);}}catch (e) {$exceptionHandler(e, startingTag($compileNode));}}if (directive.terminal) {nodeLinkFn.terminal = true; terminalPriority = Math.max(terminalPriority, directive.priority);}}nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true; nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective; nodeLinkFn.templateOnThisElement = hasTemplate; nodeLinkFn.transclude = childTranscludeFn; previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective; return nodeLinkFn; function addLinkFns(pre, post, attrStart, attrEnd) {if (pre) {if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd); pre.require = directive.require; pre.directiveName = directiveName; if (newIsolateScopeDirective === directive || directive.$$isolateScope) {pre = cloneAndAnnotateFn(pre, {isolateScope: true });}preLinkFns.push(pre);}if (post) {if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd); post.require = directive.require; post.directiveName = directiveName; if (newIsolateScopeDirective === directive || directive.$$isolateScope) {post = cloneAndAnnotateFn(post, {isolateScope: true });}postLinkFns.push(post);}}function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo; if (compileNode === linkNode) {attrs = templateAttrs; $element = templateAttrs.$$element;}else {$element = jqLite(linkNode); attrs = new Attributes($element, templateAttrs);}controllerScope = scope; if (newIsolateScopeDirective) {isolateScope = scope.$new(true);}else if (newScopeDirective) {controllerScope = scope.$parent;}if (boundTranscludeFn) {transcludeFn = controllersBoundTransclude; transcludeFn.$$boundTransclude = boundTranscludeFn; transcludeFn.isSlotFilled = function (slotName) {return !!boundTranscludeFn.$$slots[slotName];};}if (controllerDirectives) {elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);}if (newIsolateScopeDirective) {compile.$$addScopeInfo( $element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)), ); compile.$$addScopeClass($element, true); isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings; scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective); if (scopeBindingInfo.removeWatches) {isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);}}for (var name in elementControllers) {var controllerDirective = controllerDirectives[name]; var controller = elementControllers[name]; var bindings = controllerDirective.$$bindings.bindToController; if (preAssignBindingsEnabled) {if (bindings) {controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);}else {controller.bindingInfo = {};}var controllerResult = controller(); if (controllerResult !== controller.instance) {controller.instance = controllerResult; $element.data('$' + controllerDirective.name + 'Controller', controllerResult); if (controller.bindingInfo.removeWatches) {controller.bindingInfo.removeWatches();}controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);}}else {controller.instance = controller(); $element.data('$' + controllerDirective.name + 'Controller', controller.instance); controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);}}forEach(controllerDirectives, function (controllerDirective, name) {var require = controllerDirective.require; if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));}}); forEach(elementControllers, function (controller) {var controllerInstance = controller.instance; if (isFunction(controllerInstance.$onChanges)) {try {controllerInstance.$onChanges(controller.bindingInfo.initialChanges);}catch (e) {$exceptionHandler(e);}}if (isFunction(controllerInstance.$onInit)) {try {controllerInstance.$onInit();}catch (e) {$exceptionHandler(e);}}if (isFunction(controllerInstance.$doCheck)) {controllerScope.$watch(function () {controllerInstance.$doCheck();}); controllerInstance.$doCheck();}if (isFunction(controllerInstance.$onDestroy)) {controllerScope.$on('$destroy', function callOnDestroyHook() {controllerInstance.$onDestroy();});}}); for (i = 0, ii = preLinkFns.length; i < ii; i++) {linkFn = preLinkFns[i]; invokeLinkFn( linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn, );}var scopeToChild = scope; if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {scopeToChild = isolateScope;}if (childLinkFn) {childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);}for (i = postLinkFns.length - 1; i >= 0; i--) {linkFn = postLinkFns[i]; invokeLinkFn( linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn, );}forEach(elementControllers, function (controller) {var controllerInstance = controller.instance; if (isFunction(controllerInstance.$postLink)) {controllerInstance.$postLink();}}); function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {var transcludeControllers; if (!isScope(scope)) {slotName = futureParentElement; futureParentElement = cloneAttachFn; cloneAttachFn = scope; scope = undefined;}if (hasElementTranscludeDirective) {transcludeControllers = elementControllers;}if (!futureParentElement) {futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;}if (slotName) {var slotTranscludeFn = boundTranscludeFn.$$slots[slotName]; if (slotTranscludeFn) {return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);}else if (isUndefined(slotTranscludeFn)) {throw $compileMinErr( 'noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element), );}}else {return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);}}}}function getControllers(directiveName, require, $element, elementControllers) {var value; if (isString(require)) {var match = require.match(REQUIRE_PREFIX_REGEXP); var name = require.substring(match[0].length); var inheritType = match[1] || match[3]; var optional = match[2] === '?'; if (inheritType === '^^') {$element = $element.parent();}else {value = elementControllers && elementControllers[name]; value = value && value.instance;}if (!value) {var dataName = '$' + name + 'Controller'; value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);}if (!value && !optional) {throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);}}else if (isArray(require)) {value = []; for (var i = 0, ii = require.length; i < ii; i++) {value[i] = getControllers(directiveName, require[i], $element, elementControllers);}}else if (isObject(require)) {value = {}; forEach(require, function (controller, property) {value[property] = getControllers(directiveName, controller, $element, elementControllers);});}return value || null;}function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {var elementControllers = createMap(); for (var controllerKey in controllerDirectives) {var directive = controllerDirectives[controllerKey]; var locals = {$scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope, $element: $element, $attrs: attrs, $transclude: transcludeFn, }; var controller = directive.controller; if (controller === '@') {controller = attrs[directive.name];}var controllerInstance = $controller(controller, locals, true, directive.controllerAs); elementControllers[directive.name] = controllerInstance; $element.data('$' + directive.name + 'Controller', controllerInstance.instance);}return elementControllers;}function markDirectiveScope(directives, isolateScope, newScope) {for (var j = 0, jj = directives.length; j < jj; j++) {directives[j] = inherit(directives[j], {$$isolateScope: isolateScope, $$newScope: newScope });}}function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {if (name === ignoreDirective) return null; var match = null; if (hasDirectives.hasOwnProperty(name)) {for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {directive = directives[i]; if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {if (startAttrName) {directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName });}if (!directive.$$bindings) {var bindings = (directive.$$bindings = parseDirectiveBindings(directive, directive.name)); if (isObject(bindings.isolateScope)) {directive.$$isolateBindings = bindings.isolateScope;}}tDirectives.push(directive); match = directive;}}}return match;}function directiveIsMultiElement(name) {if (hasDirectives.hasOwnProperty(name)) {for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {directive = directives[i]; if (directive.multiElement) {return true;}}}return false;}function mergeTemplateAttributes(dst, src) {var srcAttr = src.$attr, dstAttr = dst.$attr; forEach(dst, function (value, key) {if (key.charAt(0) !== '$') {if (src[key] && src[key] !== value) {if (value.length) {value += (key === 'style' ? ';' : ' ') + src[key];}else {value = src[key];}}dst.$set(key, value, true, srcAttr[key]);}}); forEach(src, function (value, key) {if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {dst[key] = value; if (key !== 'class' && key !== 'style') {dstAttr[key] = srcAttr[key];}}});}function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective, }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace; $compileNode.empty(); $templateRequest(templateUrl) .then(function (content) {var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn; content = denormalizeTemplate(content); if (origAsyncDirective.replace) {if (jqLiteIsTextNode(content)) {$template = [];}else {$template = removeComments(wrapTemplate(templateNamespace, trim(content)));}compileNode = $template[0]; if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);}tempTemplateAttrs = {$attr: {}}; replaceWith($rootElement, $compileNode, compileNode); var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs); if (isObject(origAsyncDirective.scope)) {markDirectiveScope(templateDirectives, true);}directives = templateDirectives.concat(directives); mergeTemplateAttributes(tAttrs, tempTemplateAttrs);}else {compileNode = beforeTemplateCompileNode; $compileNode.html(content);}directives.unshift(derivedSyncDirective); afterTemplateNodeLinkFn = applyDirectivesToNode( directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext, ); forEach($rootElement, function (node, i) {if (node === compileNode) {$rootElement[i] = $compileNode[0];}}); afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); while (linkQueue.length) {var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0]; if (scope.$$destroyed) continue; if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {var oldClasses = beforeTemplateLinkNode.className; if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {linkNode = jqLiteClone(compileNode);}replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode); safeAddClass(jqLite(linkNode), oldClasses);}if (afterTemplateNodeLinkFn.transcludeOnThisElement) {childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);}else {childBoundTranscludeFn = boundTranscludeFn;}afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);}linkQueue = null;}) .catch(function (error) {if (isError(error)) {$exceptionHandler(error);}}); return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {var childBoundTranscludeFn = boundTranscludeFn; if (scope.$$destroyed) return; if (linkQueue) {linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);}else {if (afterTemplateNodeLinkFn.transcludeOnThisElement) {childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);}afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);}};}function byPriority(a, b) {var diff = b.priority - a.priority; if (diff !== 0) return diff; if (a.name !== b.name) return a.name < b.name ? -1 : 1; return a.index - b.index;}function assertNoDuplicate(what, previousDirective, directive, element) {function wrapModuleNameIfDefined(moduleName) {return moduleName ? ' (module: ' + moduleName + ')' : '';}if (previousDirective) {throw $compileMinErr( 'multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4}on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element), );}}function addTextInterpolateDirective(directives, text) {var interpolateFn = $interpolate(text, true); if (interpolateFn) {directives.push({priority: 0, compile: function textInterpolateCompileFn(templateNode) {var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length; if (hasCompileParent) compile.$$addBindingClass(templateNodeParent); return function textInterpolateLinkFn(scope, node) {var parent = node.parent(); if (!hasCompileParent) compile.$$addBindingClass(parent); compile.$$addBindingInfo(parent, interpolateFn.expressions); scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {node[0].nodeValue = value;});};}, });}}function wrapTemplate(type, template) {type = lowercase(type || 'html'); switch (type) {case 'svg': case 'math': var wrapper = window.document.createElement('div'); wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>'; return wrapper.childNodes[0].childNodes; default: return template;}}function getTrustedContext(node, attrNormalizedName) {if (attrNormalizedName === 'srcdoc') {return $sce.HTML;}var tag = nodeName_(node); if (attrNormalizedName === 'src' || attrNormalizedName === 'ngSrc') {if (['img', 'video', 'audio', 'source', 'track'].indexOf(tag) === -1) {return $sce.RESOURCE_URL;}}else if ( attrNormalizedName === 'xlinkHref' || (tag === 'form' && attrNormalizedName === 'action') || (tag === 'link' && attrNormalizedName === 'href') ) {return $sce.RESOURCE_URL;}}function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {var trustedContext = getTrustedContext(node, name); var mustHaveExpression = !isNgAttr; var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr; var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing); if (!interpolateFn) return; if (name === 'multiple' && nodeName_(node) === 'select') {throw $compileMinErr('selmulti', "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));}if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {throw $compileMinErr( 'nodomevents', 'Interpolations for HTML DOM event attributes are disallowed. Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.', );}directives.push({priority: 100, compile: function () {return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {var $$observers = attr.$$observers || (attr.$$observers = createMap()); var newValue = attr[name]; if (newValue !== value) {interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing); value = newValue;}if (!interpolateFn) return; attr[name] = interpolateFn(scope); ($$observers[name] || ($$observers[name] = [])).$$inter = true; ((attr.$$observers && attr.$$observers[name].$$scope) || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {if (name === 'class' && newValue !== oldValue) {attr.$updateClass(newValue, oldValue);}else {attr.$set(name, newValue);}});}, };}, });}function replaceWith($rootElement, elementsToRemove, newNode) {var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii; if ($rootElement) {for (i = 0, ii = $rootElement.length; i < ii; i++) {if ($rootElement[i] === firstElementToRemove) {$rootElement[i++] = newNode; for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {if (j2 < jj) {$rootElement[j] = $rootElement[j2];}else {delete $rootElement[j];}}$rootElement.length -= removeCount - 1; if ($rootElement.context === firstElementToRemove) {$rootElement.context = newNode;}break;}}}if (parent) {parent.replaceChild(newNode, firstElementToRemove);}var fragment = window.document.createDocumentFragment(); for (i = 0; i < removeCount; i++) {fragment.appendChild(elementsToRemove[i]);}if (jqLite.hasData(firstElementToRemove)) {jqLite.data(newNode, jqLite.data(firstElementToRemove)); jqLite(firstElementToRemove).off('$destroy');}jqLite.cleanData(fragment.querySelectorAll('*')); for (i = 1; i < removeCount; i++) {delete elementsToRemove[i];}elementsToRemove[0] = newNode; elementsToRemove.length = 1;}function cloneAndAnnotateFn(fn, annotation) {return extend( function () {return fn.apply(null, arguments);}, fn, annotation, );}function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {try {linkFn(scope, $element, attrs, controllers, transcludeFn);}catch (e) {$exceptionHandler(e, startingTag($element));}}function strictBindingsCheck(attrName, directiveName) {if (strictComponentBindingsEnabled) {throw $compileMinErr('missingattr', "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);}}function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {var removeWatchCollection = []; var initialChanges = {}; var changes; forEach(bindings, function initializeBinding(definition, scopeName) {var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch; switch (mode) {case '@': if (!optional && !hasOwnProperty.call(attrs, attrName)) {strictBindingsCheck(attrName, directive.name); destination[scopeName] = attrs[attrName] = undefined;}removeWatch = attrs.$observe(attrName, function (value) {if (isString(value) || isBoolean(value)) {var oldValue = destination[scopeName]; recordChanges(scopeName, value, oldValue); destination[scopeName] = value;}}); attrs.$$observers[attrName].$$scope = scope; lastValue = attrs[attrName]; if (isString(lastValue)) {destination[scopeName] = $interpolate(lastValue)(scope);}else if (isBoolean(lastValue)) {destination[scopeName] = lastValue;}initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]); removeWatchCollection.push(removeWatch); break; case '=': if (!hasOwnProperty.call(attrs, attrName)) {if (optional) break; strictBindingsCheck(attrName, directive.name); attrs[attrName] = undefined;}if (optional && !attrs[attrName]) break; parentGet = $parse(attrs[attrName]); if (parentGet.literal) {compare = equals;}else {compare = simpleCompare;}parentSet = parentGet.assign || function () {lastValue = destination[scopeName] = parentGet(scope); throw $compileMinErr( 'nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name, );}; lastValue = destination[scopeName] = parentGet(scope); var parentValueWatch = function parentValueWatch(parentValue) {if (!compare(parentValue, destination[scopeName])) {if (!compare(parentValue, lastValue)) {destination[scopeName] = parentValue;}else {parentSet(scope, (parentValue = destination[scopeName]));}}lastValue = parentValue; return lastValue;}; parentValueWatch.$stateful = true; if (definition.collection) {removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);}else {removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);}removeWatchCollection.push(removeWatch); break; case '<': if (!hasOwnProperty.call(attrs, attrName)) {if (optional) break; strictBindingsCheck(attrName, directive.name); attrs[attrName] = undefined;}if (optional && !attrs[attrName]) break; parentGet = $parse(attrs[attrName]); var deepWatch = parentGet.literal; var initialValue = (destination[scopeName] = parentGet(scope)); initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]); removeWatch = scope.$watch( parentGet, function parentValueWatchAction(newValue, oldValue) {if (oldValue === newValue) {if (oldValue === initialValue || (deepWatch && equals(oldValue, initialValue))) {return;}oldValue = initialValue;}recordChanges(scopeName, newValue, oldValue); destination[scopeName] = newValue;}, deepWatch, ); removeWatchCollection.push(removeWatch); break; case '&': if (!optional && !hasOwnProperty.call(attrs, attrName)) {strictBindingsCheck(attrName, directive.name);}parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop; if (parentGet === noop && optional) break; destination[scopeName] = function (locals) {return parentGet(scope, locals);}; break;}}); function recordChanges(key, currentValue, previousValue) {if (isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue)) {if (!onChangesQueue) {scope.$$postDigest(flushOnChangesQueue); onChangesQueue = [];}if (!changes) {changes = {}; onChangesQueue.push(triggerOnChangesHook);}if (changes[key]) {previousValue = changes[key].previousValue;}changes[key] = new SimpleChange(previousValue, currentValue);}}function triggerOnChangesHook() {destination.$onChanges(changes); changes = undefined;}return {initialChanges: initialChanges, removeWatches: removeWatchCollection.length && function removeWatches() {for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {removeWatchCollection[i]();}}, };}}, ];}function SimpleChange(previous, current) {this.previousValue = previous; this.currentValue = current;}SimpleChange.prototype.isFirstChange = function () {return this.previousValue === _UNINITIALIZED_VALUE;}; var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i; var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g; function directiveNormalize(name) {return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);}function nodesetLinkingFn( scope, nodeList, rootElement, boundTranscludeFn) {}function directiveLinkingFn( nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn, ) {}function tokenDifference(str1, str2) {var values = '', tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/); outer: for (var i = 0; i < tokens1.length; i++) {var token = tokens1[i]; for (var j = 0; j < tokens2.length; j++) {if (token === tokens2[j]) continue outer;}values += (values.length > 0 ? ' ' : '') + token;}return values;}function removeComments(jqNodes) {jqNodes = jqLite(jqNodes); var i = jqNodes.length; if (i <= 1) {return jqNodes;}while (i--) {var node = jqNodes[i]; if (node.nodeType === NODE_TYPE_COMMENT || (node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === '')) {splice.call(jqNodes, i, 1);}}return jqNodes;}var $controllerMinErr = minErr('$controller'); var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/; function identifierForController(controller, ident) {if (ident && isString(ident)) return ident; if (isString(controller)) {var match = CNTRL_REG.exec(controller); if (match) return match[3];}}function $ControllerProvider() {var controllers = {}, globals = false; this.has = function (name) {return controllers.hasOwnProperty(name);}; this.register = function (name, constructor) {assertNotHasOwnProperty(name, 'controller'); if (isObject(name)) {extend(controllers, name);}else {controllers[name] = constructor;}}; this.allowGlobals = function () {globals = true;}; this.$get = [ '$injector', '$window', function ($injector, $window) {return function $controller(expression, locals, later, ident) {var instance, match, constructor, identifier; later = later === true; if (ident && isString(ident)) {identifier = ident;}if (isString(expression)) {match = expression.match(CNTRL_REG); if (!match) {throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + 'Must match `__name__ as __id__` or `__name__`.', expression);}constructor = match[1]; identifier = identifier || match[3]; expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined); if (!expression) {throw $controllerMinErr('ctrlreg', "The controller with the name '{0}' is not registered.", constructor);}assertArgFn(expression, constructor, true);}if (later) {var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype; instance = Object.create(controllerPrototype || null); if (identifier) {addIdentifier(locals, identifier, instance, constructor || expression.name);}return extend( function $controllerInit() {var result = $injector.invoke(expression, instance, locals, constructor); if (result !== instance && (isObject(result) || isFunction(result))) {instance = result; if (identifier) {addIdentifier(locals, identifier, instance, constructor || expression.name);}}return instance;}, {instance: instance, identifier: identifier, }, );}instance = $injector.instantiate(expression, locals, constructor); if (identifier) {addIdentifier(locals, identifier, instance, constructor || expression.name);}return instance;}; function addIdentifier(locals, identifier, instance, name) {if (!(locals && isObject(locals.$scope))) {throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);}locals.$scope[identifier] = instance;}}, ];}function $DocumentProvider() {this.$get = [ '$window', function (window) {return jqLite(window.document);}, ];}function $$IsDocumentHiddenProvider() {this.$get = [ '$document', '$rootScope', function ($document, $rootScope) {var doc = $document[0]; var hidden = doc && doc.hidden; $document.on('visibilitychange', changeListener); $rootScope.$on('$destroy', function () {$document.off('visibilitychange', changeListener);}); function changeListener() {hidden = doc.hidden;}return function () {return hidden;};}, ];}function $ExceptionHandlerProvider() {this.$get = [ '$log', function ($log) {return function (exception, cause) {$log.error.apply($log, arguments);};}, ];}var $$ForceReflowProvider = function () {this.$get = [ '$document', function ($document) {return function (domNode) {if (domNode) {if (!domNode.nodeType && domNode instanceof jqLite) {domNode = domNode[0];}}else {domNode = $document[0].body;}return domNode.offsetWidth + 1;};}, ];}; var APPLICATION_JSON = 'application/json'; var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8' }; var JSON_START = /^\[|^\{(?!\{)/; var JSON_ENDS = {'[': /]$/, '{': /}$/, }; var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/; var $httpMinErr = minErr('$http'); function serializeValue(v) {if (isObject(v)) {return isDate(v) ? v.toISOString() : toJson(v);}return v;}function $HttpParamSerializerProvider() {this.$get = function () {return function ngParamSerializer(params) {if (!params) return ''; var parts = []; forEachSorted(params, function (value, key) {if (value === null || isUndefined(value) || isFunction(value)) return; if (isArray(value)) {forEach(value, function (v) {parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));});}else {parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));}}); return parts.join('&');};};}function $HttpParamSerializerJQLikeProvider() {this.$get = function () {return function jQueryLikeParamSerializer(params) {if (!params) return ''; var parts = []; serialize(params, '', true); return parts.join('&'); function serialize(toSerialize, prefix, topLevel) {if (toSerialize === null || isUndefined(toSerialize)) return; if (isArray(toSerialize)) {forEach(toSerialize, function (value, index) {serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');});}else if (isObject(toSerialize) && !isDate(toSerialize)) {forEachSorted(toSerialize, function (value, key) {serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));});}else {parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));}}};};}function defaultHttpResponseTransform(data, headers) {if (isString(data)) {var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim(); if (tempData) {var contentType = headers('Content-Type'); var hasJsonContentType = contentType && contentType.indexOf(APPLICATION_JSON) === 0; if (hasJsonContentType || isJsonLike(tempData)) {try {data = fromJson(tempData);}catch (e) {if (!hasJsonContentType) {return data;}throw $httpMinErr('baddata', 'Data must be a valid JSON object. Received: "{0}". ' + 'Parse error: "{1}"', data, e);}}}}return data;}function isJsonLike(str) {var jsonStart = str.match(JSON_START); return jsonStart && JSON_ENDS[jsonStart[0]].test(str);}function parseHeaders(headers) {var parsed = createMap(), i; function fillInParsed(key, val) {if (key) {parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;}}if (isString(headers)) {forEach(headers.split('\n'), function (line) {i = line.indexOf(':'); fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));});}else if (isObject(headers)) {forEach(headers, function (headerVal, headerKey) {fillInParsed(lowercase(headerKey), trim(headerVal));});}return parsed;}function headersGetter(headers) {var headersObj; return function (name) {if (!headersObj) headersObj = parseHeaders(headers); if (name) {var value = headersObj[lowercase(name)]; if (value === undefined) {value = null;}return value;}return headersObj;};}function transformData(data, headers, status, fns) {if (isFunction(fns)) {return fns(data, headers, status);}forEach(fns, function (fn) {data = fn(data, headers, status);}); return data;}function isSuccess(status) {return 200 <= status && status < 300;}function $HttpProvider() {var defaults = (this.defaults = {transformResponse: [defaultHttpResponseTransform], transformRequest: [ function (d) {return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;}, ], headers: {common: {Accept: 'application/json, text/plain, * this.useApplyAsync = function (value) {if (isDefined(value)) {useApplyAsync = !!value; return this;}return useApplyAsync;}; var interceptorFactories = (this.interceptors = []); this.$get = [ '$browser', '$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', '$sce', function ($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {var defaultCache = $cacheFactory('$http'); defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer; var reversedInterceptors = []; forEach(interceptorFactories, function (interceptorFactory) {reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));}); function $http(requestConfig) {if (!isObject(requestConfig)) {throw minErr('$http')('badreq', 'Http request configuration must be an object. Received: {0}', requestConfig);}if (!isString($sce.valueOf(requestConfig.url))) {throw minErr('$http')('badreq', 'Http request configuration url must be a string or a $sce trusted object. Received: {0}', requestConfig.url);}var config = extend( {method: 'get', transformRequest: defaults.transformRequest, transformResponse: defaults.transformResponse, paramSerializer: defaults.paramSerializer, jsonpCallbackParam: defaults.jsonpCallbackParam, }, requestConfig, ); config.headers = mergeHeaders(requestConfig); config.method = uppercase(config.method); config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer; $browser.$$incOutstandingRequestCount(); var requestInterceptors = []; var responseInterceptors = []; var promise = $q.resolve(config); forEach(reversedInterceptors, function (interceptor) {if (interceptor.request || interceptor.requestError) {requestInterceptors.unshift(interceptor.request, interceptor.requestError);}if (interceptor.response || interceptor.responseError) {responseInterceptors.push(interceptor.response, interceptor.responseError);}}); promise = chainInterceptors(promise, requestInterceptors); promise = promise.then(serverRequest); promise = chainInterceptors(promise, responseInterceptors); promise = promise.finally(completeOutstandingRequest); return promise; function chainInterceptors(promise, interceptors) {for (var i = 0, ii = interceptors.length; i < ii; ) {var thenFn = interceptors[i++]; var rejectFn = interceptors[i++]; promise = promise.then(thenFn, rejectFn);}interceptors.length = 0; return promise;}function completeOutstandingRequest() {$browser.$$completeOutstandingRequest(noop);}function executeHeaderFns(headers, config) {var headerContent, processedHeaders = {}; forEach(headers, function (headerFn, header) {if (isFunction(headerFn)) {headerContent = headerFn(config); if (headerContent != null) {processedHeaders[header] = headerContent;}}else {processedHeaders[header] = headerFn;}}); return processedHeaders;}function mergeHeaders(config) {var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName; defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]); defaultHeadersIteration: for (defHeaderName in defHeaders) {lowercaseDefHeaderName = lowercase(defHeaderName); for (reqHeaderName in reqHeaders) {if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {continue defaultHeadersIteration;}}reqHeaders[defHeaderName] = defHeaders[defHeaderName];}return executeHeaderFns(reqHeaders, shallowCopy(config));}function serverRequest(config) {var headers = config.headers; var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest); if (isUndefined(reqData)) {forEach(headers, function (value, header) {if (lowercase(header) === 'content-type') {delete headers[header];}});}if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {config.withCredentials = defaults.withCredentials;}return sendReq(config, reqData).then(transformResponse, transformResponse);}function transformResponse(response) {var resp = extend({}, response); resp.data = transformData(response.data, response.headers, response.status, config.transformResponse); return isSuccess(response.status) ? resp : $q.reject(resp);}}$http.pendingRequests = []; createShortMethods('get', 'delete', 'head', 'jsonp'); createShortMethodsWithData('post', 'put', 'patch'); $http.defaults = defaults; return $http; function createShortMethods(names) {forEach(arguments, function (name) {$http[name] = function (url, config) {return $http( extend({}, config || {}, {method: name, url: url, }), );};});}function createShortMethodsWithData(name) {forEach(arguments, function (name) {$http[name] = function (url, data, config) {return $http( extend({}, config || {}, {method: name, url: url, data: data, }), );};});}function sendReq(config, reqData) {var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, isJsonp = lowercase(config.method) === 'jsonp', url = config.url; if (isJsonp) {url = $sce.getTrustedResourceUrl(url);}else if (!isString(url)) {url = $sce.valueOf(url);}url = buildUrl(url, config.paramSerializer(config.params)); if (isJsonp) {url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);}$http.pendingRequests.push(config); promise.then(removePendingReq, removePendingReq); if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {cache = isObject(config.cache) ? config.cache : isObject( (defaults).cache) ? (defaults).cache : defaultCache;}if (cache) {cachedResp = cache.get(url); if (isDefined(cachedResp)) {if (isPromiseLike(cachedResp)) {cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);}else {if (isArray(cachedResp)) {resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]);}else {resolvePromise(cachedResp, 200, {}, 'OK', 'complete');}}}else {cache.put(url, promise);}}if (isUndefined(cachedResp)) {var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined; if (xsrfValue) {reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;}$httpBackend( config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers), );}return promise; function createApplyHandlers(eventHandlers) {if (eventHandlers) {var applyHandlers = {}; forEach(eventHandlers, function (eventHandler, key) {applyHandlers[key] = function (event) {if (useApplyAsync) {$rootScope.$applyAsync(callEventHandler);}else if ($rootScope.$$phase) {callEventHandler();}else {$rootScope.$apply(callEventHandler);}function callEventHandler() {eventHandler(event);}};}); return applyHandlers;}}function done(status, response, headersString, statusText, xhrStatus) {if (cache) {if (isSuccess(status)) {cache.put(url, [status, response, parseHeaders(headersString), statusText, xhrStatus]);}else {cache.remove(url);}}function resolveHttpPromise() {resolvePromise(response, status, headersString, statusText, xhrStatus);}if (useApplyAsync) {$rootScope.$applyAsync(resolveHttpPromise);}else {resolveHttpPromise(); if (!$rootScope.$$phase) $rootScope.$apply();}}function resolvePromise(response, status, headers, statusText, xhrStatus) {status = status >= -1 ? status : 0; (isSuccess(status) ? deferred.resolve : deferred.reject)({data: response, status: status, headers: headersGetter(headers), config: config, statusText: statusText, xhrStatus: xhrStatus, });}function resolvePromiseWithResult(result) {resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);}function removePendingReq() {var idx = $http.pendingRequests.indexOf(config); if (idx !== -1) $http.pendingRequests.splice(idx, 1);}}function buildUrl(url, serializedParams) {if (serializedParams.length > 0) {url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;}return url;}function sanitizeJsonpCallbackParam(url, key) {if (/[&?][^=]+=JSON_CALLBACK/.test(url)) {throw $httpMinErr('badjsonp', 'Illegal use of JSON_CALLBACK in url, "{0}"', url);}var callbackParamRegex = new RegExp('[&?]' + key + '='); if (callbackParamRegex.test(url)) {throw $httpMinErr('badjsonp', 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);}url += (url.indexOf('?') === -1 ? '?' : '&') + key + '=JSON_CALLBACK'; return url;}}, ];}function $xhrFactoryProvider() {this.$get = function () {return function createXhr() {return new window.XMLHttpRequest();};};}function $HttpBackendProvider() {this.$get = [ '$browser', '$jsonpCallbacks', '$document', '$xhrFactory', function ($browser, $jsonpCallbacks, $document, $xhrFactory) {return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);}, ];}function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {url = url || $browser.url(); if (lowercase(method) === 'jsonp') {var callbackPath = callbacks.createCallback(url); var jsonpDone = jsonpReq(url, callbackPath, function (status, text) {var response = status === 200 && callbacks.getResponse(callbackPath); completeRequest(callback, status, response, '', text, 'complete'); callbacks.removeCallback(callbackPath);});}else {var xhr = createXhr(method, url); xhr.open(method, url, true); forEach(headers, function (value, key) {if (isDefined(value)) {xhr.setRequestHeader(key, value);}}); xhr.onload = function requestLoaded() {var statusText = xhr.statusText || ''; var response = 'response' in xhr ? xhr.response : xhr.responseText; var status = xhr.status === 1223 ? 204 : xhr.status; if (status === 0) {status = response ? 200 : urlResolve(url).protocol === 'file' ? 404 : 0;}completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, 'complete');}; var requestError = function () {completeRequest(callback, -1, null, null, '', 'error');}; var requestAborted = function () {completeRequest(callback, -1, null, null, '', 'abort');}; var requestTimeout = function () {completeRequest(callback, -1, null, null, '', 'timeout');}; xhr.onerror = requestError; xhr.onabort = requestAborted; xhr.ontimeout = requestTimeout; forEach(eventHandlers, function (value, key) {xhr.addEventListener(key, value);}); forEach(uploadEventHandlers, function (value, key) {xhr.upload.addEventListener(key, value);}); if (withCredentials) {xhr.withCredentials = true;}if (responseType) {try {xhr.responseType = responseType;}catch (e) {if (responseType !== 'json') {throw e;}}}xhr.send(isUndefined(post) ? null : post);}if (timeout > 0) {var timeoutId = $browserDefer(timeoutRequest, timeout);}else if (isPromiseLike(timeout)) {timeout.then(timeoutRequest);}function timeoutRequest() {if (jsonpDone) {jsonpDone();}if (xhr) {xhr.abort();}}function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {if (isDefined(timeoutId)) {$browserDefer.cancel(timeoutId);}jsonpDone = xhr = null; callback(status, response, headersString, statusText, xhrStatus);}}; function jsonpReq(url, callbackPath, done) {url = url.replace('JSON_CALLBACK', callbackPath); var script = rawDocument.createElement('script'), callback = null; script.type = 'text/javascript'; script.src = url; script.async = true; callback = function (event) {script.removeEventListener('load', callback); script.removeEventListener('error', callback); rawDocument.body.removeChild(script); script = null; var status = -1; var text = 'unknown'; if (event) {if (event.type === 'load' && !callbacks.wasCalled(callbackPath)) {event = {type: 'error' };}text = event.type; status = event.type === 'error' ? 404 : 200;}if (done) {done(status, text);}}; script.addEventListener('load', callback); script.addEventListener('error', callback); rawDocument.body.appendChild(script); return callback;}}var $interpolateMinErr = (angular.$interpolateMinErr = minErr('$interpolate')); $interpolateMinErr.throwNoconcat = function (text) {throw $interpolateMinErr( 'noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required. See http: text, );}; $interpolateMinErr.interr = function (text, err) {return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());}; function $InterpolateProvider() {var startSymbol = '{{'; var endSymbol = '}}'; this.startSymbol = function (value) {if (value) {startSymbol = value; return this;}else {return startSymbol;}}; this.endSymbol = function (value) {if (value) {endSymbol = value; return this;}else {return endSymbol;}}; this.$get = [ '$parse', '$exceptionHandler', '$sce', function ($parse, $exceptionHandler, $sce) {var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g'); function escape(ch) {return '\\\\\\' + ch;}function unescapeText(text) {return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);}function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {var unwatch = scope.$watch( function constantInterpolateWatch(scope) {unwatch(); return constantInterp(scope);}, listener, objectEquality, ); return unwatch;}function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {if (!text.length || text.indexOf(startSymbol) === -1) {var constantInterp; if (!mustHaveExpression) {var unescapedText = unescapeText(text); constantInterp = valueFn(unescapedText); constantInterp.exp = text; constantInterp.expressions = []; constantInterp.$$watchDelegate = constantWatchDelegate;}return constantInterp;}allOrNothing = !!allOrNothing; var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = []; while (index < textLength) {if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {if (index !== startIndex) {concat.push(unescapeText(text.substring(index, startIndex)));}exp = text.substring(startIndex + startSymbolLength, endIndex); expressions.push(exp); parseFns.push($parse(exp, parseStringifyInterceptor)); index = endIndex + endSymbolLength; expressionPositions.push(concat.length); concat.push('');}else {if (index !== textLength) {concat.push(unescapeText(text.substring(index)));}break;}}if (trustedContext && concat.length > 1) {$interpolateMinErr.throwNoconcat(text);}if (!mustHaveExpression || expressions.length) {var compute = function (values) {for (var i = 0, ii = expressions.length; i < ii; i++) {if (allOrNothing && isUndefined(values[i])) return; concat[expressionPositions[i]] = values[i];}return concat.join('');}; var getValue = function (value) {return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);}; return extend( function interpolationFn(context) {var i = 0; var ii = expressions.length; var values = new Array(ii); try {for (; i < ii; i++) {values[i] = parseFns[i](context);}return compute(values);}catch (err) {$exceptionHandler($interpolateMinErr.interr(text, err));}}, {exp: text, expressions: expressions, $$watchDelegate: function (scope, listener) {var lastValue; return scope.$watchGroup( parseFns, function interpolateFnWatcher(values, oldValues) {var currValue = compute(values); if (isFunction(listener)) {listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);}lastValue = currValue;}, );}, }, );}function parseStringifyInterceptor(value) {try {value = getValue(value); return allOrNothing && !isDefined(value) ? value : stringify(value);}catch (err) {$exceptionHandler($interpolateMinErr.interr(text, err));}}}$interpolate.startSymbol = function () {return startSymbol;}; $interpolate.endSymbol = function () {return endSymbol;}; return $interpolate;}, ];}function $IntervalProvider() {this.$get = [ '$rootScope', '$window', '$q', '$$q', '$browser', function ($rootScope, $window, $q, $$q, $browser) {var intervals = {}; function interval(fn, delay, count, invokeApply) {var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise; count = isDefined(count) ? count : 0; promise.$$intervalId = setInterval(function tick() {if (skipApply) {$browser.defer(callback);}else {$rootScope.$evalAsync(callback);}deferred.notify(iteration++); if (count > 0 && iteration >= count) {deferred.resolve(iteration); clearInterval(promise.$$intervalId); delete intervals[promise.$$intervalId];}if (!skipApply) $rootScope.$apply();}, delay); intervals[promise.$$intervalId] = deferred; return promise; function callback() {if (!hasParams) {fn(iteration);}else {fn.apply(null, args);}}}interval.cancel = function (promise) {if (promise && promise.$$intervalId in intervals) {markQExceptionHandled(intervals[promise.$$intervalId].promise); intervals[promise.$$intervalId].reject('canceled'); $window.clearInterval(promise.$$intervalId); delete intervals[promise.$$intervalId]; return true;}return false;}; return interval;}, ];}var $jsonpCallbacksProvider = function () {this.$get = function () {var callbacks = angular.callbacks; var callbackMap = {}; function createCallback(callbackId) {var callback = function (data) {callback.data = data; callback.called = true;}; callback.id = callbackId; return callback;}return {createCallback: function (url) {var callbackId = '_' + (callbacks.$$counter++).toString(36); var callbackPath = 'angular.callbacks.' + callbackId; var callback = createCallback(callbackId); callbackMap[callbackPath] = callbacks[callbackId] = callback; return callbackPath;}, wasCalled: function (callbackPath) {return callbackMap[callbackPath].called;}, getResponse: function (callbackPath) {return callbackMap[callbackPath].data;}, removeCallback: function (callbackPath) {var callback = callbackMap[callbackPath]; delete callbacks[callback.id]; delete callbackMap[callbackPath];}, };};}; var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {http: 80, https: 443, ftp: 21 }; var $locationMinErr = minErr('$location'); function encodePath(path) {var segments = path.split('/'), i = segments.length; while (i--) {segments[i] = encodeUriSegment(segments[i]);}return segments.join('/');}function parseAbsoluteUrl(absoluteUrl, locationObj) {var parsedUrl = urlResolve(absoluteUrl); locationObj.$$protocol = parsedUrl.protocol; locationObj.$$host = parsedUrl.hostname; locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;}var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/; function parseAppUrl(url, locationObj) {if (DOUBLE_SLASH_REGEX.test(url)) {throw $locationMinErr('badpath', 'Invalid url "{0}".', url);}var prefixed = url.charAt(0) !== '/'; if (prefixed) {url = '/' + url;}var match = urlResolve(url); locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname); locationObj.$$search = parseKeyValue(match.search); locationObj.$$hash = decodeURIComponent(match.hash); if (locationObj.$$path && locationObj.$$path.charAt(0) !== '/') {locationObj.$$path = '/' + locationObj.$$path;}}function startsWith(str, search) {return str.slice(0, search.length) === search;}function stripBaseUrl(base, url) {if (startsWith(url, base)) {return url.substr(base.length);}}function stripHash(url) {var index = url.indexOf('#'); return index === -1 ? url : url.substr(0, index);}function trimEmptyHash(url) {return url.replace(/(#.+)|#$/, '$1');}function stripFile(url) {return url.substr(0, stripHash(url).lastIndexOf('/') + 1);}function serverBase(url) {return url.substring(0, url.indexOf('/', url.indexOf(' }function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {this.$$html5 = true; basePrefix = basePrefix || ''; parseAbsoluteUrl(appBase, this); this.$$parse = function (url) {var pathUrl = stripBaseUrl(appBaseNoFile, url); if (!isString(pathUrl)) {throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);}parseAppUrl(pathUrl, this); if (!this.$$path) {this.$$path = '/';}this.$$compose();}; this.$$compose = function () {var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : ''; this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash; this.$$absUrl = appBaseNoFile + this.$$url.substr(1); this.$$urlUpdatedByLocation = true;}; this.$$parseLinkUrl = function (url, relHref) {if (relHref && relHref[0] === '#') {this.hash(relHref.slice(1)); return true;}var appUrl, prevAppUrl; var rewrittenUrl; if (isDefined((appUrl = stripBaseUrl(appBase, url)))) {prevAppUrl = appUrl; if (basePrefix && isDefined((appUrl = stripBaseUrl(basePrefix, appUrl)))) {rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);}else {rewrittenUrl = appBase + prevAppUrl;}}else if (isDefined((appUrl = stripBaseUrl(appBaseNoFile, url)))) {rewrittenUrl = appBaseNoFile + appUrl;}else if (appBaseNoFile === url + '/') {rewrittenUrl = appBaseNoFile;}if (rewrittenUrl) {this.$$parse(rewrittenUrl);}return !!rewrittenUrl;};}function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {parseAbsoluteUrl(appBase, this); this.$$parse = function (url) {var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url); var withoutHashUrl; if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl); if (isUndefined(withoutHashUrl)) {withoutHashUrl = withoutBaseUrl;}}else {if (this.$$html5) {withoutHashUrl = withoutBaseUrl;}else {withoutHashUrl = ''; if (isUndefined(withoutBaseUrl)) {appBase = url; (this).replace();}}}parseAppUrl(withoutHashUrl, this); this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase); this.$$compose(); function removeWindowsDriveName(path, url, base) {var windowsFilePathExp = /^\/[A-Z]:(\/.*)/; var firstPathSegmentMatch; if (startsWith(url, base)) {url = url.replace(base, '');}if (windowsFilePathExp.exec(url)) {return path;}firstPathSegmentMatch = windowsFilePathExp.exec(path); return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;}}; this.$$compose = function () {var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : ''; this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash; this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : ''); this.$$urlUpdatedByLocation = true;}; this.$$parseLinkUrl = function (url, relHref) {if (stripHash(appBase) === stripHash(url)) {this.$$parse(url); return true;}return false;};}function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {this.$$html5 = true; LocationHashbangUrl.apply(this, arguments); this.$$parseLinkUrl = function (url, relHref) {if (relHref && relHref[0] === '#') {this.hash(relHref.slice(1)); return true;}var rewrittenUrl; var appUrl; if (appBase === stripHash(url)) {rewrittenUrl = url;}else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {rewrittenUrl = appBase + hashPrefix + appUrl;}else if (appBaseNoFile === url + '/') {rewrittenUrl = appBaseNoFile;}if (rewrittenUrl) {this.$$parse(rewrittenUrl);}return !!rewrittenUrl;}; this.$$compose = function () {var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : ''; this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash; this.$$absUrl = appBase + hashPrefix + this.$$url; this.$$urlUpdatedByLocation = true;};}var locationPrototype = {$$absUrl: '', $$html5: false, $$replace: false, absUrl: locationGetter('$$absUrl'), url: function (url) {if (isUndefined(url)) {return this.$$url;}var match = PATH_MATCH.exec(url); if (match[1] || url === '') this.path(decodeURIComponent(match[1])); if (match[2] || match[1] || url === '') this.search(match[3] || ''); this.hash(match[5] || ''); return this;}, protocol: locationGetter('$$protocol'), host: locationGetter('$$host'), port: locationGetter('$$port'), path: locationGetterSetter('$$path', function (path) {path = path !== null ? path.toString() : ''; return path.charAt(0) === '/' ? path : '/' + path;}), search: function (search, paramValue) {switch (arguments.length) {case 0: return this.$$search; case 1: if (isString(search) || isNumber(search)) {search = search.toString(); this.$$search = parseKeyValue(search);}else if (isObject(search)) {search = copy(search, {}); forEach(search, function (value, key) {if (value == null) delete search[key];}); this.$$search = search;}else {throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');}break; default: if (isUndefined(paramValue) || paramValue === null) {delete this.$$search[search];}else {this.$$search[search] = paramValue;}}this.$$compose(); return this;}, hash: locationGetterSetter('$$hash', function (hash) {return hash !== null ? hash.toString() : '';}), replace: function () {this.$$replace = true; return this;}, }; forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function (Location) {Location.prototype = Object.create(locationPrototype); Location.prototype.state = function (state) {if (!arguments.length) {return this.$$state;}if (Location !== LocationHtml5Url || !this.$$html5) {throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');}this.$$state = isUndefined(state) ? null : state; this.$$urlUpdatedByLocation = true; return this;};}); function locationGetter(property) {return function () {return this[property];};}function locationGetterSetter(property, preprocess) {return function (value) {if (isUndefined(value)) {return this[property];}this[property] = preprocess(value); this.$$compose(); return this;};}function $LocationProvider() {var hashPrefix = '!', html5Mode = {enabled: false, requireBase: true, rewriteLinks: true, }; this.hashPrefix = function (prefix) {if (isDefined(prefix)) {hashPrefix = prefix; return this;}else {return hashPrefix;}}; this.html5Mode = function (mode) {if (isBoolean(mode)) {html5Mode.enabled = mode; return this;}else if (isObject(mode)) {if (isBoolean(mode.enabled)) {html5Mode.enabled = mode.enabled;}if (isBoolean(mode.requireBase)) {html5Mode.requireBase = mode.requireBase;}if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {html5Mode.rewriteLinks = mode.rewriteLinks;}return this;}else {return html5Mode;}}; this.$get = [ '$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function ($rootScope, $browser, $sniffer, $rootElement, $window) {var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase; if (html5Mode.enabled) {if (!baseHref && html5Mode.requireBase) {throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');}appBase = serverBase(initialUrl) + (baseHref || '/'); LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;}else {appBase = stripHash(initialUrl); LocationMode = LocationHashbangUrl;}var appBaseNoFile = stripFile(appBase); $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix); $location.$$parseLinkUrl(initialUrl, initialUrl); $location.$$state = $browser.state(); var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i; function setBrowserUrlWithFallback(url, replace, state) {var oldUrl = $location.url(); var oldState = $location.$$state; try {$browser.url(url, replace, state); $location.$$state = $browser.state();}catch (e) {$location.url(oldUrl); $location.$$state = oldState; throw e;}}$rootElement.on('click', function (event) {var rewriteLinks = html5Mode.rewriteLinks; if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2) return; var elm = jqLite(event.target); while (nodeName_(elm[0]) !== 'a') {if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;}if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks))) return; var absHref = elm.prop('href'); var relHref = elm.attr('href') || elm.attr('xlink:href'); if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {absHref = urlResolve(absHref.animVal).href;}if (IGNORE_URI_REGEXP.test(absHref)) return; if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {if ($location.$$parseLinkUrl(absHref, relHref)) {event.preventDefault(); if ($location.absUrl() !== $browser.url()) {$rootScope.$apply(); $window.angular['ff-684208-preventDefault'] = true;}}}}); if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {$browser.url($location.absUrl(), true);}var initializing = true; $browser.onUrlChange(function (newUrl, newState) {if (!startsWith(newUrl, appBaseNoFile)) {$window.location.href = newUrl; return;}$rootScope.$evalAsync(function () {var oldUrl = $location.absUrl(); var oldState = $location.$$state; var defaultPrevented; newUrl = trimEmptyHash(newUrl); $location.$$parse(newUrl); $location.$$state = newState; defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented; if ($location.absUrl() !== newUrl) return; if (defaultPrevented) {$location.$$parse(oldUrl); $location.$$state = oldState; setBrowserUrlWithFallback(oldUrl, false, oldState);}else {initializing = false; afterLocationChange(oldUrl, oldState);}}); if (!$rootScope.$$phase) $rootScope.$digest();}); $rootScope.$watch(function $locationWatch() {if (initializing || $location.$$urlUpdatedByLocation) {$location.$$urlUpdatedByLocation = false; var oldUrl = trimEmptyHash($browser.url()); var newUrl = trimEmptyHash($location.absUrl()); var oldState = $browser.state(); var currentReplace = $location.$$replace; var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state); if (initializing || urlOrStateChanged) {initializing = false; $rootScope.$evalAsync(function () {var newUrl = $location.absUrl(); var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented; if ($location.absUrl() !== newUrl) return; if (defaultPrevented) {$location.$$parse(oldUrl); $location.$$state = oldState;}else {if (urlOrStateChanged) {setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);}afterLocationChange(oldUrl, oldState);}});}}$location.$$replace = false;}); return $location; function afterLocationChange(oldUrl, oldState) {$rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);}}, ];}function $LogProvider() {var debug = true, self = this; this.debugEnabled = function (flag) {if (isDefined(flag)) {debug = flag; return this;}else {return debug;}}; this.$get = [ '$window', function ($window) {var formatStackTrace = msie || /\bEdge\ return {log: consoleLog('log'), info: consoleLog('info'), warn: consoleLog('warn'), error: consoleLog('error'), debug: (function () {var fn = consoleLog('debug'); return function () {if (debug) {fn.apply(self, arguments);}};})(), }; function formatError(arg) {if (isError(arg)) {if (arg.stack && formatStackTrace) {arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;}else if (arg.sourceURL) {arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;}}return arg;}function consoleLog(type) {var console = $window.console || {}, logFn = console[type] || console.log || noop; return function () {var args = []; forEach(arguments, function (arg) {args.push(formatError(arg));}); return Function.prototype.apply.call(logFn, console, args);};}}, ];}var $parseMinErr = minErr('$parse'); var objectValueOf = {}.constructor.prototype.valueOf; function getStringValue(name) {return name + '';}var OPERATORS = createMap(); forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {OPERATORS[operator] = true;}); var ESCAPE = {n: '\n', f: '\f', r: '\r', t: '\t', v: '\v', "'": "'", '"': '"' }; var Lexer = function Lexer(options) {this.options = options;}; Lexer.prototype = {constructor: Lexer, lex: function (text) {this.text = text; this.index = 0; this.tokens = []; while (this.index < this.text.length) {var ch = this.text.charAt(this.index); if (ch === '"' || ch === "'") {this.readString(ch);}else if (this.isNumber(ch) || (ch === '.' && this.isNumber(this.peek()))) {this.readNumber();}else if (this.isIdentifierStart(this.peekMultichar())) {this.readIdent();}else if (this.is(ch, '(){}[].,;:?')) {this.tokens.push({index: this.index, text: ch }); this.index++;}else if (this.isWhitespace(ch)) {this.index++;}else {var ch2 = ch + this.peek(); var ch3 = ch2 + this.peek(2); var op1 = OPERATORS[ch]; var op2 = OPERATORS[ch2]; var op3 = OPERATORS[ch3]; if (op1 || op2 || op3) {var token = op3 ? ch3 : op2 ? ch2 : ch; this.tokens.push({index: this.index, text: token, operator: true }); this.index += token.length;}else {this.throwError('Unexpected next character ', this.index, this.index + 1);}}}return this.tokens;}, is: function (ch, chars) {return chars.indexOf(ch) !== -1;}, peek: function (i) {var num = i || 1; return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;}, isNumber: function (ch) {return '0' <= ch && ch <= '9' && typeof ch === 'string';}, isWhitespace: function (ch) {return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0';}, isIdentifierStart: function (ch) {return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);}, isValidIdentifierStart: function (ch) {return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || '_' === ch || ch === '$';}, isIdentifierContinue: function (ch) {return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);}, isValidIdentifierContinue: function (ch, cp) {return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);}, codePointAt: function (ch) {if (ch.length === 1) return ch.charCodeAt(0); return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;}, peekMultichar: function () {var ch = this.text.charAt(this.index); var peek = this.peek(); if (!peek) {return ch;}var cp1 = ch.charCodeAt(0); var cp2 = peek.charCodeAt(0); if (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {return ch + peek;}return ch;}, isExpOperator: function (ch) {return ch === '-' || ch === '+' || this.isNumber(ch);}, throwError: function (error, start, end) {end = end || this.index; var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end; throw $parseMinErr('lexerr', 'Lexer Error: {0}at column{1}in expression [{2}].', error, colStr, this.text);}, readNumber: function () {var number = ''; var start = this.index; while (this.index < this.text.length) {var ch = lowercase(this.text.charAt(this.index)); if (ch === '.' || this.isNumber(ch)) {number += ch;}else {var peekCh = this.peek(); if (ch === 'e' && this.isExpOperator(peekCh)) {number += ch;}else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === 'e') {number += ch;}else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === 'e') {this.throwError('Invalid exponent');}else {break;}}this.index++;}this.tokens.push({index: start, text: number, constant: true, value: Number(number), });}, readIdent: function () {var start = this.index; this.index += this.peekMultichar().length; while (this.index < this.text.length) {var ch = this.peekMultichar(); if (!this.isIdentifierContinue(ch)) {break;}this.index += ch.length;}this.tokens.push({index: start, text: this.text.slice(start, this.index), identifier: true, });}, readString: function (quote) {var start = this.index; this.index++; var string = ''; var rawString = quote; var escape = false; while (this.index < this.text.length) {var ch = this.text.charAt(this.index); rawString += ch; if (escape) {if (ch === 'u') {var hex = this.text.substring(this.index + 1, this.index + 5); if (!hex.match(/[\da-f]{4}/i)) {this.throwError('Invalid unicode escape [\\u' + hex + ']');}this.index += 4; string += String.fromCharCode(parseInt(hex, 16));}else {var rep = ESCAPE[ch]; string = string + (rep || ch);}escape = false;}else if (ch === '\\') {escape = true;}else if (ch === quote) {this.index++; this.tokens.push({index: start, text: rawString, constant: true, value: string, }); return;}else {string += ch;}this.index++;}this.throwError('Unterminated quote', start);}, }; var AST = function AST(lexer, options) {this.lexer = lexer; this.options = options;}; AST.Program = 'Program'; AST.ExpressionStatement = 'ExpressionStatement'; AST.AssignmentExpression = 'AssignmentExpression'; AST.ConditionalExpression = 'ConditionalExpression'; AST.LogicalExpression = 'LogicalExpression'; AST.BinaryExpression = 'BinaryExpression'; AST.UnaryExpression = 'UnaryExpression'; AST.CallExpression = 'CallExpression'; AST.MemberExpression = 'MemberExpression'; AST.Identifier = 'Identifier'; AST.Literal = 'Literal'; AST.ArrayExpression = 'ArrayExpression'; AST.Property = 'Property'; AST.ObjectExpression = 'ObjectExpression'; AST.ThisExpression = 'ThisExpression'; AST.LocalsExpression = 'LocalsExpression'; AST.NGValueParameter = 'NGValueParameter'; AST.prototype = {ast: function (text) {this.text = text; this.tokens = this.lexer.lex(text); var value = this.program(); if (this.tokens.length !== 0) {this.throwError('is an unexpected token', this.tokens[0]);}return value;}, program: function () {var body = []; while (true) {if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']')) body.push(this.expressionStatement()); if (!this.expect(';')) {return {type: AST.Program, body: body };}}}, expressionStatement: function () {return {type: AST.ExpressionStatement, expression: this.filterChain() };}, filterChain: function () {var left = this.expression(); while (this.expect('|')) {left = this.filter(left);}return left;}, expression: function () {return this.assignment();}, assignment: function () {var result = this.ternary(); if (this.expect('=')) {if (!isAssignable(result)) {throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');}result = {type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '=' };}return result;}, ternary: function () {var test = this.logicalOR(); var alternate; var consequent; if (this.expect('?')) {alternate = this.expression(); if (this.consume(':')) {consequent = this.expression(); return {type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent };}}return test;}, logicalOR: function () {var left = this.logicalAND(); while (this.expect('||')) {left = {type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };}return left;}, logicalAND: function () {var left = this.equality(); while (this.expect('&&')) {left = {type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };}return left;}, equality: function () {var left = this.relational(); var token; while ((token = this.expect('==', '!=', '===', '!=='))) {left = {type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };}return left;}, relational: function () {var left = this.additive(); var token; while ((token = this.expect('<', '>', '<=', '>='))) {left = {type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };}return left;}, additive: function () {var left = this.multiplicative(); var token; while ((token = this.expect('+', '-'))) {left = {type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };}return left;}, multiplicative: function () {var left = this.unary(); var token; while ((token = this.expect('*', '/', '%'))) {left = {type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };}return left;}, unary: function () {var token; if ((token = this.expect('+', '-', '!'))) {return {type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };}else {return this.primary();}}, primary: function () {var primary; if (this.expect('(')) {primary = this.filterChain(); this.consume(')');}else if (this.expect('[')) {primary = this.arrayDeclaration();}else if (this.expect('{')) {primary = this.object();}else if (this.selfReferential.hasOwnProperty(this.peek().text)) {primary = copy(this.selfReferential[this.consume().text]);}else if (this.options.literals.hasOwnProperty(this.peek().text)) {primary = {type: AST.Literal, value: this.options.literals[this.consume().text] };}else if (this.peek().identifier) {primary = this.identifier();}else if (this.peek().constant) {primary = this.constant();}else {this.throwError('not a primary expression', this.peek());}var next; while ((next = this.expect('(', '[', '.'))) {if (next.text === '(') {primary = {type: AST.CallExpression, callee: primary, arguments: this.parseArguments() }; this.consume(')');}else if (next.text === '[') {primary = {type: AST.MemberExpression, object: primary, property: this.expression(), computed: true }; this.consume(']');}else if (next.text === '.') {primary = {type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };}else {this.throwError('IMPOSSIBLE');}}return primary;}, filter: function (baseExpression) {var args = [baseExpression]; var result = {type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true }; while (this.expect(':')) {args.push(this.expression());}return result;}, parseArguments: function () {var args = []; if (this.peekToken().text !== ')') {do {args.push(this.filterChain());}while (this.expect(','));}return args;}, identifier: function () {var token = this.consume(); if (!token.identifier) {this.throwError('is not a valid identifier', token);}return {type: AST.Identifier, name: token.text };}, constant: function () {return {type: AST.Literal, value: this.consume().value };}, arrayDeclaration: function () {var elements = []; if (this.peekToken().text !== ']') {do {if (this.peek(']')) {break;}elements.push(this.expression());}while (this.expect(','));}this.consume(']'); return {type: AST.ArrayExpression, elements: elements };}, object: function () {var properties = [], property; if (this.peekToken().text !== '}') {do {if (this.peek('}')) {break;}property = {type: AST.Property, kind: 'init' }; if (this.peek().constant) {property.key = this.constant(); property.computed = false; this.consume(':'); property.value = this.expression();}else if (this.peek().identifier) {property.key = this.identifier(); property.computed = false; if (this.peek(':')) {this.consume(':'); property.value = this.expression();}else {property.value = property.key;}}else if (this.peek('[')) {this.consume('['); property.key = this.expression(); this.consume(']'); property.computed = true; this.consume(':'); property.value = this.expression();}else {this.throwError('invalid key', this.peek());}properties.push(property);}while (this.expect(','));}this.consume('}'); return {type: AST.ObjectExpression, properties: properties };}, throwError: function (msg, token) {throw $parseMinErr( 'syntax', "Syntax Error: Token '{0}' {1}at column {2}of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index), );}, consume: function (e1) {if (this.tokens.length === 0) {throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);}var token = this.expect(e1); if (!token) {this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());}return token;}, peekToken: function () {if (this.tokens.length === 0) {throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);}return this.tokens[0];}, peek: function (e1, e2, e3, e4) {return this.peekAhead(0, e1, e2, e3, e4);}, peekAhead: function (i, e1, e2, e3, e4) {if (this.tokens.length > i) {var token = this.tokens[i]; var t = token.text; if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {return token;}}return false;}, expect: function (e1, e2, e3, e4) {var token = this.peek(e1, e2, e3, e4); if (token) {this.tokens.shift(); return token;}return false;}, selfReferential: {this: {type: AST.ThisExpression }, $locals: {type: AST.LocalsExpression }, }, }; function ifDefined(v, d) {return typeof v !== 'undefined' ? v : d;}function plusFn(l, r) {if (typeof l === 'undefined') return r; if (typeof r === 'undefined') return l; return l + r;}function isStateless($filter, filterName) {var fn = $filter(filterName); return !fn.$stateful;}var PURITY_ABSOLUTE = 1; var PURITY_RELATIVE = 2; function isPure(node, parentIsPure) {switch (node.type) {case AST.MemberExpression: if (node.computed) {return false;}break; case AST.UnaryExpression: return PURITY_ABSOLUTE; case AST.BinaryExpression: return node.operator !== '+' ? PURITY_ABSOLUTE : false; case AST.CallExpression: return false;}return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;}function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {var allConstants; var argsToWatch; var isStatelessFilter; var astIsPure = (ast.isPure = isPure(ast, parentIsPure)); switch (ast.type) {case AST.Program: allConstants = true; forEach(ast.body, function (expr) {findConstantAndWatchExpressions(expr.expression, $filter, astIsPure); allConstants = allConstants && expr.expression.constant;}); ast.constant = allConstants; break; case AST.Literal: ast.constant = true; ast.toWatch = []; break; case AST.UnaryExpression: findConstantAndWatchExpressions(ast.argument, $filter, astIsPure); ast.constant = ast.argument.constant; ast.toWatch = ast.argument.toWatch; break; case AST.BinaryExpression: findConstantAndWatchExpressions(ast.left, $filter, astIsPure); findConstantAndWatchExpressions(ast.right, $filter, astIsPure); ast.constant = ast.left.constant && ast.right.constant; ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch); break; case AST.LogicalExpression: findConstantAndWatchExpressions(ast.left, $filter, astIsPure); findConstantAndWatchExpressions(ast.right, $filter, astIsPure); ast.constant = ast.left.constant && ast.right.constant; ast.toWatch = ast.constant ? [] : [ast]; break; case AST.ConditionalExpression: findConstantAndWatchExpressions(ast.test, $filter, astIsPure); findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure); findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure); ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant; ast.toWatch = ast.constant ? [] : [ast]; break; case AST.Identifier: ast.constant = false; ast.toWatch = [ast]; break; case AST.MemberExpression: findConstantAndWatchExpressions(ast.object, $filter, astIsPure); if (ast.computed) {findConstantAndWatchExpressions(ast.property, $filter, astIsPure);}ast.constant = ast.object.constant && (!ast.computed || ast.property.constant); ast.toWatch = ast.constant ? [] : [ast]; break; case AST.CallExpression: isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false; allConstants = isStatelessFilter; argsToWatch = []; forEach(ast.arguments, function (expr) {findConstantAndWatchExpressions(expr, $filter, astIsPure); allConstants = allConstants && expr.constant; argsToWatch.push.apply(argsToWatch, expr.toWatch);}); ast.constant = allConstants; ast.toWatch = isStatelessFilter ? argsToWatch : [ast]; break; case AST.AssignmentExpression: findConstantAndWatchExpressions(ast.left, $filter, astIsPure); findConstantAndWatchExpressions(ast.right, $filter, astIsPure); ast.constant = ast.left.constant && ast.right.constant; ast.toWatch = [ast]; break; case AST.ArrayExpression: allConstants = true; argsToWatch = []; forEach(ast.elements, function (expr) {findConstantAndWatchExpressions(expr, $filter, astIsPure); allConstants = allConstants && expr.constant; argsToWatch.push.apply(argsToWatch, expr.toWatch);}); ast.constant = allConstants; ast.toWatch = argsToWatch; break; case AST.ObjectExpression: allConstants = true; argsToWatch = []; forEach(ast.properties, function (property) {findConstantAndWatchExpressions(property.value, $filter, astIsPure); allConstants = allConstants && property.value.constant; argsToWatch.push.apply(argsToWatch, property.value.toWatch); if (property.computed) {findConstantAndWatchExpressions(property.key, $filter, false); allConstants = allConstants && property.key.constant; argsToWatch.push.apply(argsToWatch, property.key.toWatch);}}); ast.constant = allConstants; ast.toWatch = argsToWatch; break; case AST.ThisExpression: ast.constant = false; ast.toWatch = []; break; case AST.LocalsExpression: ast.constant = false; ast.toWatch = []; break;}}function getInputs(body) {if (body.length !== 1) return; var lastExpression = body[0].expression; var candidate = lastExpression.toWatch; if (candidate.length !== 1) return candidate; return candidate[0] !== lastExpression ? candidate : undefined;}function isAssignable(ast) {return ast.type === AST.Identifier || ast.type === AST.MemberExpression;}function assignableAST(ast) {if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {return {type: AST.AssignmentExpression, left: ast.body[0].expression, right: {type: AST.NGValueParameter }, operator: '=' };}}function isLiteral(ast) {return ( ast.body.length === 0 || (ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression)) );}function isConstant(ast) {return ast.constant;}function ASTCompiler($filter) {this.$filter = $filter;}ASTCompiler.prototype = {compile: function (ast) {var self = this; this.state = {nextId: 0, filters: {}, fn: {vars: [], body: [], own: {}}, assign: {vars: [], body: [], own: {}}, inputs: [], }; findConstantAndWatchExpressions(ast, self.$filter); var extra = ''; var assignable; this.stage = 'assign'; if ((assignable = assignableAST(ast))) {this.state.computing = 'assign'; var result = this.nextId(); this.recurse(assignable, result); this.return_(result); extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');}var toWatch = getInputs(ast.body); self.stage = 'inputs'; forEach(toWatch, function (watch, key) {var fnKey = 'fn' + key; self.state[fnKey] = {vars: [], body: [], own: {}}; self.state.computing = fnKey; var intoId = self.nextId(); self.recurse(watch, intoId); self.return_(intoId); self.state.inputs.push({name: fnKey, isPure: watch.isPure }); watch.watchId = key;}); this.state.computing = 'fn'; this.stage = 'main'; this.recurse(ast); var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;'; var fn = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString)(this.$filter, getStringValue, ifDefined, plusFn); this.state = this.stage = undefined; return fn;}, USE: 'use', STRICT: 'strict', watchFns: function () {var result = []; var inputs = this.state.inputs; var self = this; forEach(inputs, function (input) {result.push('var ' + input.name + '=' + self.generateFunction(input.name, 's')); if (input.isPure) {result.push(input.name, '.isPure=' + JSON.stringify(input.isPure) + ';');}}); if (inputs.length) {result.push( 'fn.inputs=[' + inputs .map(function (i) {return i.name;}) .join(',') + '];', );}return result.join('');}, generateFunction: function (name, params) {return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';}, filterPrefix: function () {var parts = []; var self = this; forEach(this.state.filters, function (id, filter) {parts.push(id + '=$filter(' + self.escape(filter) + ')');}); if (parts.length) return 'var ' + parts.join(',') + ';'; return '';}, varsPrefix: function (section) {return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';}, body: function (section) {return this.state[section].body.join('');}, recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {var left, right, self = this, args, expression, computed; recursionFn = recursionFn || noop; if (!skipWatchIdCheck && isDefined(ast.watchId)) {intoId = intoId || this.nextId(); this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)); return;}switch (ast.type) {case AST.Program: forEach(ast.body, function (expression, pos) {self.recurse(expression.expression, undefined, undefined, function (expr) {right = expr;}); if (pos !== ast.body.length - 1) {self.current().body.push(right, ';');}else {self.return_(right);}}); break; case AST.Literal: expression = this.escape(ast.value); this.assign(intoId, expression); recursionFn(intoId || expression); break; case AST.UnaryExpression: this.recurse(ast.argument, undefined, undefined, function (expr) {right = expr;}); expression = ast.operator + '(' + this.ifDefined(right, 0) + ')'; this.assign(intoId, expression); recursionFn(expression); break; case AST.BinaryExpression: this.recurse(ast.left, undefined, undefined, function (expr) {left = expr;}); this.recurse(ast.right, undefined, undefined, function (expr) {right = expr;}); if (ast.operator === '+') {expression = this.plus(left, right);}else if (ast.operator === '-') {expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);}else {expression = '(' + left + ')' + ast.operator + '(' + right + ')';}this.assign(intoId, expression); recursionFn(expression); break; case AST.LogicalExpression: intoId = intoId || this.nextId(); self.recurse(ast.left, intoId); self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)); recursionFn(intoId); break; case AST.ConditionalExpression: intoId = intoId || this.nextId(); self.recurse(ast.test, intoId); self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)); recursionFn(intoId); break; case AST.Identifier: intoId = intoId || this.nextId(); if (nameId) {nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s'); nameId.computed = false; nameId.name = ast.name;}self.if_( self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {self.if_(self.stage === 'inputs' || 's', function () {if (create && create !== 1) {self.if_(self.isNull(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));}self.assign(intoId, self.nonComputedMember('s', ast.name));});}, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)), ); recursionFn(intoId); break; case AST.MemberExpression: left = (nameId && (nameId.context = this.nextId())) || this.nextId(); intoId = intoId || this.nextId(); self.recurse( ast.object, left, undefined, function () {self.if_( self.notNull(left), function () {if (ast.computed) {right = self.nextId(); self.recurse(ast.property, right); self.getStringValue(right); if (create && create !== 1) {self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));}expression = self.computedMember(left, right); self.assign(intoId, expression); if (nameId) {nameId.computed = true; nameId.name = right;}}else {if (create && create !== 1) {self.if_( self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'), );}expression = self.nonComputedMember(left, ast.property.name); self.assign(intoId, expression); if (nameId) {nameId.computed = false; nameId.name = ast.property.name;}}}, function () {self.assign(intoId, 'undefined');}, ); recursionFn(intoId);}, !!create, ); break; case AST.CallExpression: intoId = intoId || this.nextId(); if (ast.filter) {right = self.filter(ast.callee.name); args = []; forEach(ast.arguments, function (expr) {var argument = self.nextId(); self.recurse(expr, argument); args.push(argument);}); expression = right + '(' + args.join(',') + ')'; self.assign(intoId, expression); recursionFn(intoId);}else {right = self.nextId(); left = {}; args = []; self.recurse(ast.callee, right, left, function () {self.if_( self.notNull(right), function () {forEach(ast.arguments, function (expr) {self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {args.push(argument);});}); if (left.name) {expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';}else {expression = right + '(' + args.join(',') + ')';}self.assign(intoId, expression);}, function () {self.assign(intoId, 'undefined');}, ); recursionFn(intoId);});}break; case AST.AssignmentExpression: right = this.nextId(); left = {}; this.recurse( ast.left, undefined, left, function () {self.if_(self.notNull(left.context), function () {self.recurse(ast.right, right); expression = self.member(left.context, left.name, left.computed) + ast.operator + right; self.assign(intoId, expression); recursionFn(intoId || expression);});}, 1, ); break; case AST.ArrayExpression: args = []; forEach(ast.elements, function (expr) {self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {args.push(argument);});}); expression = '[' + args.join(',') + ']'; this.assign(intoId, expression); recursionFn(intoId || expression); break; case AST.ObjectExpression: args = []; computed = false; forEach(ast.properties, function (property) {if (property.computed) {computed = true;}}); if (computed) {intoId = intoId || this.nextId(); this.assign(intoId, '{}'); forEach(ast.properties, function (property) {if (property.computed) {left = self.nextId(); self.recurse(property.key, left);}else {left = property.key.type === AST.Identifier ? property.key.name : '' + property.key.value;}right = self.nextId(); self.recurse(property.value, right); self.assign(self.member(intoId, left, property.computed), right);});}else {forEach(ast.properties, function (property) {self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);});}); expression = '{' + args.join(',') + '}'; this.assign(intoId, expression);}recursionFn(intoId || expression); break; case AST.ThisExpression: this.assign(intoId, 's'); recursionFn(intoId || 's'); break; case AST.LocalsExpression: this.assign(intoId, 'l'); recursionFn(intoId || 'l'); break; case AST.NGValueParameter: this.assign(intoId, 'v'); recursionFn(intoId || 'v'); break;}}, getHasOwnProperty: function (element, property) {var key = element + '.' + property; var own = this.current().own; if (!own.hasOwnProperty(key)) {own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');}return own[key];}, assign: function (id, value) {if (!id) return; this.current().body.push(id, '=', value, ';'); return id;}, filter: function (filterName) {if (!this.state.filters.hasOwnProperty(filterName)) {this.state.filters[filterName] = this.nextId(true);}return this.state.filters[filterName];}, ifDefined: function (id, defaultValue) {return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';}, plus: function (left, right) {return 'plus(' + left + ',' + right + ')';}, return_: function (id) {this.current().body.push('return ', id, ';');}, if_: function (test, alternate, consequent) {if (test === true) {alternate();}else {var body = this.current().body; body.push('if(', test, '){'); alternate(); body.push('}'); if (consequent) {body.push('else{'); consequent(); body.push('}');}}}, not: function (expression) {return '!(' + expression + ')';}, isNull: function (expression) {return expression + '==null';}, notNull: function (expression) {return expression + '!=null';}, nonComputedMember: function (left, right) {var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/; var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g; if (SAFE_IDENTIFIER.test(right)) {return left + '.' + right;}else {return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';}}, computedMember: function (left, right) {return left + '[' + right + ']';}, member: function (left, right, computed) {if (computed) return this.computedMember(left, right); return this.nonComputedMember(left, right);}, getStringValue: function (item) {this.assign(item, 'getStringValue(' + item + ')');}, lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {var self = this; return function () {self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);};}, lazyAssign: function (id, value) {var self = this; return function () {self.assign(id, value);};}, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (c) {return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);}, escape: function (value) {if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (isNumber(value)) return value.toString(); if (value === true) return 'true'; if (value === false) return 'false'; if (value === null) return 'null'; if (typeof value === 'undefined') return 'undefined'; throw $parseMinErr('esc', 'IMPOSSIBLE');}, nextId: function (skip, init) {var id = 'v' + this.state.nextId++; if (!skip) {this.current().vars.push(id + (init ? '=' + init : ''));}return id;}, current: function () {return this.state[this.state.computing];}, }; function ASTInterpreter($filter) {this.$filter = $filter;}ASTInterpreter.prototype = {compile: function (ast) {var self = this; findConstantAndWatchExpressions(ast, self.$filter); var assignable; var assign; if ((assignable = assignableAST(ast))) {assign = this.recurse(assignable);}var toWatch = getInputs(ast.body); var inputs; if (toWatch) {inputs = []; forEach(toWatch, function (watch, key) {var input = self.recurse(watch); input.isPure = watch.isPure; watch.input = input; inputs.push(input); watch.watchId = key;});}var expressions = []; forEach(ast.body, function (expression) {expressions.push(self.recurse(expression.expression));}); var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {var lastValue; forEach(expressions, function (exp) {lastValue = exp(scope, locals);}); return lastValue;}; if (assign) {fn.assign = function (scope, value, locals) {return assign(scope, locals, value);};}if (inputs) {fn.inputs = inputs;}return fn;}, recurse: function (ast, context, create) {var left, right, self = this, args; if (ast.input) {return this.inputs(ast.input, ast.watchId);}switch (ast.type) {case AST.Literal: return this.value(ast.value, context); case AST.UnaryExpression: right = this.recurse(ast.argument); return this['unary' + ast.operator](right, context); case AST.BinaryExpression: left = this.recurse(ast.left); right = this.recurse(ast.right); return this['binary' + ast.operator](left, right, context); case AST.LogicalExpression: left = this.recurse(ast.left); right = this.recurse(ast.right); return this['binary' + ast.operator](left, right, context); case AST.ConditionalExpression: return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context); case AST.Identifier: return self.identifier(ast.name, context, create); case AST.MemberExpression: left = this.recurse(ast.object, false, !!create); if (!ast.computed) {right = ast.property.name;}if (ast.computed) right = this.recurse(ast.property); return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create); case AST.CallExpression: args = []; forEach(ast.arguments, function (expr) {args.push(self.recurse(expr));}); if (ast.filter) right = this.$filter(ast.callee.name); if (!ast.filter) right = this.recurse(ast.callee, true); return ast.filter ? function (scope, locals, assign, inputs) {var values = []; for (var i = 0; i < args.length; ++i) {values.push(args[i](scope, locals, assign, inputs));}var value = right.apply(undefined, values, inputs); return context ? {context: undefined, name: undefined, value: value }: value;}: function (scope, locals, assign, inputs) {var rhs = right(scope, locals, assign, inputs); var value; if (rhs.value != null) {var values = []; for (var i = 0; i < args.length; ++i) {values.push(args[i](scope, locals, assign, inputs));}value = rhs.value.apply(rhs.context, values);}return context ? {value: value }: value;}; case AST.AssignmentExpression: left = this.recurse(ast.left, true, 1); right = this.recurse(ast.right); return function (scope, locals, assign, inputs) {var lhs = left(scope, locals, assign, inputs); var rhs = right(scope, locals, assign, inputs); lhs.context[lhs.name] = rhs; return context ? {value: rhs }: rhs;}; case AST.ArrayExpression: args = []; forEach(ast.elements, function (expr) {args.push(self.recurse(expr));}); return function (scope, locals, assign, inputs) {var value = []; for (var i = 0; i < args.length; ++i) {value.push(args[i](scope, locals, assign, inputs));}return context ? {value: value }: value;}; case AST.ObjectExpression: args = []; forEach(ast.properties, function (property) {if (property.computed) {args.push({key: self.recurse(property.key), computed: true, value: self.recurse(property.value) });}else {args.push({key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value, computed: false, value: self.recurse(property.value), });}}); return function (scope, locals, assign, inputs) {var value = {}; for (var i = 0; i < args.length; ++i) {if (args[i].computed) {value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);}else {value[args[i].key] = args[i].value(scope, locals, assign, inputs);}}return context ? {value: value }: value;}; case AST.ThisExpression: return function (scope) {return context ? {value: scope }: scope;}; case AST.LocalsExpression: return function (scope, locals) {return context ? {value: locals }: locals;}; case AST.NGValueParameter: return function (scope, locals, assign) {return context ? {value: assign }: assign;};}}, 'unary+': function (argument, context) {return function (scope, locals, assign, inputs) {var arg = argument(scope, locals, assign, inputs); if (isDefined(arg)) {arg = +arg;}else {arg = 0;}return context ? {value: arg }: arg;};}, 'unary-': function (argument, context) {return function (scope, locals, assign, inputs) {var arg = argument(scope, locals, assign, inputs); if (isDefined(arg)) {arg = -arg;}else {arg = -0;}return context ? {value: arg }: arg;};}, 'unary!': function (argument, context) {return function (scope, locals, assign, inputs) {var arg = !argument(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary+': function (left, right, context) {return function (scope, locals, assign, inputs) {var lhs = left(scope, locals, assign, inputs); var rhs = right(scope, locals, assign, inputs); var arg = plusFn(lhs, rhs); return context ? {value: arg }: arg;};}, 'binary-': function (left, right, context) {return function (scope, locals, assign, inputs) {var lhs = left(scope, locals, assign, inputs); var rhs = right(scope, locals, assign, inputs); var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0); return context ? {value: arg }: arg;};}, 'binary*': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary/': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary%': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary===': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary!==': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary==': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary!=': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary<': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary>': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary<=': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary>=': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary&&': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'binary||': function (left, right, context) {return function (scope, locals, assign, inputs) {var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, 'ternary?:': function (test, alternate, consequent, context) {return function (scope, locals, assign, inputs) {var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs); return context ? {value: arg }: arg;};}, value: function (value, context) {return function () {return context ? {context: undefined, name: undefined, value: value }: value;};}, identifier: function (name, context, create) {return function (scope, locals, assign, inputs) {var base = locals && name in locals ? locals : scope; if (create && create !== 1 && base && base[name] == null) {base[name] = {};}var value = base ? base[name] : undefined; if (context) {return {context: base, name: name, value: value };}else {return value;}};}, computedMember: function (left, right, context, create) {return function (scope, locals, assign, inputs) {var lhs = left(scope, locals, assign, inputs); var rhs; var value; if (lhs != null) {rhs = right(scope, locals, assign, inputs); rhs = getStringValue(rhs); if (create && create !== 1) {if (lhs && !lhs[rhs]) {lhs[rhs] = {};}}value = lhs[rhs];}if (context) {return {context: lhs, name: rhs, value: value };}else {return value;}};}, nonComputedMember: function (left, right, context, create) {return function (scope, locals, assign, inputs) {var lhs = left(scope, locals, assign, inputs); if (create && create !== 1) {if (lhs && lhs[right] == null) {lhs[right] = {};}}var value = lhs != null ? lhs[right] : undefined; if (context) {return {context: lhs, name: right, value: value };}else {return value;}};}, inputs: function (input, watchId) {return function (scope, value, locals, inputs) {if (inputs) return inputs[watchId]; return input(scope, value, locals);};}, }; function Parser(lexer, $filter, options) {this.ast = new AST(lexer, options); this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);}Parser.prototype = {constructor: Parser, parse: function (text) {var ast = this.ast.ast(text); var fn = this.astCompiler.compile(ast); fn.literal = isLiteral(ast); fn.constant = isConstant(ast); return fn;}, }; function getValueOf(value) {return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);}function $ParseProvider() {var cache = createMap(); var literals = {true: true, false: false, null: null, undefined: undefined, }; var identStart, identContinue; this.addLiteral = function (literalName, literalValue) {literals[literalName] = literalValue;}; this.setIdentifierFns = function (identifierStart, identifierContinue) {identStart = identifierStart; identContinue = identifierContinue; return this;}; this.$get = [ '$filter', function ($filter) {var noUnsafeEval = csp().noUnsafeEval; var $parseOptions = {csp: noUnsafeEval, literals: copy(literals), isIdentifierStart: isFunction(identStart) && identStart, isIdentifierContinue: isFunction(identContinue) && identContinue, }; return $parse; function $parse(exp, interceptorFn) {var parsedExpression, oneTime, cacheKey; switch (typeof exp) {case 'string': exp = exp.trim(); cacheKey = exp; parsedExpression = cache[cacheKey]; if (!parsedExpression) {if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {oneTime = true; exp = exp.substring(2);}var lexer = new Lexer($parseOptions); var parser = new Parser(lexer, $filter, $parseOptions); parsedExpression = parser.parse(exp); if (parsedExpression.constant) {parsedExpression.$$watchDelegate = constantWatchDelegate;}else if (oneTime) {parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;}else if (parsedExpression.inputs) {parsedExpression.$$watchDelegate = inputsWatchDelegate;}cache[cacheKey] = parsedExpression;}return addInterceptor(parsedExpression, interceptorFn); case 'function': return addInterceptor(exp, interceptorFn); default: return addInterceptor(noop, interceptorFn);}}function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {if (newValue == null || oldValueOfValue == null) {return newValue === oldValueOfValue;}if (typeof newValue === 'object') {newValue = getValueOf(newValue); if (typeof newValue === 'object' && !compareObjectIdentity) {return false;}}return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);}function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {var inputExpressions = parsedExpression.inputs; var lastResult; if (inputExpressions.length === 1) {var oldInputValueOf = expressionInputDirtyCheck; inputExpressions = inputExpressions[0]; return scope.$watch( function expressionInputWatch(scope) {var newInputValue = inputExpressions(scope); if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]); oldInputValueOf = newInputValue && getValueOf(newInputValue);}return lastResult;}, listener, objectEquality, prettyPrintExpression, );}var oldInputValueOfValues = []; var oldInputValues = []; for (var i = 0, ii = inputExpressions.length; i < ii; i++) {oldInputValueOfValues[i] = expressionInputDirtyCheck; oldInputValues[i] = null;}return scope.$watch( function expressionInputsWatch(scope) {var changed = false; for (var i = 0, ii = inputExpressions.length; i < ii; i++) {var newInputValue = inputExpressions[i](scope); if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) {oldInputValues[i] = newInputValue; oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);}}if (changed) {lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);}return lastResult;}, listener, objectEquality, prettyPrintExpression, );}function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {var unwatch, lastValue; if (parsedExpression.inputs) {unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);}else {unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);}return unwatch; function oneTimeWatch(scope) {return parsedExpression(scope);}function oneTimeListener(value, old, scope) {lastValue = value; if (isFunction(listener)) {listener(value, old, scope);}if (isDefined(value)) {scope.$$postDigest(function () {if (isDefined(lastValue)) {unwatch();}});}}}function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {var unwatch, lastValue; unwatch = scope.$watch( function oneTimeWatch(scope) {return parsedExpression(scope);}, function oneTimeListener(value, old, scope) {lastValue = value; if (isFunction(listener)) {listener(value, old, scope);}if (isAllDefined(value)) {scope.$$postDigest(function () {if (isAllDefined(lastValue)) unwatch();});}}, objectEquality, ); return unwatch; function isAllDefined(value) {var allDefined = true; forEach(value, function (val) {if (!isDefined(val)) allDefined = false;}); return allDefined;}}function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {var unwatch = scope.$watch( function constantWatch(scope) {unwatch(); return parsedExpression(scope);}, listener, objectEquality, ); return unwatch;}function addInterceptor(parsedExpression, interceptorFn) {if (!interceptorFn) return parsedExpression; var watchDelegate = parsedExpression.$$watchDelegate; var useInputs = false; var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate; var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs); return interceptorFn(value, scope, locals);}: function oneTimeInterceptedExpression(scope, locals, assign, inputs) {var value = parsedExpression(scope, locals, assign, inputs); var result = interceptorFn(value, scope, locals); return isDefined(value) ? result : value;}; useInputs = !parsedExpression.inputs; if (watchDelegate && watchDelegate !== inputsWatchDelegate) {fn.$$watchDelegate = watchDelegate; fn.inputs = parsedExpression.inputs;}else if (!interceptorFn.$stateful) {fn.$$watchDelegate = inputsWatchDelegate; fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];}if (fn.inputs) {fn.inputs = fn.inputs.map(function (e) {if (e.isPure === PURITY_RELATIVE) {return function depurifier(s) {return e(s);};}return e;});}return fn;}}, ];}function $QProvider() {var errorOnUnhandledRejections = true; this.$get = [ '$rootScope', '$exceptionHandler', function ($rootScope, $exceptionHandler) {return qFactory( function (callback) {$rootScope.$evalAsync(callback);}, $exceptionHandler, errorOnUnhandledRejections, );}, ]; this.errorOnUnhandledRejections = function (value) {if (isDefined(value)) {errorOnUnhandledRejections = value; return this;}else {return errorOnUnhandledRejections;}};}function $$QProvider() {var errorOnUnhandledRejections = true; this.$get = [ '$browser', '$exceptionHandler', function ($browser, $exceptionHandler) {return qFactory( function (callback) {$browser.defer(callback);}, $exceptionHandler, errorOnUnhandledRejections, );}, ]; this.errorOnUnhandledRejections = function (value) {if (isDefined(value)) {errorOnUnhandledRejections = value; return this;}else {return errorOnUnhandledRejections;}};}function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {var $qMinErr = minErr('$q', TypeError); var queueSize = 0; var checkQueue = []; function defer() {return new Deferred();}function Deferred() {var promise = (this.promise = new Promise()); this.resolve = function (val) {resolvePromise(promise, val);}; this.reject = function (reason) {rejectPromise(promise, reason);}; this.notify = function (progress) {notifyPromise(promise, progress);};}function Promise() {this.$$state = {status: 0 };}extend(Promise.prototype, {then: function (onFulfilled, onRejected, progressBack) {if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {return this;}var result = new Promise(); this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]); if (this.$$state.status > 0) scheduleProcessQueue(this.$$state); return result;}, catch: function (callback) {return this.then(null, callback);}, finally: function (callback, progressBack) {return this.then( function (value) {return handleCallback(value, resolve, callback);}, function (error) {return handleCallback(error, reject, callback);}, progressBack, );}, }); function processQueue(state) {var fn, promise, pending; pending = state.pending; state.processScheduled = false; state.pending = undefined; try {for (var i = 0, ii = pending.length; i < ii; ++i) {markQStateExceptionHandled(state); promise = pending[i][0]; fn = pending[i][state.status]; try {if (isFunction(fn)) {resolvePromise(promise, fn(state.value));}else if (state.status === 1) {resolvePromise(promise, state.value);}else {rejectPromise(promise, state.value);}}catch (e) {rejectPromise(promise, e);}}}finally {--queueSize; if (errorOnUnhandledRejections && queueSize === 0) {nextTick(processChecks);}}}function processChecks() {while (!queueSize && checkQueue.length) {var toCheck = checkQueue.shift(); if (!isStateExceptionHandled(toCheck)) {markQStateExceptionHandled(toCheck); var errorMessage = 'Possibly unhandled rejection: ' + toDebugString(toCheck.value); if (isError(toCheck.value)) {exceptionHandler(toCheck.value, errorMessage);}else {exceptionHandler(errorMessage);}}}}function scheduleProcessQueue(state) {if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !isStateExceptionHandled(state)) {if (queueSize === 0 && checkQueue.length === 0) {nextTick(processChecks);}checkQueue.push(state);}if (state.processScheduled || !state.pending) return; state.processScheduled = true; ++queueSize; nextTick(function () {processQueue(state);});}function resolvePromise(promise, val) {if (promise.$$state.status) return; if (val === promise) {$$reject(promise, $qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));}else {$$resolve(promise, val);}}function $$resolve(promise, val) {var then; var done = false; try {if (isObject(val) || isFunction(val)) then = val.then; if (isFunction(then)) {promise.$$state.status = -1; then.call(val, doResolve, doReject, doNotify);}else {promise.$$state.value = val; promise.$$state.status = 1; scheduleProcessQueue(promise.$$state);}}catch (e) {doReject(e);}function doResolve(val) {if (done) return; done = true; $$resolve(promise, val);}function doReject(val) {if (done) return; done = true; $$reject(promise, val);}function doNotify(progress) {notifyPromise(promise, progress);}}function rejectPromise(promise, reason) {if (promise.$$state.status) return; $$reject(promise, reason);}function $$reject(promise, reason) {promise.$$state.value = reason; promise.$$state.status = 2; scheduleProcessQueue(promise.$$state);}function notifyPromise(promise, progress) {var callbacks = promise.$$state.pending; if (promise.$$state.status <= 0 && callbacks && callbacks.length) {nextTick(function () {var callback, result; for (var i = 0, ii = callbacks.length; i < ii; i++) {result = callbacks[i][0]; callback = callbacks[i][3]; try {notifyPromise(result, isFunction(callback) ? callback(progress) : progress);}catch (e) {exceptionHandler(e);}}});}}function reject(reason) {var result = new Promise(); rejectPromise(result, reason); return result;}function handleCallback(value, resolver, callback) {var callbackOutput = null; try {if (isFunction(callback)) callbackOutput = callback();}catch (e) {return reject(e);}if (isPromiseLike(callbackOutput)) {return callbackOutput.then(function () {return resolver(value);}, reject);}else {return resolver(value);}}function when(value, callback, errback, progressBack) {var result = new Promise(); resolvePromise(result, value); return result.then(callback, errback, progressBack);}var resolve = when; function all(promises) {var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {}; forEach(promises, function (promise, key) {counter++; when(promise).then( function (value) {results[key] = value; if (!--counter) resolvePromise(result, results);}, function (reason) {rejectPromise(result, reason);}, );}); if (counter === 0) {resolvePromise(result, results);}return result;}function race(promises) {var deferred = defer(); forEach(promises, function (promise) {when(promise).then(deferred.resolve, deferred.reject);}); return deferred.promise;}function $Q(resolver) {if (!isFunction(resolver)) {throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);}var promise = new Promise(); function resolveFn(value) {resolvePromise(promise, value);}function rejectFn(reason) {rejectPromise(promise, reason);}resolver(resolveFn, rejectFn); return promise;}$Q.prototype = Promise.prototype; $Q.defer = defer; $Q.reject = reject; $Q.when = when; $Q.resolve = resolve; $Q.all = all; $Q.race = race; return $Q;}function isStateExceptionHandled(state) {return !!state.pur;}function markQStateExceptionHandled(state) {state.pur = true;}function markQExceptionHandled(q) {markQStateExceptionHandled(q.$$state);}function $$RAFProvider() {this.$get = [ '$window', '$timeout', function ($window, $timeout) {var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame; var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame; var rafSupported = !!requestAnimationFrame; var raf = rafSupported ? function (fn) {var id = requestAnimationFrame(fn); return function () {cancelAnimationFrame(id);};}: function (fn) {var timer = $timeout(fn, 16.66, false); return function () {$timeout.cancel(timer);};}; raf.supported = rafSupported; return raf;}, ];}function $RootScopeProvider() {var TTL = 10; var $rootScopeMinErr = minErr('$rootScope'); var lastDirtyWatch = null; var applyAsyncId = null; this.digestTtl = function (value) {if (arguments.length) {TTL = value;}return TTL;}; function createChildScopeClass(parent) {function ChildScope() {this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = nextUid(); this.$$ChildScope = null;}ChildScope.prototype = parent; return ChildScope;}this.$get = [ '$exceptionHandler', '$parse', '$browser', function ($exceptionHandler, $parse, $browser) {function destroyChildScope($event) {$event.currentScope.$$destroyed = true;}function cleanUpScope($scope) {if (msie === 9) {if ($scope.$$childHead) {cleanUpScope($scope.$$childHead);}if ($scope.$$nextSibling) {cleanUpScope($scope.$$nextSibling);}}$scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;}function Scope() {this.$id = nextUid(); this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$destroyed = false; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null;}Scope.prototype = {constructor: Scope, $new: function (isolate, parent) {var child; parent = parent || this; if (isolate) {child = new Scope(); child.$root = this.$root;}else {if (!this.$$ChildScope) {this.$$ChildScope = createChildScopeClass(this);}child = new this.$$ChildScope();}child.$parent = parent; child.$$prevSibling = parent.$$childTail; if (parent.$$childHead) {parent.$$childTail.$$nextSibling = child; parent.$$childTail = child;}else {parent.$$childHead = parent.$$childTail = child;}if (isolate || parent !== this) child.$on('$destroy', destroyChildScope); return child;}, $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {var get = $parse(watchExp); if (get.$$watchDelegate) {return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);}var scope = this, array = scope.$$watchers, watcher = {fn: listener, last: initWatchVal, get: get, exp: prettyPrintExpression || watchExp, eq: !!objectEquality, }; lastDirtyWatch = null; if (!isFunction(listener)) {watcher.fn = noop;}if (!array) {array = scope.$$watchers = []; array.$$digestWatchIndex = -1;}array.unshift(watcher); array.$$digestWatchIndex++; incrementWatchersCount(this, 1); return function deregisterWatch() {var index = arrayRemove(array, watcher); if (index >= 0) {incrementWatchersCount(scope, -1); if (index < array.$$digestWatchIndex) {array.$$digestWatchIndex--;}}lastDirtyWatch = null;};}, $watchGroup: function (watchExpressions, listener) {var oldValues = new Array(watchExpressions.length); var newValues = new Array(watchExpressions.length); var deregisterFns = []; var self = this; var changeReactionScheduled = false; var firstRun = true; if (!watchExpressions.length) {var shouldCall = true; self.$evalAsync(function () {if (shouldCall) listener(newValues, newValues, self);}); return function deregisterWatchGroup() {shouldCall = false;};}if (watchExpressions.length === 1) {return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {newValues[0] = value; oldValues[0] = oldValue; listener(newValues, value === oldValue ? newValues : oldValues, scope);});}forEach(watchExpressions, function (expr, i) {var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {newValues[i] = value; oldValues[i] = oldValue; if (!changeReactionScheduled) {changeReactionScheduled = true; self.$evalAsync(watchGroupAction);}}); deregisterFns.push(unwatchFn);}); function watchGroupAction() {changeReactionScheduled = false; if (firstRun) {firstRun = false; listener(newValues, newValues, self);}else {listener(newValues, oldValues, self);}}return function deregisterWatchGroup() {while (deregisterFns.length) {deregisterFns.shift()();}};}, $watchCollection: function (obj, listener) {$watchCollectionInterceptor.$stateful = true; var self = this; var newValue; var oldValue; var veryOldValue; var trackVeryOldValue = listener.length > 1; var changeDetected = 0; var changeDetector = $parse(obj, $watchCollectionInterceptor); var internalArray = []; var internalObject = {}; var initRun = true; var oldLength = 0; function $watchCollectionInterceptor(_value) {newValue = _value; var newLength, key, bothNaN, newItem, oldItem; if (isUndefined(newValue)) return; if (!isObject(newValue)) {if (oldValue !== newValue) {oldValue = newValue; changeDetected++;}}else if (isArrayLike(newValue)) {if (oldValue !== internalArray) {oldValue = internalArray; oldLength = oldValue.length = 0; changeDetected++;}newLength = newValue.length; if (oldLength !== newLength) {changeDetected++; oldValue.length = oldLength = newLength;}for (var i = 0; i < newLength; i++) {oldItem = oldValue[i]; newItem = newValue[i]; bothNaN = oldItem !== oldItem && newItem !== newItem; if (!bothNaN && oldItem !== newItem) {changeDetected++; oldValue[i] = newItem;}}}else {if (oldValue !== internalObject) {oldValue = internalObject = {}; oldLength = 0; changeDetected++;}newLength = 0; for (key in newValue) {if (hasOwnProperty.call(newValue, key)) {newLength++; newItem = newValue[key]; oldItem = oldValue[key]; if (key in oldValue) {bothNaN = oldItem !== oldItem && newItem !== newItem; if (!bothNaN && oldItem !== newItem) {changeDetected++; oldValue[key] = newItem;}}else {oldLength++; oldValue[key] = newItem; changeDetected++;}}}if (oldLength > newLength) {changeDetected++; for (key in oldValue) {if (!hasOwnProperty.call(newValue, key)) {oldLength--; delete oldValue[key];}}}}return changeDetected;}function $watchCollectionAction() {if (initRun) {initRun = false; listener(newValue, newValue, self);}else {listener(newValue, veryOldValue, self);}if (trackVeryOldValue) {if (!isObject(newValue)) {veryOldValue = newValue;}else if (isArrayLike(newValue)) {veryOldValue = new Array(newValue.length); for (var i = 0; i < newValue.length; i++) {veryOldValue[i] = newValue[i];}}else {veryOldValue = {}; for (var key in newValue) {if (hasOwnProperty.call(newValue, key)) {veryOldValue[key] = newValue[key];}}}}}return this.$watch(changeDetector, $watchCollectionAction);}, $digest: function () {var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask; beginPhase('$digest'); $browser.$$checkUrlChange(); if (this === $rootScope && applyAsyncId !== null) {$browser.defer.cancel(applyAsyncId); flushApplyAsync();}lastDirtyWatch = null; do {dirty = false; current = target; for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {try {asyncTask = asyncQueue[asyncQueuePosition]; fn = asyncTask.fn; fn(asyncTask.scope, asyncTask.locals);}catch (e) {$exceptionHandler(e);}lastDirtyWatch = null;}asyncQueue.length = 0; traverseScopesLoop: do {if ((watchers = current.$$watchers)) {watchers.$$digestWatchIndex = watchers.length; while (watchers.$$digestWatchIndex--) {try {watch = watchers[watchers.$$digestWatchIndex]; if (watch) {get = watch.get; if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {dirty = true; lastDirtyWatch = watch; watch.last = watch.eq ? copy(value, null) : value; fn = watch.fn; fn(value, last === initWatchVal ? value : last, current); if (ttl < 5) {logIdx = 4 - ttl; if (!watchLog[logIdx]) watchLog[logIdx] = []; watchLog[logIdx].push({msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last, });}}else if (watch === lastDirtyWatch) {dirty = false; break traverseScopesLoop;}}}catch (e) {$exceptionHandler(e);}}}if (!(next = (current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling))) {while (current !== target && !(next = current.$$nextSibling)) {current = current.$parent;}}}while ((current = next)); if ((dirty || asyncQueue.length) && !ttl--) {clearPhase(); throw $rootScopeMinErr( 'infdig', '{0}$digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog, );}}while (dirty || asyncQueue.length); clearPhase(); while (postDigestQueuePosition < postDigestQueue.length) {try {postDigestQueue[postDigestQueuePosition++]();}catch (e) {$exceptionHandler(e);}}postDigestQueue.length = postDigestQueuePosition = 0; $browser.$$checkUrlChange();}, $destroy: function () {if (this.$$destroyed) return; var parent = this.$parent; this.$broadcast('$destroy'); this.$$destroyed = true; if (this === $rootScope) {$browser.$$applicationDestroyed();}incrementWatchersCount(this, -this.$$watchersCount); for (var eventName in this.$$listenerCount) {decrementListenerCount(this, this.$$listenerCount[eventName], eventName);}if (parent && parent.$$childHead === this) parent.$$childHead = this.$$nextSibling; if (parent && parent.$$childTail === this) parent.$$childTail = this.$$prevSibling; if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling; if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling; this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop; this.$on = this.$watch = this.$watchGroup = function () {return noop;}; this.$$listeners = {}; this.$$nextSibling = null; cleanUpScope(this);}, $eval: function (expr, locals) {return $parse(expr)(this, locals);}, $evalAsync: function (expr, locals) {if (!$rootScope.$$phase && !asyncQueue.length) {$browser.defer(function () {if (asyncQueue.length) {$rootScope.$digest();}});}asyncQueue.push({scope: this, fn: $parse(expr), locals: locals });}, $$postDigest: function (fn) {postDigestQueue.push(fn);}, $apply: function (expr) {try {beginPhase('$apply'); try {return this.$eval(expr);}finally {clearPhase();}}catch (e) {$exceptionHandler(e);}finally {try {$rootScope.$digest();}catch (e) {$exceptionHandler(e); throw e;}}}, $applyAsync: function (expr) {var scope = this; if (expr) {applyAsyncQueue.push($applyAsyncExpression);}expr = $parse(expr); scheduleApplyAsync(); function $applyAsyncExpression() {scope.$eval(expr);}}, $on: function (name, listener) {var namedListeners = this.$$listeners[name]; if (!namedListeners) {this.$$listeners[name] = namedListeners = [];}namedListeners.push(listener); var current = this; do {if (!current.$$listenerCount[name]) {current.$$listenerCount[name] = 0;}current.$$listenerCount[name]++;}while ((current = current.$parent)); var self = this; return function () {var indexOfListener = namedListeners.indexOf(listener); if (indexOfListener !== -1) {namedListeners[indexOfListener] = null; decrementListenerCount(self, 1, name);}};}, $emit: function (name, args) {var empty = [], namedListeners, scope = this, stopPropagation = false, event = {name: name, targetScope: scope, stopPropagation: function () {stopPropagation = true;}, preventDefault: function () {event.defaultPrevented = true;}, defaultPrevented: false, }, listenerArgs = concat([event], arguments, 1), i, length; do {namedListeners = scope.$$listeners[name] || empty; event.currentScope = scope; for (i = 0, length = namedListeners.length; i < length; i++) {if (!namedListeners[i]) {namedListeners.splice(i, 1); i--; length--; continue;}try {namedListeners[i].apply(null, listenerArgs);}catch (e) {$exceptionHandler(e);}}if (stopPropagation) {event.currentScope = null; return event;}scope = scope.$parent;}while (scope); event.currentScope = null; return event;}, $broadcast: function (name, args) {var target = this, current = target, next = target, event = {name: name, targetScope: target, preventDefault: function () {event.defaultPrevented = true;}, defaultPrevented: false, }; if (!target.$$listenerCount[name]) return event; var listenerArgs = concat([event], arguments, 1), listeners, i, length; while ((current = next)) {event.currentScope = current; listeners = current.$$listeners[name] || []; for (i = 0, length = listeners.length; i < length; i++) {if (!listeners[i]) {listeners.splice(i, 1); i--; length--; continue;}try {listeners[i].apply(null, listenerArgs);}catch (e) {$exceptionHandler(e);}}if (!(next = (current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling))) {while (current !== target && !(next = current.$$nextSibling)) {current = current.$parent;}}}event.currentScope = null; return event;}, }; var $rootScope = new Scope(); var asyncQueue = ($rootScope.$$asyncQueue = []); var postDigestQueue = ($rootScope.$$postDigestQueue = []); var applyAsyncQueue = ($rootScope.$$applyAsyncQueue = []); var postDigestQueuePosition = 0; return $rootScope; function beginPhase(phase) {if ($rootScope.$$phase) {throw $rootScopeMinErr('inprog', '{0}already in progress', $rootScope.$$phase);}$rootScope.$$phase = phase;}function clearPhase() {$rootScope.$$phase = null;}function incrementWatchersCount(current, count) {do {current.$$watchersCount += count;}while ((current = current.$parent));}function decrementListenerCount(current, count, name) {do {current.$$listenerCount[name] -= count; if (current.$$listenerCount[name] === 0) {delete current.$$listenerCount[name];}}while ((current = current.$parent));}function initWatchVal() {}function flushApplyAsync() {while (applyAsyncQueue.length) {try {applyAsyncQueue.shift()();}catch (e) {$exceptionHandler(e);}}applyAsyncId = null;}function scheduleApplyAsync() {if (applyAsyncId === null) {applyAsyncId = $browser.defer(function () {$rootScope.$apply(flushApplyAsync);});}}}, ];}function $$SanitizeUriProvider() {var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function (regexp) {if (isDefined(regexp)) {aHrefSanitizationWhitelist = regexp; return this;}return aHrefSanitizationWhitelist;}; this.imgSrcSanitizationWhitelist = function (regexp) {if (isDefined(regexp)) {imgSrcSanitizationWhitelist = regexp; return this;}return imgSrcSanitizationWhitelist;}; this.$get = function () {return function sanitizeUri(uri, isImage) {var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist; var normalizedVal; normalizedVal = urlResolve(uri).href; if (normalizedVal !== '' && !normalizedVal.match(regex)) {return 'unsafe:' + normalizedVal;}return uri;};};}var $sceMinErr = minErr('$sce'); var SCE_CONTEXTS = {HTML: 'html', CSS: 'css', URL: 'url', RESOURCE_URL: 'resourceUrl', JS: 'js', }; var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g; function snakeToCamel(name) {return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);}function adjustMatcher(matcher) {if (matcher === 'self') {return matcher;}else if (isString(matcher)) {if (matcher.indexOf('***') > -1) {throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher. String: {0}', matcher);}matcher = escapeForRegexp(matcher) .replace(/\\\*\\\*/g, '.*') .replace(/\\\*/g, '[^:/.?&;]*'); return new RegExp('^' + matcher + '$');}else if (isRegExp(matcher)) {return new RegExp('^' + matcher.source + '$');}else {throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');}}function adjustMatchers(matchers) {var adjustedMatchers = []; if (isDefined(matchers)) {forEach(matchers, function (matcher) {adjustedMatchers.push(adjustMatcher(matcher));});}return adjustedMatchers;}function $SceDelegateProvider() {this.SCE_CONTEXTS = SCE_CONTEXTS; var resourceUrlWhitelist = ['self'], resourceUrlBlacklist = []; this.resourceUrlWhitelist = function (value) {if (arguments.length) {resourceUrlWhitelist = adjustMatchers(value);}return resourceUrlWhitelist;}; this.resourceUrlBlacklist = function (value) {if (arguments.length) {resourceUrlBlacklist = adjustMatchers(value);}return resourceUrlBlacklist;}; this.$get = [ '$injector', function ($injector) {var htmlSanitizer = function htmlSanitizer(html) {throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');}; if ($injector.has('$sanitize')) {htmlSanitizer = $injector.get('$sanitize');}function matchUrl(matcher, parsedUrl) {if (matcher === 'self') {return urlIsSameOrigin(parsedUrl);}else {return !!matcher.exec(parsedUrl.href);}}function isResourceUrlAllowedByPolicy(url) {var parsedUrl = urlResolve(url.toString()); var i, n, allowed = false; for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {allowed = true; break;}}if (allowed) {for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {allowed = false; break;}}}return allowed;}function generateHolderType(Base) {var holderType = function TrustedValueHolderType(trustedValue) {this.$$unwrapTrustedValue = function () {return trustedValue;};}; if (Base) {holderType.prototype = new Base();}holderType.prototype.valueOf = function sceValueOf() {return this.$$unwrapTrustedValue();}; holderType.prototype.toString = function sceToString() {return this.$$unwrapTrustedValue().toString();}; return holderType;}var trustedValueHolderBase = generateHolderType(), byType = {}; byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase); byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]); function trustAs(type, trustedValue) {var Constructor = byType.hasOwnProperty(type) ? byType[type] : null; if (!Constructor) {throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);}if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {return trustedValue;}if (typeof trustedValue !== 'string') {throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);}return new Constructor(trustedValue);}function valueOf(maybeTrusted) {if (maybeTrusted instanceof trustedValueHolderBase) {return maybeTrusted.$$unwrapTrustedValue();}else {return maybeTrusted;}}function getTrusted(type, maybeTrusted) {if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {return maybeTrusted;}var constructor = byType.hasOwnProperty(type) ? byType[type] : null; if (constructor && maybeTrusted instanceof constructor) {return maybeTrusted.$$unwrapTrustedValue();}if (type === SCE_CONTEXTS.RESOURCE_URL) {if (isResourceUrlAllowedByPolicy(maybeTrusted)) {return maybeTrusted;}else {throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy. URL: {0}', maybeTrusted.toString());}}else if (type === SCE_CONTEXTS.HTML) {return htmlSanitizer(maybeTrusted);}throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');}return {trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf };}, ];}function $SceProvider() {var enabled = true; this.enabled = function (value) {if (arguments.length) {enabled = !!value;}return enabled;}; this.$get = [ '$parse', '$sceDelegate', function ($parse, $sceDelegate) {if (enabled && msie < 8) {throw $sceMinErr( 'iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode. You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document. See http: );}var sce = shallowCopy(SCE_CONTEXTS); sce.isEnabled = function () {return enabled;}; sce.trustAs = $sceDelegate.trustAs; sce.getTrusted = $sceDelegate.getTrusted; sce.valueOf = $sceDelegate.valueOf; if (!enabled) {sce.trustAs = sce.getTrusted = function (type, value) {return value;}; sce.valueOf = identity;}sce.parseAs = function sceParseAs(type, expr) {var parsed = $parse(expr); if (parsed.literal && parsed.constant) {return parsed;}else {return $parse(expr, function (value) {return sce.getTrusted(type, value);});}}; var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs; forEach(SCE_CONTEXTS, function (enumValue, name) {var lName = lowercase(name); sce[snakeToCamel('parse_as_' + lName)] = function (expr) {return parse(enumValue, expr);}; sce[snakeToCamel('get_trusted_' + lName)] = function (value) {return getTrusted(enumValue, value);}; sce[snakeToCamel('trust_as_' + lName)] = function (value) {return trustAs(enumValue, value);};}); return sce;}, ];}function $SnifferProvider() {this.$get = [ '$window', '$document', function ($window, $document) {var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && (($window.chrome.app && $window.chrome.app.runtime) || (!$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id)), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = false, animations = false; if (bodyStyle) {transitions = !!('transition' in bodyStyle || 'webkitTransition' in bodyStyle); animations = !!('animation' in bodyStyle || 'webkitAnimation' in bodyStyle);}return {history: !!(hasHistoryPushState && !(android < 4) && !boxee), hasEvent: function (event) {if (event === 'input' && msie) return false; if (isUndefined(eventSupport[event])) {var divElm = document.createElement('div'); eventSupport[event] = 'on' + event in divElm;}return eventSupport[event];}, csp: csp(), transitions: transitions, animations: animations, android: android, };}, ];}var $templateRequestMinErr = minErr('$compile'); function $TemplateRequestProvider() {var httpOptions; this.httpOptions = function (val) {if (val) {httpOptions = val; return this;}return httpOptions;}; this.$get = [ '$exceptionHandler', '$templateCache', '$http', '$q', '$sce', function ($exceptionHandler, $templateCache, $http, $q, $sce) {function handleRequestFn(tpl, ignoreRequestError) {handleRequestFn.totalPendingRequests++; if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {tpl = $sce.getTrustedResourceUrl(tpl);}var transformResponse = $http.defaults && $http.defaults.transformResponse; if (isArray(transformResponse)) {transformResponse = transformResponse.filter(function (transformer) {return transformer !== defaultHttpResponseTransform;});}else if (transformResponse === defaultHttpResponseTransform) {transformResponse = null;}return $http .get( tpl, extend( {cache: $templateCache, transformResponse: transformResponse, }, httpOptions, ), ) .finally(function () {handleRequestFn.totalPendingRequests--;}) .then(function (response) {$templateCache.put(tpl, response.data); return response.data;}, handleError); function handleError(resp) {if (!ignoreRequestError) {resp = $templateRequestMinErr('tpload', 'Failed to load template: {0}(HTTP status: {1}{2})', tpl, resp.status, resp.statusText); $exceptionHandler(resp);}return $q.reject(resp);}}handleRequestFn.totalPendingRequests = 0; return handleRequestFn;}, ];}function $$TestabilityProvider() {this.$get = [ '$rootScope', '$browser', '$location', function ($rootScope, $browser, $location) {var testability = {}; testability.findBindings = function (element, expression, opt_exactMatch) {var bindings = element.getElementsByClassName('ng-binding'); var matches = []; forEach(bindings, function (binding) {var dataBinding = angular.element(binding).data('$binding'); if (dataBinding) {forEach(dataBinding, function (bindingName) {if (opt_exactMatch) {var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)'); if (matcher.test(bindingName)) {matches.push(binding);}}else {if (bindingName.indexOf(expression) !== -1) {matches.push(binding);}}});}}); return matches;}; testability.findModels = function (element, expression, opt_exactMatch) {var prefixes = ['ng-', 'data-ng-', 'ng\\:']; for (var p = 0; p < prefixes.length; ++p) {var attributeEquals = opt_exactMatch ? '=' : '*='; var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]'; var elements = element.querySelectorAll(selector); if (elements.length) {return elements;}}}; testability.getLocation = function () {return $location.url();}; testability.setLocation = function (url) {if (url !== $location.url()) {$location.url(url); $rootScope.$digest();}}; testability.whenStable = function (callback) {$browser.notifyWhenNoOutstandingRequests(callback);}; return testability;}, ];}function $TimeoutProvider() {this.$get = [ '$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function ($rootScope, $browser, $q, $$q, $exceptionHandler) {var deferreds = {}; function timeout(fn, delay, invokeApply) {if (!isFunction(fn)) {invokeApply = delay; delay = fn; fn = noop;}var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId; timeoutId = $browser.defer(function () {try {deferred.resolve(fn.apply(null, args));}catch (e) {deferred.reject(e); $exceptionHandler(e);}finally {delete deferreds[promise.$$timeoutId];}if (!skipApply) $rootScope.$apply();}, delay); promise.$$timeoutId = timeoutId; deferreds[timeoutId] = deferred; return promise;}timeout.cancel = function (promise) {if (promise && promise.$$timeoutId in deferreds) {markQExceptionHandled(deferreds[promise.$$timeoutId].promise); deferreds[promise.$$timeoutId].reject('canceled'); delete deferreds[promise.$$timeoutId]; return $browser.defer.cancel(promise.$$timeoutId);}return false;}; return timeout;}, ];}var urlParsingNode = window.document.createElement('a'); var originUrl = urlResolve(window.location.href); function urlResolve(url) {var href = url; if (msie) {urlParsingNode.setAttribute('href', href); href = urlParsingNode.href;}urlParsingNode.setAttribute('href', href); return {href: urlParsingNode.href, protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '', host: urlParsingNode.host, search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '', hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '', hostname: urlParsingNode.hostname, port: urlParsingNode.port, pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname, };}function urlIsSameOrigin(requestUrl) {var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl; return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;}function $WindowProvider() {this.$get = valueFn(window);}function $$CookieReader($document) {var rawDocument = $document[0] || {}; var lastCookies = {}; var lastCookieString = ''; function safeGetCookie(rawDocument) {try {return rawDocument.cookie || '';}catch (e) {return '';}}function safeDecodeURIComponent(str) {try {return decodeURIComponent(str);}catch (e) {return str;}}return function () {var cookieArray, cookie, i, index, name; var currentCookieString = safeGetCookie(rawDocument); if (currentCookieString !== lastCookieString) {lastCookieString = currentCookieString; cookieArray = lastCookieString.split('; '); lastCookies = {}; for (i = 0; i < cookieArray.length; i++) {cookie = cookieArray[i]; index = cookie.indexOf('='); if (index > 0) {name = safeDecodeURIComponent(cookie.substring(0, index)); if (isUndefined(lastCookies[name])) {lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));}}}}return lastCookies;};}$$CookieReader.$inject = ['$document']; function $$CookieReaderProvider() {this.$get = $$CookieReader;}$FilterProvider.$inject = ['$provide']; function $FilterProvider($provide) {var suffix = 'Filter'; function register(name, factory) {if (isObject(name)) {var filters = {}; forEach(name, function (filter, key) {filters[key] = register(key, filter);}); return filters;}else {return $provide.factory(name + suffix, factory);}}this.register = register; this.$get = [ '$injector', function ($injector) {return function (name) {return $injector.get(name + suffix);};}, ]; register('currency', currencyFilter); register('date', dateFilter); register('filter', filterFilter); register('json', jsonFilter); register('limitTo', limitToFilter); register('lowercase', lowercaseFilter); register('number', numberFilter); register('orderBy', orderByFilter); register('uppercase', uppercaseFilter);}function filterFilter() {return function (array, expression, comparator, anyPropertyKey) {if (!isArrayLike(array)) {if (array == null) {return array;}else {throw minErr('filter')('notarray', 'Expected array but received: {0}', array);}}anyPropertyKey = anyPropertyKey || '$'; var expressionType = getTypeForFilter(expression); var predicateFn; var matchAgainstAnyProp; switch (expressionType) {case 'function': predicateFn = expression; break; case 'boolean': case 'null': case 'number': case 'string': matchAgainstAnyProp = true; case 'object': predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp); break; default: return array;}return Array.prototype.filter.call(array, predicateFn);};}function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression; var predicateFn; if (comparator === true) {comparator = equals;}else if (!isFunction(comparator)) {comparator = function (actual, expected) {if (isUndefined(actual)) {return false;}if (actual === null || expected === null) {return actual === expected;}if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {return false;}actual = lowercase('' + actual); expected = lowercase('' + expected); return actual.indexOf(expected) !== -1;};}predicateFn = function (item) {if (shouldMatchPrimitives && !isObject(item)) {return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);}return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);}; return predicateFn;}function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {var actualType = getTypeForFilter(actual); var expectedType = getTypeForFilter(expected); if (expectedType === 'string' && expected.charAt(0) === '!') {return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);}else if (isArray(actual)) {return actual.some(function (item) {return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);});}switch (actualType) {case 'object': var key; if (matchAgainstAnyProp) {for (key in actual) {if (key.charAt && key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {return true;}}return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);}else if (expectedType === 'object') {for (key in expected) {var expectedVal = expected[key]; if (isFunction(expectedVal) || isUndefined(expectedVal)) {continue;}var matchAnyProperty = key === anyPropertyKey; var actualVal = matchAnyProperty ? actual : actual[key]; if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {return false;}}return true;}else {return comparator(actual, expected);}case 'function': return false; default: return comparator(actual, expected);}}function getTypeForFilter(val) {return val === null ? 'null' : typeof val;}var MAX_DIGITS = 22; var DECIMAL_SEP = '.'; var ZERO_CHAR = '0'; currencyFilter.$inject = ['$locale']; function currencyFilter($locale) {var formats = $locale.NUMBER_FORMATS; return function (amount, currencySymbol, fractionSize) {if (isUndefined(currencySymbol)) {currencySymbol = formats.CURRENCY_SYM;}if (isUndefined(fractionSize)) {fractionSize = formats.PATTERNS[1].maxFrac;}return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);};}numberFilter.$inject = ['$locale']; function numberFilter($locale) {var formats = $locale.NUMBER_FORMATS; return function (number, fractionSize) {return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);};}function parse(numStr) {var exponent = 0, digits, numberOfIntegerDigits; var i, j, zeros; if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {numStr = numStr.replace(DECIMAL_SEP, '');}if ((i = numStr.search(/e/i)) > 0) {if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i; numberOfIntegerDigits += +numStr.slice(i + 1); numStr = numStr.substring(0, i);}else if (numberOfIntegerDigits < 0) {numberOfIntegerDigits = numStr.length;}for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}if (i === (zeros = numStr.length)) {digits = [0]; numberOfIntegerDigits = 1;}else {zeros--; while (numStr.charAt(zeros) === ZERO_CHAR) zeros--; numberOfIntegerDigits -= i; digits = []; for (j = 0; i <= zeros; i++, j++) {digits[j] = +numStr.charAt(i);}}if (numberOfIntegerDigits > MAX_DIGITS) {digits = digits.splice(0, MAX_DIGITS - 1); exponent = numberOfIntegerDigits - 1; numberOfIntegerDigits = 1;}return {d: digits, e: exponent, i: numberOfIntegerDigits };}function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {var digits = parsedNumber.d; var fractionLen = digits.length - parsedNumber.i; fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize; var roundAt = fractionSize + parsedNumber.i; var digit = digits[roundAt]; if (roundAt > 0) {digits.splice(Math.max(parsedNumber.i, roundAt)); for (var j = roundAt; j < digits.length; j++) {digits[j] = 0;}}else {fractionLen = Math.max(0, fractionLen); parsedNumber.i = 1; digits.length = Math.max(1, (roundAt = fractionSize + 1)); digits[0] = 0; for (var i = 1; i < roundAt; i++) digits[i] = 0;}if (digit >= 5) {if (roundAt - 1 < 0) {for (var k = 0; k > roundAt; k--) {digits.unshift(0); parsedNumber.i++;}digits.unshift(1); parsedNumber.i++;}else {digits[roundAt - 1]++;}}for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0); var carry = digits.reduceRight(function (carry, d, i, digits) {d = d + carry; digits[i] = d % 10; return Math.floor(d / 10);}, 0); if (carry) {digits.unshift(carry); parsedNumber.i++;}}function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {if (!(isString(number) || isNumber(number)) || isNaN(number)) return ''; var isInfinity = !isFinite(number); var isZero = false; var numStr = Math.abs(number) + '', formattedText = '', parsedNumber; if (isInfinity) {formattedText = '\u221e';}else {parsedNumber = parse(numStr); roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac); var digits = parsedNumber.d; var integerLen = parsedNumber.i; var exponent = parsedNumber.e; var decimals = []; isZero = digits.reduce(function (isZero, d) {return isZero && !d;}, true); while (integerLen < 0) {digits.unshift(0); integerLen++;}if (integerLen > 0) {decimals = digits.splice(integerLen, digits.length);}else {decimals = digits; digits = [0];}var groups = []; if (digits.length >= pattern.lgSize) {groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));}while (digits.length > pattern.gSize) {groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));}if (digits.length) {groups.unshift(digits.join(''));}formattedText = groups.join(groupSep); if (decimals.length) {formattedText += decimalSep + decimals.join('');}if (exponent) {formattedText += 'e+' + exponent;}}if (number < 0 && !isZero) {return pattern.negPre + formattedText + pattern.negSuf;}else {return pattern.posPre + formattedText + pattern.posSuf;}}function padNumber(num, digits, trim, negWrap) {var neg = ''; if (num < 0 || (negWrap && num <= 0)) {if (negWrap) {num = -num + 1;}else {num = -num; neg = '-';}}num = '' + num; while (num.length < digits) num = ZERO_CHAR + num; if (trim) {num = num.substr(num.length - digits);}return neg + num;}function dateGetter(name, size, offset, trim, negWrap) {offset = offset || 0; return function (date) {var value = date['get' + name](); if (offset > 0 || value > -offset) {value += offset;}if (value === 0 && offset === -12) value = 12; return padNumber(value, size, trim, negWrap);};}function dateStrGetter(name, shortForm, standAlone) {return function (date, formats) {var value = date['get' + name](); var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : ''); var get = uppercase(propPrefix + name); return formats[get][value];};}function timeZoneGetter(date, formats, offset) {var zone = -1 * offset; var paddedZone = zone >= 0 ? '+' : ''; paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2); return paddedZone;}function getFirstThursdayOfYear(year) {var dayOfWeekOnFirst = new Date(year, 0, 1).getDay(); return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);}function getThursdayThisWeek(datetime) {return new Date( datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()), );}function weekGetter(size) {return function (date) {var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date); var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6.048e8); return padNumber(result, size);};}function ampmGetter(date, formats) {return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];}function eraGetter(date, formats) {return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];}function longEraGetter(date, formats) {return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];}var DATE_FORMATS = {yyyy: dateGetter('FullYear', 4, 0, false, true), yy: dateGetter('FullYear', 2, 0, true, true), y: dateGetter('FullYear', 1, 0, false, true), MMMM: dateStrGetter('Month'), MMM: dateStrGetter('Month', true), MM: dateGetter('Month', 2, 1), M: dateGetter('Month', 1, 1), LLLL: dateStrGetter('Month', false, true), dd: dateGetter('Date', 2), d: dateGetter('Date', 1), HH: dateGetter('Hours', 2), H: dateGetter('Hours', 1), hh: dateGetter('Hours', 2, -12), h: dateGetter('Hours', 1, -12), mm: dateGetter('Minutes', 2), m: dateGetter('Minutes', 1), ss: dateGetter('Seconds', 2), s: dateGetter('Seconds', 1), sss: dateGetter('Milliseconds', 3), EEEE: dateStrGetter('Day'), EEE: dateStrGetter('Day', true), a: ampmGetter, Z: timeZoneGetter, ww: weekGetter(2), w: weekGetter(1), G: eraGetter, GG: eraGetter, GGG: eraGetter, GGGG: longEraGetter, }; var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/; dateFilter.$inject = ['$locale']; function dateFilter($locale) {var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; function jsonStringToDate(string) {var match; if ((match = string.match(R_ISO8601_STR))) {var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours; if (match[9]) {tzHour = toInt(match[9] + match[10]); tzMin = toInt(match[9] + match[11]);}dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3])); var h = toInt(match[4] || 0) - tzHour; var m = toInt(match[5] || 0) - tzMin; var s = toInt(match[6] || 0); var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000); timeSetter.call(date, h, m, s, ms); return date;}return string;}return function (date, format, timezone) {var text = '', parts = [], fn, match; format = format || 'mediumDate'; format = $locale.DATETIME_FORMATS[format] || format; if (isString(date)) {date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);}if (isNumber(date)) {date = new Date(date);}if (!isDate(date) || !isFinite(date.getTime())) {return date;}while (format) {match = DATE_FORMATS_SPLIT.exec(format); if (match) {parts = concat(parts, match, 1); format = parts.pop();}else {parts.push(format); format = null;}}var dateTimezoneOffset = date.getTimezoneOffset(); if (timezone) {dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset); date = convertTimezoneToLocal(date, timezone, true);}forEach(parts, function (value) {fn = DATE_FORMATS[value]; text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");}); return text;};}function jsonFilter() {return function (object, spacing) {if (isUndefined(spacing)) {spacing = 2;}return toJson(object, spacing);};}var lowercaseFilter = valueFn(lowercase); var uppercaseFilter = valueFn(uppercase); function limitToFilter() {return function (input, limit, begin) {if (Math.abs(Number(limit)) === Infinity) {limit = Number(limit);}else {limit = toInt(limit);}if (isNumberNaN(limit)) return input; if (isNumber(input)) input = input.toString(); if (!isArrayLike(input)) return input; begin = !begin || isNaN(begin) ? 0 : toInt(begin); begin = begin < 0 ? Math.max(0, input.length + begin) : begin; if (limit >= 0) {return sliceFn(input, begin, begin + limit);}else {if (begin === 0) {return sliceFn(input, limit, input.length);}else {return sliceFn(input, Math.max(0, begin + limit), begin);}}};}function sliceFn(input, begin, end) {if (isString(input)) return input.slice(begin, end); return slice.call(input, begin, end);}orderByFilter.$inject = ['$parse']; function orderByFilter($parse) {return function (array, sortPredicate, reverseOrder, compareFn) {if (array == null) return array; if (!isArrayLike(array)) {throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);}if (!isArray(sortPredicate)) {sortPredicate = [sortPredicate];}if (sortPredicate.length === 0) {sortPredicate = ['+'];}var predicates = processPredicates(sortPredicate); var descending = reverseOrder ? -1 : 1; var compare = isFunction(compareFn) ? compareFn : defaultCompare; var compareValues = Array.prototype.map.call(array, getComparisonObject); compareValues.sort(doComparison); array = compareValues.map(function (item) {return item.value;}); return array; function getComparisonObject(value, index) {return {value: value, tieBreaker: {value: index, type: 'number', index: index }, predicateValues: predicates.map(function (predicate) {return getPredicateValue(predicate.get(value), index);}), };}function doComparison(v1, v2) {for (var i = 0, ii = predicates.length; i < ii; i++) {var result = compare(v1.predicateValues[i], v2.predicateValues[i]); if (result) {return result * predicates[i].descending * descending;}}return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;}}; function processPredicates(sortPredicates) {return sortPredicates.map(function (predicate) {var descending = 1, get = identity; if (isFunction(predicate)) {get = predicate;}else if (isString(predicate)) {if (predicate.charAt(0) === '+' || predicate.charAt(0) === '-') {descending = predicate.charAt(0) === '-' ? -1 : 1; predicate = predicate.substring(1);}if (predicate !== '') {get = $parse(predicate); if (get.constant) {var key = get(); get = function (value) {return value[key];};}}}return {get: get, descending: descending };});}function isPrimitive(value) {switch (typeof value) {case 'number': case 'boolean': case 'string': return true; default: return false;}}function objectValue(value) {if (isFunction(value.valueOf)) {value = value.valueOf(); if (isPrimitive(value)) return value;}if (hasCustomToString(value)) {value = value.toString(); if (isPrimitive(value)) return value;}return value;}function getPredicateValue(value, index) {var type = typeof value; if (value === null) {type = 'string'; value = 'null';}else if (type === 'object') {value = objectValue(value);}return {value: value, type: type, index: index };}function defaultCompare(v1, v2) {var result = 0; var type1 = v1.type; var type2 = v2.type; if (type1 === type2) {var value1 = v1.value; var value2 = v2.value; if (type1 === 'string') {value1 = value1.toLowerCase(); value2 = value2.toLowerCase();}else if (type1 === 'object') {if (isObject(value1)) value1 = v1.index; if (isObject(value2)) value2 = v2.index;}if (value1 !== value2) {result = value1 < value2 ? -1 : 1;}}else {result = type1 < type2 ? -1 : 1;}return result;}}function ngDirective(directive) {if (isFunction(directive)) {directive = {link: directive, };}directive.restrict = directive.restrict || 'AC'; return valueFn(directive);}var htmlAnchorDirective = valueFn({restrict: 'E', compile: function (element, attr) {if (!attr.href && !attr.xlinkHref) {return function (scope, element) {if (element[0].nodeName.toLowerCase() !== 'a') return; var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href'; element.on('click', function (event) {if (!element.attr(href)) {event.preventDefault();}});};}}, }); var ngAttributeAliasDirectives = {}; forEach(BOOLEAN_ATTR, function (propName, attrName) {if (propName === 'multiple') return; function defaultLinkFn(scope, element, attr) {scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {attr.$set(attrName, !!value);});}var normalized = directiveNormalize('ng-' + attrName); var linkFn = defaultLinkFn; if (propName === 'checked') {linkFn = function (scope, element, attr) {if (attr.ngModel !== attr[normalized]) {defaultLinkFn(scope, element, attr);}};}ngAttributeAliasDirectives[normalized] = function () {return {restrict: 'A', priority: 100, link: linkFn, };};}); forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {ngAttributeAliasDirectives[ngAttr] = function () {return {priority: 100, link: function (scope, element, attr) {if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {var match = attr.ngPattern.match(REGEX_STRING_REGEXP); if (match) {attr.$set('ngPattern', new RegExp(match[1], match[2])); return;}}scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {attr.$set(ngAttr, value);});}, };};}); forEach(['src', 'srcset', 'href'], function (attrName) {var normalized = directiveNormalize('ng-' + attrName); ngAttributeAliasDirectives[normalized] = function () {return {priority: 99, link: function (scope, element, attr) {var propName = attrName, name = attrName; if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {name = 'xlinkHref'; attr.$attr[name] = 'xlink:href'; propName = null;}attr.$observe(normalized, function (value) {if (!value) {if (attrName === 'href') {attr.$set(name, null);}return;}attr.$set(name, value); if (msie && propName) element.prop(propName, attr[name]);});}, };};}); var nullFormCtrl = {$addControl: noop, $$renameControl: nullFormRenameControl, $removeControl: noop, $setValidity: noop, $setDirty: noop, $setPristine: noop, $setSubmitted: noop, }, PENDING_CLASS = 'ng-pending', SUBMITTED_CLASS = 'ng-submitted'; function nullFormRenameControl(control, name) {control.$name = name;}FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate']; function FormController($element, $attrs, $scope, $animate, $interpolate) {this.$$controls = []; this.$error = {}; this.$$success = {}; this.$pending = undefined; this.$name = $interpolate($attrs.name || $attrs.ngForm || '')($scope); this.$dirty = false; this.$pristine = true; this.$valid = true; this.$invalid = false; this.$submitted = false; this.$$parentForm = nullFormCtrl; this.$$element = $element; this.$$animate = $animate; setupValidity(this);}FormController.prototype = {$rollbackViewValue: function () {forEach(this.$$controls, function (control) {control.$rollbackViewValue();});}, $commitViewValue: function () {forEach(this.$$controls, function (control) {control.$commitViewValue();});}, $addControl: function (control) {assertNotHasOwnProperty(control.$name, 'input'); this.$$controls.push(control); if (control.$name) {this[control.$name] = control;}control.$$parentForm = this;}, $$renameControl: function (control, newName) {var oldName = control.$name; if (this[oldName] === control) {delete this[oldName];}this[newName] = control; control.$name = newName;}, $removeControl: function (control) {if (control.$name && this[control.$name] === control) {delete this[control.$name];}forEach( this.$pending, function (value, name) {this.$setValidity(name, null, control);}, this, ); forEach( this.$error, function (value, name) {this.$setValidity(name, null, control);}, this, ); forEach( this.$$success, function (value, name) {this.$setValidity(name, null, control);}, this, ); arrayRemove(this.$$controls, control); control.$$parentForm = nullFormCtrl;}, $setDirty: function () {this.$$animate.removeClass(this.$$element, PRISTINE_CLASS); this.$$animate.addClass(this.$$element, DIRTY_CLASS); this.$dirty = true; this.$pristine = false; this.$$parentForm.$setDirty();}, $setPristine: function () {this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS); this.$dirty = false; this.$pristine = true; this.$submitted = false; forEach(this.$$controls, function (control) {control.$setPristine();});}, $setUntouched: function () {forEach(this.$$controls, function (control) {control.$setUntouched();});}, $setSubmitted: function () {this.$$animate.addClass(this.$$element, SUBMITTED_CLASS); this.$submitted = true; this.$$parentForm.$setSubmitted();}, }; addSetValidityMethod({clazz: FormController, set: function (object, property, controller) {var list = object[property]; if (!list) {object[property] = [controller];}else {var index = list.indexOf(controller); if (index === -1) {list.push(controller);}}}, unset: function (object, property, controller) {var list = object[property]; if (!list) {return;}arrayRemove(list, controller); if (list.length === 0) {delete object[property];}}, }); var formDirectiveFactory = function (isNgForm) {return [ '$timeout', '$parse', function ($timeout, $parse) {var formDirective = {name: 'form', restrict: isNgForm ? 'EAC' : 'E', require: ['form', '^^?form'], controller: FormController, compile: function ngFormCompile(formElement, attr) {formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS); var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false; return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {var controller = ctrls[0]; if (!('action' in attr)) {var handleFormSubmission = function (event) {scope.$apply(function () {controller.$commitViewValue(); controller.$setSubmitted();}); event.preventDefault();}; formElement[0].addEventListener('submit', handleFormSubmission); formElement.on('$destroy', function () {$timeout( function () {formElement[0].removeEventListener('submit', handleFormSubmission);}, 0, false, );});}var parentFormCtrl = ctrls[1] || controller.$$parentForm; parentFormCtrl.$addControl(controller); var setter = nameAttr ? getSetter(controller.$name) : noop; if (nameAttr) {setter(scope, controller); attr.$observe(nameAttr, function (newValue) {if (controller.$name === newValue) return; setter(scope, undefined); controller.$$parentForm.$$renameControl(controller, newValue); setter = getSetter(controller.$name); setter(scope, controller);});}formElement.on('$destroy', function () {controller.$$parentForm.$removeControl(controller); setter(scope, undefined); extend(controller, nullFormCtrl);});}, };}, }; return formDirective; function getSetter(expression) {if (expression === '') {return $parse('this[""]').assign;}return $parse(expression).assign || noop;}}, ];}; var formDirective = formDirectiveFactory(); var ngFormDirective = formDirectiveFactory(true); function setupValidity(instance) {instance.$$classCache = {}; instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));}function addSetValidityMethod(context) {var clazz = context.clazz, set = context.set, unset = context.unset; clazz.prototype.$setValidity = function (validationErrorKey, state, controller) {if (isUndefined(state)) {createAndSet(this, '$pending', validationErrorKey, controller);}else {unsetAndCleanup(this, '$pending', validationErrorKey, controller);}if (!isBoolean(state)) {unset(this.$error, validationErrorKey, controller); unset(this.$$success, validationErrorKey, controller);}else {if (state) {unset(this.$error, validationErrorKey, controller); set(this.$$success, validationErrorKey, controller);}else {set(this.$error, validationErrorKey, controller); unset(this.$$success, validationErrorKey, controller);}}if (this.$pending) {cachedToggleClass(this, PENDING_CLASS, true); this.$valid = this.$invalid = undefined; toggleValidationCss(this, '', null);}else {cachedToggleClass(this, PENDING_CLASS, false); this.$valid = isObjectEmpty(this.$error); this.$invalid = !this.$valid; toggleValidationCss(this, '', this.$valid);}var combinedState; if (this.$pending && this.$pending[validationErrorKey]) {combinedState = undefined;}else if (this.$error[validationErrorKey]) {combinedState = false;}else if (this.$$success[validationErrorKey]) {combinedState = true;}else {combinedState = null;}toggleValidationCss(this, validationErrorKey, combinedState); this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);}; function createAndSet(ctrl, name, value, controller) {if (!ctrl[name]) {ctrl[name] = {};}set(ctrl[name], value, controller);}function unsetAndCleanup(ctrl, name, value, controller) {if (ctrl[name]) {unset(ctrl[name], value, controller);}if (isObjectEmpty(ctrl[name])) {ctrl[name] = undefined;}}function cachedToggleClass(ctrl, className, switchValue) {if (switchValue && !ctrl.$$classCache[className]) {ctrl.$$animate.addClass(ctrl.$$element, className); ctrl.$$classCache[className] = true;}else if (!switchValue && ctrl.$$classCache[className]) {ctrl.$$animate.removeClass(ctrl.$$element, className); ctrl.$$classCache[className] = false;}}function toggleValidationCss(ctrl, validationErrorKey, isValid) {validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : ''; cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true); cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);}}function isObjectEmpty(obj) {if (obj) {for (var prop in obj) {if (obj.hasOwnProperty(prop)) {return false;}}}return true;}var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/; var URL_REGEXP = /^[a-z][a-z\d.+-]*:\ text: textInputType, date: createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'), 'datetime-local': createDateInputType( 'datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss', ), time: createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'), week: createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'), month: createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'), number: numberInputType, url: urlInputType, email: emailInputType, radio: radioInputType, range: rangeInputType, checkbox: checkboxInputType, hidden: noop, button: noop, submit: noop, reset: noop, file: noop, }; function stringBasedInputType(ctrl) {ctrl.$formatters.push(function (value) {return ctrl.$isEmpty(value) ? value : value.toString();});}function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {baseInputType(scope, element, attr, ctrl, $sniffer, $browser); stringBasedInputType(ctrl);}function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {var type = lowercase(element[0].type); if (!$sniffer.android) {var composing = false; element.on('compositionstart', function () {composing = true;}); element.on('compositionend', function () {composing = false; listener();});}var timeout; var listener = function (ev) {if (timeout) {$browser.defer.cancel(timeout); timeout = null;}if (composing) return; var value = element.val(), event = ev && ev.type; if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {value = trim(value);}if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {ctrl.$setViewValue(value, event);}}; if ($sniffer.hasEvent('input')) {element.on('input', listener);}else {var deferListener = function (ev, input, origValue) {if (!timeout) {timeout = $browser.defer(function () {timeout = null; if (!input || input.value !== origValue) {listener(ev);}});}}; element.on( 'keydown', function (event) {var key = event.keyCode; if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return; deferListener(event, this, this.value);}, ); if ($sniffer.hasEvent('paste')) {element.on('paste cut', deferListener);}}element.on('change', listener); if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {element.on( PARTIAL_VALIDATION_EVENTS, function (ev) {if (!timeout) {var validity = this[VALIDITY_STATE_PROPERTY]; var origBadInput = validity.badInput; var origTypeMismatch = validity.typeMismatch; timeout = $browser.defer(function () {timeout = null; if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {listener(ev);}});}}, );}ctrl.$render = function () {var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue; if (element.val() !== value) {element.val(value);}};}function weekParser(isoWeek, existingDate) {if (isDate(isoWeek)) {return isoWeek;}if (isString(isoWeek)) {WEEK_REGEXP.lastIndex = 0; var parts = WEEK_REGEXP.exec(isoWeek); if (parts) {var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7; if (existingDate) {hours = existingDate.getHours(); minutes = existingDate.getMinutes(); seconds = existingDate.getSeconds(); milliseconds = existingDate.getMilliseconds();}return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);}}return NaN;}function createDateParser(regexp, mapping) {return function (iso, date) {var parts, map; if (isDate(iso)) {return iso;}if (isString(iso)) {if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {iso = iso.substring(1, iso.length - 1);}if (ISO_DATE_REGEXP.test(iso)) {return new Date(iso);}regexp.lastIndex = 0; parts = regexp.exec(iso); if (parts) {parts.shift(); if (date) {map = {yyyy: date.getFullYear(), MM: date.getMonth() + 1, dd: date.getDate(), HH: date.getHours(), mm: date.getMinutes(), ss: date.getSeconds(), sss: date.getMilliseconds() / 1000, };}else {map = {yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };}forEach(parts, function (part, index) {if (index < mapping.length) {map[mapping[index]] = +part;}}); return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);}}return NaN;};}function createDateInputType(type, regexp, parseDate, format) {return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {badInputChecker(scope, element, attr, ctrl); baseInputType(scope, element, attr, ctrl, $sniffer, $browser); var timezone = ctrl && ctrl.$options.getOption('timezone'); var previousDate; ctrl.$$parserName = type; ctrl.$parsers.push(function (value) {if (ctrl.$isEmpty(value)) return null; if (regexp.test(value)) {var parsedDate = parseDate(value, previousDate); if (timezone) {parsedDate = convertTimezoneToLocal(parsedDate, timezone);}return parsedDate;}return undefined;}); ctrl.$formatters.push(function (value) {if (value && !isDate(value)) {throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);}if (isValidDate(value)) {previousDate = value; if (previousDate && timezone) {previousDate = convertTimezoneToLocal(previousDate, timezone, true);}return $filter('date')(value, format, timezone);}else {previousDate = null; return '';}}); if (isDefined(attr.min) || attr.ngMin) {var minVal; ctrl.$validators.min = function (value) {return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;}; attr.$observe('min', function (val) {minVal = parseObservedDateValue(val); ctrl.$validate();});}if (isDefined(attr.max) || attr.ngMax) {var maxVal; ctrl.$validators.max = function (value) {return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;}; attr.$observe('max', function (val) {maxVal = parseObservedDateValue(val); ctrl.$validate();});}function isValidDate(value) {return value && !(value.getTime && value.getTime() !== value.getTime());}function parseObservedDateValue(val) {return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;}};}function badInputChecker(scope, element, attr, ctrl) {var node = element[0]; var nativeValidation = (ctrl.$$hasNativeValidators = isObject(node.validity)); if (nativeValidation) {ctrl.$parsers.push(function (value) {var validity = element.prop(VALIDITY_STATE_PROPERTY) || {}; return validity.badInput || validity.typeMismatch ? undefined : value;});}}function numberFormatterParser(ctrl) {ctrl.$$parserName = 'number'; ctrl.$parsers.push(function (value) {if (ctrl.$isEmpty(value)) return null; if (NUMBER_REGEXP.test(value)) return parseFloat(value); return undefined;}); ctrl.$formatters.push(function (value) {if (!ctrl.$isEmpty(value)) {if (!isNumber(value)) {throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);}value = value.toString();}return value;});}function parseNumberAttrVal(val) {if (isDefined(val) && !isNumber(val)) {val = parseFloat(val);}return !isNumberNaN(val) ? val : undefined;}function isNumberInteger(num) {return (num | 0) === num;}function countDecimals(num) {var numString = num.toString(); var decimalSymbolIndex = numString.indexOf('.'); if (decimalSymbolIndex === -1) {if (-1 < num && num < 1) {var match = /e-(\d+)$/.exec(numString); if (match) {return Number(match[1]);}}return 0;}return numString.length - decimalSymbolIndex - 1;}function isValidForStep(viewValue, stepBase, step) {var value = Number(viewValue); var isNonIntegerValue = !isNumberInteger(value); var isNonIntegerStepBase = !isNumberInteger(stepBase); var isNonIntegerStep = !isNumberInteger(step); if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0; var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0; var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0; var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals); var multiplier = Math.pow(10, decimalCount); value = value * multiplier; stepBase = stepBase * multiplier; step = step * multiplier; if (isNonIntegerValue) value = Math.round(value); if (isNonIntegerStepBase) stepBase = Math.round(stepBase); if (isNonIntegerStep) step = Math.round(step);}return (value - stepBase) % step === 0;}function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {badInputChecker(scope, element, attr, ctrl); numberFormatterParser(ctrl); baseInputType(scope, element, attr, ctrl, $sniffer, $browser); var minVal; var maxVal; if (isDefined(attr.min) || attr.ngMin) {ctrl.$validators.min = function (value) {return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;}; attr.$observe('min', function (val) {minVal = parseNumberAttrVal(val); ctrl.$validate();});}if (isDefined(attr.max) || attr.ngMax) {ctrl.$validators.max = function (value) {return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;}; attr.$observe('max', function (val) {maxVal = parseNumberAttrVal(val); ctrl.$validate();});}if (isDefined(attr.step) || attr.ngStep) {var stepVal; ctrl.$validators.step = function (modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);}; attr.$observe('step', function (val) {stepVal = parseNumberAttrVal(val); ctrl.$validate();});}}function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {badInputChecker(scope, element, attr, ctrl); numberFormatterParser(ctrl); baseInputType(scope, element, attr, ctrl, $sniffer, $browser); var supportsRange = ctrl.$$hasNativeValidators && element[0].type === 'range', minVal = supportsRange ? 0 : undefined, maxVal = supportsRange ? 100 : undefined, stepVal = supportsRange ? 1 : undefined, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step); var originalRender = ctrl.$render; ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {originalRender(); ctrl.$setViewValue(element.val());}: originalRender; if (hasMinAttr) {ctrl.$validators.min = supportsRange ? function noopMinValidator() {return true;}: function minValidator(modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;}; setInitialValueAndObserver('min', minChange);}if (hasMaxAttr) {ctrl.$validators.max = supportsRange ? function noopMaxValidator() {return true;}: function maxValidator(modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;}; setInitialValueAndObserver('max', maxChange);}if (hasStepAttr) {ctrl.$validators.step = supportsRange ? function nativeStepValidator() {return !validity.stepMismatch;}: function stepValidator(modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);}; setInitialValueAndObserver('step', stepChange);}function setInitialValueAndObserver(htmlAttrName, changeFn) {element.attr(htmlAttrName, attr[htmlAttrName]); attr.$observe(htmlAttrName, changeFn);}function minChange(val) {minVal = parseNumberAttrVal(val); if (isNumberNaN(ctrl.$modelValue)) {return;}if (supportsRange) {var elVal = element.val(); if (minVal > elVal) {elVal = minVal; element.val(elVal);}ctrl.$setViewValue(elVal);}else {ctrl.$validate();}}function maxChange(val) {maxVal = parseNumberAttrVal(val); if (isNumberNaN(ctrl.$modelValue)) {return;}if (supportsRange) {var elVal = element.val(); if (maxVal < elVal) {element.val(maxVal); elVal = maxVal < minVal ? minVal : maxVal;}ctrl.$setViewValue(elVal);}else {ctrl.$validate();}}function stepChange(val) {stepVal = parseNumberAttrVal(val); if (isNumberNaN(ctrl.$modelValue)) {return;}if (supportsRange && ctrl.$viewValue !== element.val()) {ctrl.$setViewValue(element.val());}else {ctrl.$validate();}}}function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {baseInputType(scope, element, attr, ctrl, $sniffer, $browser); stringBasedInputType(ctrl); ctrl.$$parserName = 'url'; ctrl.$validators.url = function (modelValue, viewValue) {var value = modelValue || viewValue; return ctrl.$isEmpty(value) || URL_REGEXP.test(value);};}function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {baseInputType(scope, element, attr, ctrl, $sniffer, $browser); stringBasedInputType(ctrl); ctrl.$$parserName = 'email'; ctrl.$validators.email = function (modelValue, viewValue) {var value = modelValue || viewValue; return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);};}function radioInputType(scope, element, attr, ctrl) {var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== 'false'; if (isUndefined(attr.name)) {element.attr('name', nextUid());}var listener = function (ev) {var value; if (element[0].checked) {value = attr.value; if (doTrim) {value = trim(value);}ctrl.$setViewValue(value, ev && ev.type);}}; element.on('click', listener); ctrl.$render = function () {var value = attr.value; if (doTrim) {value = trim(value);}element[0].checked = value === ctrl.$viewValue;}; attr.$observe('value', ctrl.$render);}function parseConstantExpr($parse, context, name, expression, fallback) {var parseFn; if (isDefined(expression)) {parseFn = $parse(expression); if (!parseFn.constant) {throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);}return parseFn(context);}return fallback;}function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true); var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false); var listener = function (ev) {ctrl.$setViewValue(element[0].checked, ev && ev.type);}; element.on('click', listener); ctrl.$render = function () {element[0].checked = ctrl.$viewValue;}; ctrl.$isEmpty = function (value) {return value === false;}; ctrl.$formatters.push(function (value) {return equals(value, trueValue);}); ctrl.$parsers.push(function (value) {return value ? trueValue : falseValue;});}var inputDirective = [ '$browser', '$sniffer', '$filter', '$parse', function ($browser, $sniffer, $filter, $parse) {return {restrict: 'E', require: ['?ngModel'], link: {pre: function (scope, element, attr, ctrls) {if (ctrls[0]) {(inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);}}, }, };}, ]; var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/; var ngValueDirective = function () {function updateElementValue(element, attr, value) {var propValue = isDefined(value) ? value : msie === 9 ? '' : null; element.prop('value', propValue); attr.$set('value', value);}return {restrict: 'A', priority: 100, compile: function (tpl, tplAttr) {if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {return function ngValueConstantLink(scope, elm, attr) {var value = scope.$eval(attr.ngValue); updateElementValue(elm, attr, value);};}else {return function ngValueLink(scope, elm, attr) {scope.$watch(attr.ngValue, function valueWatchAction(value) {updateElementValue(elm, attr, value);});};}}, };}; var ngBindDirective = [ '$compile', function ($compile) {return {restrict: 'AC', compile: function ngBindCompile(templateElement) {$compile.$$addBindingClass(templateElement); return function ngBindLink(scope, element, attr) {$compile.$$addBindingInfo(element, attr.ngBind); element = element[0]; scope.$watch(attr.ngBind, function ngBindWatchAction(value) {element.textContent = stringify(value);});};}, };}, ]; var ngBindTemplateDirective = [ '$interpolate', '$compile', function ($interpolate, $compile) {return {compile: function ngBindTemplateCompile(templateElement) {$compile.$$addBindingClass(templateElement); return function ngBindTemplateLink(scope, element, attr) {var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate)); $compile.$$addBindingInfo(element, interpolateFn.expressions); element = element[0]; attr.$observe('ngBindTemplate', function (value) {element.textContent = isUndefined(value) ? '' : value;});};}, };}, ]; var ngBindHtmlDirective = [ '$sce', '$parse', '$compile', function ($sce, $parse, $compile) {return {restrict: 'A', compile: function ngBindHtmlCompile(tElement, tAttrs) {var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml); var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {return $sce.valueOf(val);}); $compile.$$addBindingClass(tElement); return function ngBindHtmlLink(scope, element, attr) {$compile.$$addBindingInfo(element, attr.ngBindHtml); scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {var value = ngBindHtmlGetter(scope); element.html($sce.getTrustedHtml(value) || '');});};}, };}, ]; var ngChangeDirective = valueFn({restrict: 'A', require: 'ngModel', link: function (scope, element, attr, ctrl) {ctrl.$viewChangeListeners.push(function () {scope.$eval(attr.ngChange);});}, }); function classDirective(name, selector) {name = 'ngClass' + name; var indexWatchExpression; return [ '$parse', function ($parse) {return {restrict: 'AC', link: function (scope, element, attr) {var expression = attr[name].trim(); var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':'; var watchInterceptor = isOneTime ? toFlatValue : toClassString; var watchExpression = $parse(expression, watchInterceptor); var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction; var classCounts = element.data('$classCounts'); var oldModulo = true; var oldClassString; if (!classCounts) {classCounts = createMap(); element.data('$classCounts', classCounts);}if (name !== 'ngClass') {if (!indexWatchExpression) {indexWatchExpression = $parse('$index', function moduloTwo($index) {return $index & 1;});}scope.$watch(indexWatchExpression, ngClassIndexWatchAction);}scope.$watch(watchExpression, watchAction, isOneTime); function addClasses(classString) {classString = digestClassCounts(split(classString), 1); attr.$addClass(classString);}function removeClasses(classString) {classString = digestClassCounts(split(classString), -1); attr.$removeClass(classString);}function updateClasses(oldClassString, newClassString) {var oldClassArray = split(oldClassString); var newClassArray = split(newClassString); var toRemoveArray = arrayDifference(oldClassArray, newClassArray); var toAddArray = arrayDifference(newClassArray, oldClassArray); var toRemoveString = digestClassCounts(toRemoveArray, -1); var toAddString = digestClassCounts(toAddArray, 1); attr.$addClass(toAddString); attr.$removeClass(toRemoveString);}function digestClassCounts(classArray, count) {var classesToUpdate = []; forEach(classArray, function (className) {if (count > 0 || classCounts[className]) {classCounts[className] = (classCounts[className] || 0) + count; if (classCounts[className] === +(count > 0)) {classesToUpdate.push(className);}}}); return classesToUpdate.join(' ');}function ngClassIndexWatchAction(newModulo) {if (newModulo === selector) {addClasses(oldClassString);}else {removeClasses(oldClassString);}oldModulo = newModulo;}function ngClassOneTimeWatchAction(newClassValue) {var newClassString = toClassString(newClassValue); if (newClassString !== oldClassString) {ngClassWatchAction(newClassString);}}function ngClassWatchAction(newClassString) {if (oldModulo === selector) {updateClasses(oldClassString, newClassString);}oldClassString = newClassString;}}, };}, ]; function arrayDifference(tokens1, tokens2) {if (!tokens1 || !tokens1.length) return []; if (!tokens2 || !tokens2.length) return tokens1; var values = []; outer: for (var i = 0; i < tokens1.length; i++) {var token = tokens1[i]; for (var j = 0; j < tokens2.length; j++) {if (token === tokens2[j]) continue outer;}values.push(token);}return values;}function split(classString) {return classString && classString.split(' ');}function toClassString(classValue) {var classString = classValue; if (isArray(classValue)) {classString = classValue.map(toClassString).join(' ');}else if (isObject(classValue)) {classString = Object.keys(classValue) .filter(function (key) {return classValue[key];}) .join(' ');}return classString;}function toFlatValue(classValue) {var flatValue = classValue; if (isArray(classValue)) {flatValue = classValue.map(toFlatValue);}else if (isObject(classValue)) {var hasUndefined = false; flatValue = Object.keys(classValue).filter(function (key) {var value = classValue[key]; if (!hasUndefined && isUndefined(value)) {hasUndefined = true;}return value;}); if (hasUndefined) {flatValue.push(undefined);}}return flatValue;}}var ngClassDirective = classDirective('', true); var ngClassOddDirective = classDirective('Odd', 0); var ngClassEvenDirective = classDirective('Even', 1); var ngCloakDirective = ngDirective({compile: function (element, attr) {attr.$set('ngCloak', undefined); element.removeClass('ng-cloak');}, }); var ngControllerDirective = [ function () {return {restrict: 'A', scope: true, controller: '@', priority: 500, };}, ]; var ngEventDirectives = {}; var forceAsyncEvents = {blur: true, focus: true, }; forEach( 'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (eventName) {var directiveName = directiveNormalize('ng-' + eventName); ngEventDirectives[directiveName] = [ '$parse', '$rootScope', function ($parse, $rootScope) {return {restrict: 'A', compile: function ($element, attr) {var fn = $parse(attr[directiveName]); return function ngEventHandler(scope, element) {element.on(eventName, function (event) {var callback = function () {fn(scope, {$event: event });}; if (forceAsyncEvents[eventName] && $rootScope.$$phase) {scope.$evalAsync(callback);}else {scope.$apply(callback);}});};}, };}, ];}, ); var ngIfDirective = [ '$animate', '$compile', function ($animate, $compile) {return {multiElement: true, transclude: 'element', priority: 600, terminal: true, restrict: 'A', $$tlb: true, link: function ($scope, $element, $attr, ctrl, $transclude) {var block, childScope, previousElements; $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {if (value) {if (!childScope) {$transclude(function (clone, newScope) {childScope = newScope; clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf); block = {clone: clone, }; $animate.enter(clone, $element.parent(), $element);});}}else {if (previousElements) {previousElements.remove(); previousElements = null;}if (childScope) {childScope.$destroy(); childScope = null;}if (block) {previousElements = getBlockNodes(block.clone); $animate.leave(previousElements).done(function (response) {if (response !== false) previousElements = null;}); block = null;}}});}, };}, ]; var ngIncludeDirective = [ '$templateRequest', '$anchorScroll', '$animate', function ($templateRequest, $anchorScroll, $animate) {return {restrict: 'ECA', priority: 400, terminal: true, transclude: 'element', controller: angular.noop, compile: function (element, attr) {var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll; return function (scope, $element, $attr, ctrl, $transclude) {var changeCounter = 0, currentScope, previousElement, currentElement; var cleanupLastIncludeContent = function () {if (previousElement) {previousElement.remove(); previousElement = null;}if (currentScope) {currentScope.$destroy(); currentScope = null;}if (currentElement) {$animate.leave(currentElement).done(function (response) {if (response !== false) previousElement = null;}); previousElement = currentElement; currentElement = null;}}; scope.$watch(srcExp, function ngIncludeWatchAction(src) {var afterAnimation = function (response) {if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {$anchorScroll();}}; var thisChangeId = ++changeCounter; if (src) {$templateRequest(src, true).then( function (response) {if (scope.$$destroyed) return; if (thisChangeId !== changeCounter) return; var newScope = scope.$new(); ctrl.template = response; var clone = $transclude(newScope, function (clone) {cleanupLastIncludeContent(); $animate.enter(clone, null, $element).done(afterAnimation);}); currentScope = newScope; currentElement = clone; currentScope.$emit('$includeContentLoaded', src); scope.$eval(onloadExp);}, function () {if (scope.$$destroyed) return; if (thisChangeId === changeCounter) {cleanupLastIncludeContent(); scope.$emit('$includeContentError', src);}}, ); scope.$emit('$includeContentRequested', src);}else {cleanupLastIncludeContent(); ctrl.template = null;}});};}, };}, ]; var ngIncludeFillContentDirective = [ '$compile', function ($compile) {return {restrict: 'ECA', priority: -400, require: 'ngInclude', link: function (scope, $element, $attr, ctrl) {if (toString.call($element[0]).match(/SVG/)) {$element.empty(); $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)( scope, function namespaceAdaptedClone(clone) {$element.append(clone);}, {futureParentElement: $element }, ); return;}$element.html(ctrl.template); $compile($element.contents())(scope);}, };}, ]; var ngInitDirective = ngDirective({priority: 450, compile: function () {return {pre: function (scope, element, attrs) {scope.$eval(attrs.ngInit);}, };}, }); var ngListDirective = function () {return {restrict: 'A', priority: 100, require: 'ngModel', link: function (scope, element, attr, ctrl) {var ngList = attr.ngList || ', '; var trimValues = attr.ngTrim !== 'false'; var separator = trimValues ? trim(ngList) : ngList; var parse = function (viewValue) {if (isUndefined(viewValue)) return; var list = []; if (viewValue) {forEach(viewValue.split(separator), function (value) {if (value) list.push(trimValues ? trim(value) : value);});}return list;}; ctrl.$parsers.push(parse); ctrl.$formatters.push(function (value) {if (isArray(value)) {return value.join(ngList);}return undefined;}); ctrl.$isEmpty = function (value) {return !value || !value.length;};}, };}; var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty', UNTOUCHED_CLASS = 'ng-untouched', TOUCHED_CLASS = 'ng-touched', EMPTY_CLASS = 'ng-empty', NOT_EMPTY_CLASS = 'ng-not-empty'; var ngModelMinErr = minErr('ngModel'); NgModelController.$inject = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$q', '$interpolate']; function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {this.$viewValue = Number.NaN; this.$modelValue = Number.NaN; this.$$rawModelValue = undefined; this.$validators = {}; this.$asyncValidators = {}; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$untouched = true; this.$touched = false; this.$pristine = true; this.$dirty = false; this.$valid = true; this.$invalid = false; this.$error = {}; this.$$success = {}; this.$pending = undefined; this.$name = $interpolate($attr.name || '', false)($scope); this.$$parentForm = nullFormCtrl; this.$options = defaultModelOptions; this.$$parsedNgModel = $parse($attr.ngModel); this.$$parsedNgModelAssign = this.$$parsedNgModel.assign; this.$$ngModelGet = this.$$parsedNgModel; this.$$ngModelSet = this.$$parsedNgModelAssign; this.$$pendingDebounce = null; this.$$parserValid = undefined; this.$$currentValidationRunId = 0; Object.defineProperty(this, '$$scope', {value: $scope }); this.$$attr = $attr; this.$$element = $element; this.$$animate = $animate; this.$$timeout = $timeout; this.$$parse = $parse; this.$$q = $q; this.$$exceptionHandler = $exceptionHandler; setupValidity(this); setupModelWatcher(this);}NgModelController.prototype = {$$initGetterSetters: function () {if (this.$options.getOption('getterSetter')) {var invokeModelGetter = this.$$parse(this.$$attr.ngModel + '()'), invokeModelSetter = this.$$parse(this.$$attr.ngModel + '($$$p)'); this.$$ngModelGet = function ($scope) {var modelValue = this.$$parsedNgModel($scope); if (isFunction(modelValue)) {modelValue = invokeModelGetter($scope);}return modelValue;}; this.$$ngModelSet = function ($scope, newValue) {if (isFunction(this.$$parsedNgModel($scope))) {invokeModelSetter($scope, {$$$p: newValue });}else {this.$$parsedNgModelAssign($scope, newValue);}};}else if (!this.$$parsedNgModel.assign) {throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));}}, $render: noop, $isEmpty: function (value) {return isUndefined(value) || value === '' || value === null || value !== value;}, $$updateEmptyClasses: function (value) {if (this.$isEmpty(value)) {this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS); this.$$animate.addClass(this.$$element, EMPTY_CLASS);}else {this.$$animate.removeClass(this.$$element, EMPTY_CLASS); this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);}}, $setPristine: function () {this.$dirty = false; this.$pristine = true; this.$$animate.removeClass(this.$$element, DIRTY_CLASS); this.$$animate.addClass(this.$$element, PRISTINE_CLASS);}, $setDirty: function () {this.$dirty = true; this.$pristine = false; this.$$animate.removeClass(this.$$element, PRISTINE_CLASS); this.$$animate.addClass(this.$$element, DIRTY_CLASS); this.$$parentForm.$setDirty();}, $setUntouched: function () {this.$touched = false; this.$untouched = true; this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);}, $setTouched: function () {this.$touched = true; this.$untouched = false; this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);}, $rollbackViewValue: function () {this.$$timeout.cancel(this.$$pendingDebounce); this.$viewValue = this.$$lastCommittedViewValue; this.$render();}, $validate: function () {if (isNumberNaN(this.$modelValue)) {return;}var viewValue = this.$$lastCommittedViewValue; var modelValue = this.$$rawModelValue; var prevValid = this.$valid; var prevModelValue = this.$modelValue; var allowInvalid = this.$options.getOption('allowInvalid'); var that = this; this.$$runValidators(modelValue, viewValue, function (allValid) {if (!allowInvalid && prevValid !== allValid) {that.$modelValue = allValid ? modelValue : undefined; if (that.$modelValue !== prevModelValue) {that.$$writeModelToScope();}}});}, $$runValidators: function (modelValue, viewValue, doneCallback) {this.$$currentValidationRunId++; var localValidationRunId = this.$$currentValidationRunId; var that = this; if (!processParseErrors()) {validationDone(false); return;}if (!processSyncValidators()) {validationDone(false); return;}processAsyncValidators(); function processParseErrors() {var errorKey = that.$$parserName || 'parse'; if (isUndefined(that.$$parserValid)) {setValidity(errorKey, null);}else {if (!that.$$parserValid) {forEach(that.$validators, function (v, name) {setValidity(name, null);}); forEach(that.$asyncValidators, function (v, name) {setValidity(name, null);});}setValidity(errorKey, that.$$parserValid); return that.$$parserValid;}return true;}function processSyncValidators() {var syncValidatorsValid = true; forEach(that.$validators, function (validator, name) {var result = Boolean(validator(modelValue, viewValue)); syncValidatorsValid = syncValidatorsValid && result; setValidity(name, result);}); if (!syncValidatorsValid) {forEach(that.$asyncValidators, function (v, name) {setValidity(name, null);}); return false;}return true;}function processAsyncValidators() {var validatorPromises = []; var allValid = true; forEach(that.$asyncValidators, function (validator, name) {var promise = validator(modelValue, viewValue); if (!isPromiseLike(promise)) {throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);}setValidity(name, undefined); validatorPromises.push( promise.then( function () {setValidity(name, true);}, function () {allValid = false; setValidity(name, false);}, ), );}); if (!validatorPromises.length) {validationDone(true);}else {that.$$q.all(validatorPromises).then(function () {validationDone(allValid);}, noop);}}function setValidity(name, isValid) {if (localValidationRunId === that.$$currentValidationRunId) {that.$setValidity(name, isValid);}}function validationDone(allValid) {if (localValidationRunId === that.$$currentValidationRunId) {doneCallback(allValid);}}}, $commitViewValue: function () {var viewValue = this.$viewValue; this.$$timeout.cancel(this.$$pendingDebounce); if (this.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !this.$$hasNativeValidators)) {return;}this.$$updateEmptyClasses(viewValue); this.$$lastCommittedViewValue = viewValue; if (this.$pristine) {this.$setDirty();}this.$$parseAndValidate();}, $$parseAndValidate: function () {var viewValue = this.$$lastCommittedViewValue; var modelValue = viewValue; var that = this; this.$$parserValid = isUndefined(modelValue) ? undefined : true; if (this.$$parserValid) {for (var i = 0; i < this.$parsers.length; i++) {modelValue = this.$parsers[i](modelValue); if (isUndefined(modelValue)) {this.$$parserValid = false; break;}}}if (isNumberNaN(this.$modelValue)) {this.$modelValue = this.$$ngModelGet(this.$$scope);}var prevModelValue = this.$modelValue; var allowInvalid = this.$options.getOption('allowInvalid'); this.$$rawModelValue = modelValue; if (allowInvalid) {this.$modelValue = modelValue; writeToModelIfNeeded();}this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function (allValid) {if (!allowInvalid) {that.$modelValue = allValid ? modelValue : undefined; writeToModelIfNeeded();}}); function writeToModelIfNeeded() {if (that.$modelValue !== prevModelValue) {that.$$writeModelToScope();}}}, $$writeModelToScope: function () {this.$$ngModelSet(this.$$scope, this.$modelValue); forEach( this.$viewChangeListeners, function (listener) {try {listener();}catch (e) {this.$$exceptionHandler(e);}}, this, );}, $setViewValue: function (value, trigger) {this.$viewValue = value; if (this.$options.getOption('updateOnDefault')) {this.$$debounceViewValueCommit(trigger);}}, $$debounceViewValueCommit: function (trigger) {var debounceDelay = this.$options.getOption('debounce'); if (isNumber(debounceDelay[trigger])) {debounceDelay = debounceDelay[trigger];}else if (isNumber(debounceDelay['default'])) {debounceDelay = debounceDelay['default'];}this.$$timeout.cancel(this.$$pendingDebounce); var that = this; if (debounceDelay > 0) {this.$$pendingDebounce = this.$$timeout(function () {that.$commitViewValue();}, debounceDelay);}else if (this.$$scope.$root.$$phase) {this.$commitViewValue();}else {this.$$scope.$apply(function () {that.$commitViewValue();});}}, $overrideModelOptions: function (options) {this.$options = this.$options.createChild(options);}, }; function setupModelWatcher(ctrl) {ctrl.$$scope.$watch(function ngModelWatch(scope) {var modelValue = ctrl.$$ngModelGet(scope); if ( modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue) ) {ctrl.$modelValue = ctrl.$$rawModelValue = modelValue; ctrl.$$parserValid = undefined; var formatters = ctrl.$formatters, idx = formatters.length; var viewValue = modelValue; while (idx--) {viewValue = formatters[idx](viewValue);}if (ctrl.$viewValue !== viewValue) {ctrl.$$updateEmptyClasses(viewValue); ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue; ctrl.$render(); ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);}}return modelValue;});}addSetValidityMethod({clazz: NgModelController, set: function (object, property) {object[property] = true;}, unset: function (object, property) {delete object[property];}, }); var ngModelDirective = [ '$rootScope', function ($rootScope) {return {restrict: 'A', require: ['ngModel', '^?form', '^?ngModelOptions'], controller: NgModelController, priority: 1, compile: function ngModelCompile(element) {element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS); return {pre: function ngModelPreLink(scope, element, attr, ctrls) {var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2]; if (optionsCtrl) {modelCtrl.$options = optionsCtrl.$options;}modelCtrl.$$initGetterSetters(); formCtrl.$addControl(modelCtrl); attr.$observe('name', function (newValue) {if (modelCtrl.$name !== newValue) {modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);}}); scope.$on('$destroy', function () {modelCtrl.$$parentForm.$removeControl(modelCtrl);});}, post: function ngModelPostLink(scope, element, attr, ctrls) {var modelCtrl = ctrls[0]; if (modelCtrl.$options.getOption('updateOn')) {element.on(modelCtrl.$options.getOption('updateOn'), function (ev) {modelCtrl.$$debounceViewValueCommit(ev && ev.type);});}function setTouched() {modelCtrl.$setTouched();}element.on('blur', function () {if (modelCtrl.$touched) return; if ($rootScope.$$phase) {scope.$evalAsync(setTouched);}else {scope.$apply(setTouched);}});}, };}, };}, ]; var defaultModelOptions; var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/; function ModelOptions(options) {this.$$options = options;}ModelOptions.prototype = {getOption: function (name) {return this.$$options[name];}, createChild: function (options) {var inheritAll = false; options = extend({}, options); forEach( options, function (option, key) {if (option === '$inherit') {if (key === '*') {inheritAll = true;}else {options[key] = this.$$options[key]; if (key === 'updateOn') {options.updateOnDefault = this.$$options.updateOnDefault;}}}else {if (key === 'updateOn') {options.updateOnDefault = false; options[key] = trim( option.replace(DEFAULT_REGEXP, function () {options.updateOnDefault = true; return ' ';}), );}}}, this, ); if (inheritAll) {delete options['*']; defaults(options, this.$$options);}defaults(options, defaultModelOptions.$$options); return new ModelOptions(options);}, }; defaultModelOptions = new ModelOptions({updateOn: '', updateOnDefault: true, debounce: 0, getterSetter: false, allowInvalid: false, timezone: null, }); var ngModelOptionsDirective = function () {NgModelOptionsController.$inject = ['$attrs', '$scope']; function NgModelOptionsController($attrs, $scope) {this.$$attrs = $attrs; this.$$scope = $scope;}NgModelOptionsController.prototype = {$onInit: function () {var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions; var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions); this.$options = parentOptions.createChild(modelOptionsDefinition);}, }; return {restrict: 'A', priority: 10, require: {parentCtrl: '?^^ngModelOptions' }, bindToController: true, controller: NgModelOptionsController, };}; function defaults(dst, src) {forEach(src, function (value, key) {if (!isDefined(dst[key])) {dst[key] = value;}});}var ngNonBindableDirective = ngDirective({terminal: true, priority: 1000 }); var ngOptionsMinErr = minErr('ngOptions'); var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/; var ngOptionsDirective = [ '$compile', '$document', '$parse', function ($compile, $document, $parse) {function parseOptionsExpression(optionsExp, selectElement, scope) {var match = optionsExp.match(NG_OPTIONS_REGEXP); if (!match) {throw ngOptionsMinErr( 'iexp', 'Expected expression in form of ' + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement), );}var valueName = match[5] || match[7]; var keyName = match[6]; var selectAs = / as /.test(match[0]) && match[1]; var trackBy = match[9]; var valueFn = $parse(match[2] ? match[1] : valueName); var selectAsFn = selectAs && $parse(selectAs); var viewValueFn = selectAsFn || valueFn; var trackByFn = trackBy && $parse(trackBy); var getTrackByValueFn = trackBy ? function (value, locals) {return trackByFn(scope, locals);}: function getHashOfValue(value) {return hashKey(value);}; var getTrackByValue = function (value, key) {return getTrackByValueFn(value, getLocals(value, key));}; var displayFn = $parse(match[2] || match[1]); var groupByFn = $parse(match[3] || ''); var disableWhenFn = $parse(match[4] || ''); var valuesFn = $parse(match[8]); var locals = {}; var getLocals = keyName ? function (value, key) {locals[keyName] = key; locals[valueName] = value; return locals;}: function (value) {locals[valueName] = value; return locals;}; function Option(selectValue, viewValue, label, group, disabled) {this.selectValue = selectValue; this.viewValue = viewValue; this.label = label; this.group = group; this.disabled = disabled;}function getOptionValuesKeys(optionValues) {var optionValuesKeys; if (!keyName && isArrayLike(optionValues)) {optionValuesKeys = optionValues;}else {optionValuesKeys = []; for (var itemKey in optionValues) {if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {optionValuesKeys.push(itemKey);}}}return optionValuesKeys;}return {trackBy: trackBy, getTrackByValue: getTrackByValue, getWatchables: $parse(valuesFn, function (optionValues) {var watchedArray = []; optionValues = optionValues || []; var optionValuesKeys = getOptionValuesKeys(optionValues); var optionValuesLength = optionValuesKeys.length; for (var index = 0; index < optionValuesLength; index++) {var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index]; var value = optionValues[key]; var locals = getLocals(value, key); var selectValue = getTrackByValueFn(value, locals); watchedArray.push(selectValue); if (match[2] || match[1]) {var label = displayFn(scope, locals); watchedArray.push(label);}if (match[4]) {var disableWhen = disableWhenFn(scope, locals); watchedArray.push(disableWhen);}}return watchedArray;}), getOptions: function () {var optionItems = []; var selectValueMap = {}; var optionValues = valuesFn(scope) || []; var optionValuesKeys = getOptionValuesKeys(optionValues); var optionValuesLength = optionValuesKeys.length; for (var index = 0; index < optionValuesLength; index++) {var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index]; var value = optionValues[key]; var locals = getLocals(value, key); var viewValue = viewValueFn(scope, locals); var selectValue = getTrackByValueFn(viewValue, locals); var label = displayFn(scope, locals); var group = groupByFn(scope, locals); var disabled = disableWhenFn(scope, locals); var optionItem = new Option(selectValue, viewValue, label, group, disabled); optionItems.push(optionItem); selectValueMap[selectValue] = optionItem;}return {items: optionItems, selectValueMap: selectValueMap, getOptionFromViewValue: function (value) {return selectValueMap[getTrackByValue(value)];}, getViewValueFromOption: function (option) {return trackBy ? copy(option.viewValue) : option.viewValue;}, };}, };}var optionTemplate = window.document.createElement('option'), optGroupTemplate = window.document.createElement('optgroup'); function ngOptionsPostLink(scope, selectElement, attr, ctrls) {var selectCtrl = ctrls[0]; var ngModelCtrl = ctrls[1]; var multiple = attr.multiple; for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {if (children[i].value === '') {selectCtrl.hasEmptyOption = true; selectCtrl.emptyOption = children.eq(i); break;}}selectElement.empty(); var providedEmptyOption = !!selectCtrl.emptyOption; var unknownOption = jqLite(optionTemplate.cloneNode(false)); unknownOption.val('?'); var options; var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope); var listFragment = $document[0].createDocumentFragment(); selectCtrl.generateUnknownOptionValue = function (val) {return '?';}; if (!multiple) {selectCtrl.writeValue = function writeNgOptionsValue(value) {if (!options) return; var selectedOption = selectElement[0].options[selectElement[0].selectedIndex]; var option = options.getOptionFromViewValue(value); if (selectedOption) selectedOption.removeAttribute('selected'); if (option) {if (selectElement[0].value !== option.selectValue) {selectCtrl.removeUnknownOption(); selectElement[0].value = option.selectValue; option.element.selected = true;}option.element.setAttribute('selected', 'selected');}else {selectCtrl.selectUnknownOrEmptyOption(value);}}; selectCtrl.readValue = function readNgOptionsValue() {var selectedOption = options.selectValueMap[selectElement.val()]; if (selectedOption && !selectedOption.disabled) {selectCtrl.unselectEmptyOption(); selectCtrl.removeUnknownOption(); return options.getViewValueFromOption(selectedOption);}return null;}; if (ngOptions.trackBy) {scope.$watch( function () {return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);}, function () {ngModelCtrl.$render();}, );}}else {selectCtrl.writeValue = function writeNgOptionsMultiple(values) {if (!options) return; var selectedOptions = (values && values.map(getAndUpdateSelectedOption)) || []; options.items.forEach(function (option) {if (option.element.selected && !includes(selectedOptions, option)) {option.element.selected = false;}});}; selectCtrl.readValue = function readNgOptionsMultiple() {var selectedValues = selectElement.val() || [], selections = []; forEach(selectedValues, function (value) {var option = options.selectValueMap[value]; if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));}); return selections;}; if (ngOptions.trackBy) {scope.$watchCollection( function () {if (isArray(ngModelCtrl.$viewValue)) {return ngModelCtrl.$viewValue.map(function (value) {return ngOptions.getTrackByValue(value);});}}, function () {ngModelCtrl.$render();}, );}}if (providedEmptyOption) {$compile(selectCtrl.emptyOption)(scope); selectElement.prepend(selectCtrl.emptyOption); if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {selectCtrl.hasEmptyOption = false; selectCtrl.registerOption = function (optionScope, optionEl) {if (optionEl.val() === '') {selectCtrl.hasEmptyOption = true; selectCtrl.emptyOption = optionEl; selectCtrl.emptyOption.removeClass('ng-scope'); ngModelCtrl.$render(); optionEl.on('$destroy', function () {var needsRerender = selectCtrl.$isEmptyOptionSelected(); selectCtrl.hasEmptyOption = false; selectCtrl.emptyOption = undefined; if (needsRerender) ngModelCtrl.$render();});}};}else {selectCtrl.emptyOption.removeClass('ng-scope');}}scope.$watchCollection(ngOptions.getWatchables, updateOptions); function addOptionElement(option, parent) {var optionElement = optionTemplate.cloneNode(false); parent.appendChild(optionElement); updateOptionElement(option, optionElement);}function getAndUpdateSelectedOption(viewValue) {var option = options.getOptionFromViewValue(viewValue); var element = option && option.element; if (element && !element.selected) element.selected = true; return option;}function updateOptionElement(option, element) {option.element = element; element.disabled = option.disabled; if (option.label !== element.label) {element.label = option.label; element.textContent = option.label;}element.value = option.selectValue;}function updateOptions() {var previousValue = options && selectCtrl.readValue(); if (options) {for (var i = options.items.length - 1; i >= 0; i--) {var option = options.items[i]; if (isDefined(option.group)) {jqLiteRemove(option.element.parentNode);}else {jqLiteRemove(option.element);}}}options = ngOptions.getOptions(); var groupElementMap = {}; options.items.forEach(function addOption(option) {var groupElement; if (isDefined(option.group)) {groupElement = groupElementMap[option.group]; if (!groupElement) {groupElement = optGroupTemplate.cloneNode(false); listFragment.appendChild(groupElement); groupElement.label = option.group === null ? 'null' : option.group; groupElementMap[option.group] = groupElement;}addOptionElement(option, groupElement);}else {addOptionElement(option, listFragment);}}); selectElement[0].appendChild(listFragment); ngModelCtrl.$render(); if (!ngModelCtrl.$isEmpty(previousValue)) {var nextValue = selectCtrl.readValue(); var isNotPrimitive = ngOptions.trackBy || multiple; if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {ngModelCtrl.$setViewValue(nextValue); ngModelCtrl.$render();}}}}return {restrict: 'A', terminal: true, require: ['select', 'ngModel'], link: {pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {ctrls[0].registerOption = noop;}, post: ngOptionsPostLink, }, };}, ]; var ngPluralizeDirective = [ '$locale', '$interpolate', '$log', function ($locale, $interpolate, $log) {var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/; return {link: function (scope, element, attr) {var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount; forEach(attr, function (expression, attributeName) {var tmpMatch = IS_WHEN.exec(attributeName); if (tmpMatch) {var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]); whens[whenKey] = element.attr(attr.$attr[attributeName]);}}); forEach(whens, function (expression, key) {whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));}); scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {var count = parseFloat(newVal); var countIsNaN = isNumberNaN(count); if (!countIsNaN && !(count in whens)) {count = $locale.pluralCat(count - offset);}if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {watchRemover(); var whenExpFn = whensExpFns[count]; if (isUndefined(whenExpFn)) {if (newVal != null) {$log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);}watchRemover = noop; updateElementText();}else {watchRemover = scope.$watch(whenExpFn, updateElementText);}lastCount = count;}}); function updateElementText(newText) {element.text(newText || '');}}, };}, ]; var ngRepeatDirective = [ '$parse', '$animate', '$compile', function ($parse, $animate, $compile) {var NG_REMOVED = '$$NG_REMOVED'; var ngRepeatMinErr = minErr('ngRepeat'); var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {scope[valueIdentifier] = value; if (keyIdentifier) scope[keyIdentifier] = key; scope.$index = index; scope.$first = index === 0; scope.$last = index === arrayLength - 1; scope.$middle = !(scope.$first || scope.$last); scope.$odd = !(scope.$even = (index & 1) === 0);}; var getBlockStart = function (block) {return block.clone[0];}; var getBlockEnd = function (block) {return block.clone[block.clone.length - 1];}; return {restrict: 'A', multiElement: true, transclude: 'element', priority: 1000, terminal: true, $$tlb: true, compile: function ngRepeatCompile($element, $attr) {var expression = $attr.ngRepeat; var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression); var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/); if (!match) {throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);}var lhs = match[1]; var rhs = match[2]; var aliasAs = match[3]; var trackByExp = match[4]; match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/); if (!match) {throw ngRepeatMinErr( 'iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs, );}var valueIdentifier = match[3] || match[1]; var keyIdentifier = match[2]; if ( aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs)) ) {throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);}var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn; var hashFnLocals = {$id: hashKey }; if (trackByExp) {trackByExpGetter = $parse(trackByExp);}else {trackByIdArrayFn = function (key, value) {return hashKey(value);}; trackByIdObjFn = function (key) {return key;};}return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {if (trackByExpGetter) {trackByIdExpFn = function (key, value, index) {if (keyIdentifier) hashFnLocals[keyIdentifier] = key; hashFnLocals[valueIdentifier] = value; hashFnLocals.$index = index; return trackByExpGetter($scope, hashFnLocals);};}var lastBlockMap = createMap(); $scope.$watchCollection(rhs, function ngRepeatAction(collection) {var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove; if (aliasAs) {$scope[aliasAs] = collection;}if (isArrayLike(collection)) {collectionKeys = collection; trackByIdFn = trackByIdExpFn || trackByIdArrayFn;}else {trackByIdFn = trackByIdExpFn || trackByIdObjFn; collectionKeys = []; for (var itemKey in collection) {if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {collectionKeys.push(itemKey);}}}collectionLength = collectionKeys.length; nextBlockOrder = new Array(collectionLength); for (index = 0; index < collectionLength; index++) {key = collection === collectionKeys ? index : collectionKeys[index]; value = collection[key]; trackById = trackByIdFn(key, value, index); if (lastBlockMap[trackById]) {block = lastBlockMap[trackById]; delete lastBlockMap[trackById]; nextBlockMap[trackById] = block; nextBlockOrder[index] = block;}else if (nextBlockMap[trackById]) {forEach(nextBlockOrder, function (block) {if (block && block.scope) lastBlockMap[block.id] = block;}); throw ngRepeatMinErr( 'dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value, );}else {nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined }; nextBlockMap[trackById] = true;}}for (var blockKey in lastBlockMap) {block = lastBlockMap[blockKey]; elementsToRemove = getBlockNodes(block.clone); $animate.leave(elementsToRemove); if (elementsToRemove[0].parentNode) {for (index = 0, length = elementsToRemove.length; index < length; index++) {elementsToRemove[index][NG_REMOVED] = true;}}block.scope.$destroy();}for (index = 0; index < collectionLength; index++) {key = collection === collectionKeys ? index : collectionKeys[index]; value = collection[key]; block = nextBlockOrder[index]; if (block.scope) {nextNode = previousNode; do {nextNode = nextNode.nextSibling;}while (nextNode && nextNode[NG_REMOVED]); if (getBlockStart(block) !== nextNode) {$animate.move(getBlockNodes(block.clone), null, previousNode);}previousNode = getBlockEnd(block); updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);}else {$transclude(function ngRepeatTransclude(clone, scope) {block.scope = scope; var endNode = ngRepeatEndComment.cloneNode(false); clone[clone.length++] = endNode; $animate.enter(clone, null, previousNode); previousNode = endNode; block.clone = clone; nextBlockMap[block.id] = block; updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);});}}lastBlockMap = nextBlockMap;});};}, };}, ]; var NG_HIDE_CLASS = 'ng-hide'; var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate'; var ngShowDirective = [ '$animate', function ($animate) {return {restrict: 'A', multiElement: true, link: function (scope, element, attr) {scope.$watch(attr.ngShow, function ngShowWatchAction(value) {$animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS, });});}, };}, ]; var ngHideDirective = [ '$animate', function ($animate) {return {restrict: 'A', multiElement: true, link: function (scope, element, attr) {scope.$watch(attr.ngHide, function ngHideWatchAction(value) {$animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS, });});}, };}, ]; var ngStyleDirective = ngDirective(function (scope, element, attr) {scope.$watch( attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {if (oldStyles && newStyles !== oldStyles) {forEach(oldStyles, function (val, style) {element.css(style, '');});}if (newStyles) element.css(newStyles);}, true, );}); var ngSwitchDirective = [ '$animate', '$compile', function ($animate, $compile) {return {require: 'ngSwitch', controller: [ '$scope', function NgSwitchController() {this.cases = {};}, ], link: function (scope, element, attr, ngSwitchController) {var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = []; var spliceFactory = function (array, index) {return function (response) {if (response !== false) array.splice(index, 1);};}; scope.$watch(watchExpr, function ngSwitchWatchAction(value) {var i, ii; while (previousLeaveAnimations.length) {$animate.cancel(previousLeaveAnimations.pop());}for (i = 0, ii = selectedScopes.length; i < ii; ++i) {var selected = getBlockNodes(selectedElements[i].clone); selectedScopes[i].$destroy(); var runner = (previousLeaveAnimations[i] = $animate.leave(selected)); runner.done(spliceFactory(previousLeaveAnimations, i));}selectedElements.length = 0; selectedScopes.length = 0; if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {forEach(selectedTranscludes, function (selectedTransclude) {selectedTransclude.transclude(function (caseElement, selectedScope) {selectedScopes.push(selectedScope); var anchor = selectedTransclude.element; caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen'); var block = {clone: caseElement }; selectedElements.push(block); $animate.enter(caseElement, anchor.parent(), anchor);});});}});}, };}, ]; var ngSwitchWhenDirective = ngDirective({transclude: 'element', priority: 1200, require: '^ngSwitch', multiElement: true, link: function (scope, element, attrs, ctrl, $transclude) {var cases = attrs.ngSwitchWhen .split(attrs.ngSwitchWhenSeparator) .sort() .filter( function (element, index, array) {return array[index - 1] !== element;}, ); forEach(cases, function (whenCase) {ctrl.cases['!' + whenCase] = ctrl.cases['!' + whenCase] || []; ctrl.cases['!' + whenCase].push({transclude: $transclude, element: element });});}, }); var ngSwitchDefaultDirective = ngDirective({transclude: 'element', priority: 1200, require: '^ngSwitch', multiElement: true, link: function (scope, element, attr, ctrl, $transclude) {ctrl.cases['?'] = ctrl.cases['?'] || []; ctrl.cases['?'].push({transclude: $transclude, element: element });}, }); var ngTranscludeMinErr = minErr('ngTransclude'); var ngTranscludeDirective = [ '$compile', function ($compile) {return {restrict: 'EAC', terminal: true, compile: function ngTranscludeCompile(tElement) {var fallbackLinkFn = $compile(tElement.contents()); tElement.empty(); return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {if (!$transclude) {throw ngTranscludeMinErr( 'orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element), );}if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {$attrs.ngTransclude = '';}var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot; $transclude(ngTranscludeCloneAttachFn, null, slotName); if (slotName && !$transclude.isSlotFilled(slotName)) {useFallbackContent();}function ngTranscludeCloneAttachFn(clone, transcludedScope) {if (clone.length && notWhitespace(clone)) {$element.append(clone);}else {useFallbackContent(); transcludedScope.$destroy();}}function useFallbackContent() {fallbackLinkFn($scope, function (clone) {$element.append(clone);});}function notWhitespace(nodes) {for (var i = 0, ii = nodes.length; i < ii; i++) {var node = nodes[i]; if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {return true;}}}};}, };}, ]; var scriptDirective = [ '$templateCache', function ($templateCache) {return {restrict: 'E', terminal: true, compile: function (element, attr) {if (attr.type === 'text/ng-template') {var templateUrl = attr.id, text = element[0].text; $templateCache.put(templateUrl, text);}}, };}, ]; var noopNgModelController = {$setViewValue: noop, $render: noop }; function setOptionSelectedStatus(optionEl, value) {optionEl.prop('selected', value); optionEl.attr('selected', value);}var SelectController = [ '$element', '$scope', function ($element, $scope) {var self = this, optionsMap = new NgMap(); self.selectValueMap = {}; self.ngModelCtrl = noopNgModelController; self.multiple = false; self.unknownOption = jqLite(window.document.createElement('option')); self.hasEmptyOption = false; self.emptyOption = undefined; self.renderUnknownOption = function (val) {var unknownVal = self.generateUnknownOptionValue(val); self.unknownOption.val(unknownVal); $element.prepend(self.unknownOption); setOptionSelectedStatus(self.unknownOption, true); $element.val(unknownVal);}; self.updateUnknownOption = function (val) {var unknownVal = self.generateUnknownOptionValue(val); self.unknownOption.val(unknownVal); setOptionSelectedStatus(self.unknownOption, true); $element.val(unknownVal);}; self.generateUnknownOptionValue = function (val) {return '? ' + hashKey(val) + ' ?';}; self.removeUnknownOption = function () {if (self.unknownOption.parent()) self.unknownOption.remove();}; self.selectEmptyOption = function () {if (self.emptyOption) {$element.val(''); setOptionSelectedStatus(self.emptyOption, true);}}; self.unselectEmptyOption = function () {if (self.hasEmptyOption) {setOptionSelectedStatus(self.emptyOption, false);}}; $scope.$on('$destroy', function () {self.renderUnknownOption = noop;}); self.readValue = function readSingleValue() {var val = $element.val(); var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val; if (self.hasOption(realVal)) {return realVal;}return null;}; self.writeValue = function writeSingleValue(value) {var currentlySelectedOption = $element[0].options[$element[0].selectedIndex]; if (currentlySelectedOption) setOptionSelectedStatus(jqLite(currentlySelectedOption), false); if (self.hasOption(value)) {self.removeUnknownOption(); var hashedVal = hashKey(value); $element.val(hashedVal in self.selectValueMap ? hashedVal : value); var selectedOption = $element[0].options[$element[0].selectedIndex]; setOptionSelectedStatus(jqLite(selectedOption), true);}else {self.selectUnknownOrEmptyOption(value);}}; self.addOption = function (value, element) {if (element[0].nodeType === NODE_TYPE_COMMENT) return; assertNotHasOwnProperty(value, '"option value"'); if (value === '') {self.hasEmptyOption = true; self.emptyOption = element;}var count = optionsMap.get(value) || 0; optionsMap.set(value, count + 1); scheduleRender();}; self.removeOption = function (value) {var count = optionsMap.get(value); if (count) {if (count === 1) {optionsMap.delete(value); if (value === '') {self.hasEmptyOption = false; self.emptyOption = undefined;}}else {optionsMap.set(value, count - 1);}}}; self.hasOption = function (value) {return !!optionsMap.get(value);}; self.$hasEmptyOption = function () {return self.hasEmptyOption;}; self.$isUnknownOptionSelected = function () {return $element[0].options[0] === self.unknownOption[0];}; self.$isEmptyOptionSelected = function () {return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];}; self.selectUnknownOrEmptyOption = function (value) {if (value == null && self.emptyOption) {self.removeUnknownOption(); self.selectEmptyOption();}else if (self.unknownOption.parent().length) {self.updateUnknownOption(value);}else {self.renderUnknownOption(value);}}; var renderScheduled = false; function scheduleRender() {if (renderScheduled) return; renderScheduled = true; $scope.$$postDigest(function () {renderScheduled = false; self.ngModelCtrl.$render();});}var updateScheduled = false; function scheduleViewValueUpdate(renderAfter) {if (updateScheduled) return; updateScheduled = true; $scope.$$postDigest(function () {if ($scope.$$destroyed) return; updateScheduled = false; self.ngModelCtrl.$setViewValue(self.readValue()); if (renderAfter) self.ngModelCtrl.$render();});}self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {if (optionAttrs.$attr.ngValue) {var oldVal, hashedVal = NaN; optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {var removal; var previouslySelected = optionElement.prop('selected'); if (isDefined(hashedVal)) {self.removeOption(oldVal); delete self.selectValueMap[hashedVal]; removal = true;}hashedVal = hashKey(newVal); oldVal = newVal; self.selectValueMap[hashedVal] = newVal; self.addOption(newVal, optionElement); optionElement.attr('value', hashedVal); if (removal && previouslySelected) {scheduleViewValueUpdate();}});}else if (interpolateValueFn) {optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {self.readValue(); var removal; var previouslySelected = optionElement.prop('selected'); if (isDefined(oldVal)) {self.removeOption(oldVal); removal = true;}oldVal = newVal; self.addOption(newVal, optionElement); if (removal && previouslySelected) {scheduleViewValueUpdate();}});}else if (interpolateTextFn) {optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {optionAttrs.$set('value', newVal); var previouslySelected = optionElement.prop('selected'); if (oldVal !== newVal) {self.removeOption(oldVal);}self.addOption(newVal, optionElement); if (oldVal && previouslySelected) {scheduleViewValueUpdate();}});}else {self.addOption(optionAttrs.value, optionElement);}optionAttrs.$observe('disabled', function (newVal) {if (newVal === 'true' || (newVal && optionElement.prop('selected'))) {if (self.multiple) {scheduleViewValueUpdate(true);}else {self.ngModelCtrl.$setViewValue(null); self.ngModelCtrl.$render();}}}); optionElement.on('$destroy', function () {var currentValue = self.readValue(); var removeValue = optionAttrs.value; self.removeOption(removeValue); scheduleRender(); if ((self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1) || currentValue === removeValue) {scheduleViewValueUpdate(true);}});};}, ]; var selectDirective = function () {return {restrict: 'E', require: ['select', '?ngModel'], controller: SelectController, priority: 1, link: {pre: selectPreLink, post: selectPostLink, }, }; function selectPreLink(scope, element, attr, ctrls) {var selectCtrl = ctrls[0]; var ngModelCtrl = ctrls[1]; if (!ngModelCtrl) {selectCtrl.registerOption = noop; return;}selectCtrl.ngModelCtrl = ngModelCtrl; element.on('change', function () {selectCtrl.removeUnknownOption(); scope.$apply(function () {ngModelCtrl.$setViewValue(selectCtrl.readValue());});}); if (attr.multiple) {selectCtrl.multiple = true; selectCtrl.readValue = function readMultipleValue() {var array = []; forEach(element.find('option'), function (option) {if (option.selected && !option.disabled) {var val = option.value; array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);}}); return array;}; selectCtrl.writeValue = function writeMultipleValue(value) {forEach(element.find('option'), function (option) {var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value])); var currentlySelected = option.selected; if (shouldBeSelected !== currentlySelected) {setOptionSelectedStatus(jqLite(option), shouldBeSelected);}});}; var lastView, lastViewRef = NaN; scope.$watch(function selectMultipleWatch() {if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {lastView = shallowCopy(ngModelCtrl.$viewValue); ngModelCtrl.$render();}lastViewRef = ngModelCtrl.$viewValue;}); ngModelCtrl.$isEmpty = function (value) {return !value || value.length === 0;};}}function selectPostLink(scope, element, attrs, ctrls) {var ngModelCtrl = ctrls[1]; if (!ngModelCtrl) return; var selectCtrl = ctrls[0]; ngModelCtrl.$render = function () {selectCtrl.writeValue(ngModelCtrl.$viewValue);};}}; var optionDirective = [ '$interpolate', function ($interpolate) {return {restrict: 'E', priority: 100, compile: function (element, attr) {var interpolateValueFn, interpolateTextFn; if (isDefined(attr.ngValue)) {}else if (isDefined(attr.value)) {interpolateValueFn = $interpolate(attr.value, true);}else {interpolateTextFn = $interpolate(element.text(), true); if (!interpolateTextFn) {attr.$set('value', element.text());}}return function (scope, element, attr) {var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName); if (selectCtrl) {selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);}};}, };}, ]; var requiredDirective = function () {return {restrict: 'A', require: '?ngModel', link: function (scope, elm, attr, ctrl) {if (!ctrl) return; attr.required = true; ctrl.$validators.required = function (modelValue, viewValue) {return !attr.required || !ctrl.$isEmpty(viewValue);}; attr.$observe('required', function () {ctrl.$validate();});}, };}; var patternDirective = function () {return {restrict: 'A', require: '?ngModel', link: function (scope, elm, attr, ctrl) {if (!ctrl) return; var regexp, patternExp = attr.ngPattern || attr.pattern; attr.$observe('pattern', function (regex) {if (isString(regex) && regex.length > 0) {regex = new RegExp('^' + regex + '$');}if (regex && !regex.test) {throw minErr('ngPattern')('noregexp', 'Expected {0}to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));}regexp = regex || undefined; ctrl.$validate();}); ctrl.$validators.pattern = function (modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);};}, };}; var maxlengthDirective = function () {return {restrict: 'A', require: '?ngModel', link: function (scope, elm, attr, ctrl) {if (!ctrl) return; var maxlength = -1; attr.$observe('maxlength', function (value) {var intVal = toInt(value); maxlength = isNumberNaN(intVal) ? -1 : intVal; ctrl.$validate();}); ctrl.$validators.maxlength = function (modelValue, viewValue) {return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;};}, };}; var minlengthDirective = function () {return {restrict: 'A', require: '?ngModel', link: function (scope, elm, attr, ctrl) {if (!ctrl) return; var minlength = 0; attr.$observe('minlength', function (value) {minlength = toInt(value) || 0; ctrl.$validate();}); ctrl.$validators.minlength = function (modelValue, viewValue) {return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;};}, };}; if (window.angular.bootstrap) {if (window.console) {}return;}bindJQuery(); publishExternalAPI(angular); angular.module( 'ngLocale', [], [ '$provide', function ($provide) {var PLURAL_CATEGORY = {ZERO: 'zero', ONE: 'one', TWO: 'two', FEW: 'few', MANY: 'many', OTHER: 'other' }; function getDecimals(n) {n = n + ''; var i = n.indexOf('.'); return i == -1 ? 0 : n.length - i - 1;}function getVF(n, opt_precision) {var v = opt_precision; if (undefined === v) {v = Math.min(getDecimals(n), 3);}var base = Math.pow(10, v); var f = ((n * base) | 0) % base; return {v: v, f: f };}$provide.value('$locale', {DATETIME_FORMATS: {AMPMS: ['AM', 'PM'], DAY: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], ERANAMES: ['Before Christ', 'Anno Domini'], ERAS: ['BC', 'AD'], FIRSTDAYOFWEEK: 6, MONTH: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], SHORTDAY: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], SHORTMONTH: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], STANDALONEMONTH: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], WEEKENDRANGE: [5, 6], fullDate: 'EEEE, MMMM d, y', longDate: 'MMMM d, y', medium: 'MMM d, y h:mm:ss a', mediumDate: 'MMM d, y', mediumTime: 'h:mm:ss a', short: 'M/d/yy h:mm a', shortDate: 'M/d/yy', shortTime: 'h:mm a', }, NUMBER_FORMATS: {CURRENCY_SYM: '$', DECIMAL_SEP: '.', GROUP_SEP: ',', PATTERNS: [ {gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: '-', negSuf: '', posPre: '', posSuf: '', }, {gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: '-\u00a4', negSuf: '', posPre: '\u00a4', posSuf: '', }, ], }, id: 'en-us', localeID: 'en_US', pluralCat: function (n, opt_precision) {var i = n | 0; var vf = getVF(n, opt_precision); if (i == 1 && vf.v == 0) {return PLURAL_CATEGORY.ONE;}return PLURAL_CATEGORY.OTHER;}, });}, ], ); jqLite(function () {angularInit(window.document, bootstrap);});})(window); !window.angular.$$csp().noInlineStyle && window.angular .element(document.head) .prepend( '<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>', ); (function (window, angular) {'use strict'; var ngAriaModule = angular.module('ngAria', ['ng']).info({angularVersion: '1.6.6' }).provider('$aria', $AriaProvider); var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY']; var isNodeOneOf = function (elem, nodeTypeArray) {if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {return true;}}; function $AriaProvider() {var config = {ariaHidden: true, ariaChecked: true, ariaReadonly: true, ariaDisabled: true, ariaRequired: true, ariaInvalid: true, ariaValue: true, tabindex: true, bindKeydown: true, bindRoleForClick: true, }; this.config = function (newConfig) {config = angular.extend(config, newConfig);}; function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {return function (scope, elem, attr) {var ariaCamelName = attr.$normalize(ariaAttr); if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {scope.$watch(attr[attrName], function (boolVal) {boolVal = negate ? !boolVal : !!boolVal; elem.attr(ariaAttr, boolVal);});}};}this.$get = function () {return {config: function (key) {return config[key];}, $$watchExpr: watchExpr, };};}ngAriaModule .directive('ngShow', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);}, ]) .directive('ngHide', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);}, ]) .directive('ngValue', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);}, ]) .directive('ngChecked', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);}, ]) .directive('ngReadonly', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngReadonly', 'aria-readonly', nodeBlackList, false);}, ]) .directive('ngRequired', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);}, ]) .directive('ngModel', [ '$aria', function ($aria) {function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));}function shouldAttachRole(role, elem) {return !elem.attr('role') && elem.attr('type') === role && !isNodeOneOf(elem, nodeBlackList);}function getShape(attr, elem) {var type = attr.type, role = attr.role; return (type || role) === 'checkbox' || role === 'menuitemcheckbox' ? 'checkbox' : (type || role) === 'radio' || role === 'menuitemradio' ? 'radio' : type === 'range' || role === 'progressbar' || role === 'slider' ? 'range' : '';}return {restrict: 'A', require: 'ngModel', priority: 200, compile: function (elem, attr) {var shape = getShape(attr, elem); return {post: function (scope, elem, attr, ngModel) {var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false); function ngAriaWatchModelValue() {return ngModel.$modelValue;}function getRadioReaction(newVal) {var boolVal = attr.value == ngModel.$viewValue; elem.attr('aria-checked', boolVal);}function getCheckboxReaction() {elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));}switch (shape) {case 'radio': case 'checkbox': if (shouldAttachRole(shape, elem)) {elem.attr('role', shape);}if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {scope.$watch(ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction : getCheckboxReaction);}if (needsTabIndex) {elem.attr('tabindex', 0);}break; case 'range': if (shouldAttachRole(shape, elem)) {elem.attr('role', 'slider');}if ($aria.config('ariaValue')) {var needsAriaValuemin = !elem.attr('aria-valuemin') && (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin')); var needsAriaValuemax = !elem.attr('aria-valuemax') && (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax')); var needsAriaValuenow = !elem.attr('aria-valuenow'); if (needsAriaValuemin) {attr.$observe('min', function ngAriaValueMinReaction(newVal) {elem.attr('aria-valuemin', newVal);});}if (needsAriaValuemax) {attr.$observe('max', function ngAriaValueMinReaction(newVal) {elem.attr('aria-valuemax', newVal);});}if (needsAriaValuenow) {scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {elem.attr('aria-valuenow', newVal);});}}if (needsTabIndex) {elem.attr('tabindex', 0);}break;}if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {attr.$observe('required', function () {elem.attr('aria-required', !!attr['required']);});}if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {scope.$watch( function ngAriaInvalidWatch() {return ngModel.$invalid;}, function ngAriaInvalidReaction(newVal) {elem.attr('aria-invalid', !!newVal);}, );}}, };}, };}, ]) .directive('ngDisabled', [ '$aria', function ($aria) {return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);}, ]) .directive('ngMessages', function () {return {restrict: 'A', require: '?ngMessages', link: function (scope, elem, attr, ngMessages) {if (!elem.attr('aria-live')) {elem.attr('aria-live', 'assertive');}}, };}) .directive('ngClick', [ '$aria', '$parse', function ($aria, $parse) {return {restrict: 'A', compile: function (elem, attr) {var fn = $parse(attr.ngClick); return function (scope, elem, attr) {if (!isNodeOneOf(elem, nodeBlackList)) {if ($aria.config('bindRoleForClick') && !elem.attr('role')) {elem.attr('role', 'button');}if ($aria.config('tabindex') && !elem.attr('tabindex')) {elem.attr('tabindex', 0);}if ($aria.config('bindKeydown') && !attr.ngKeydown && !attr.ngKeypress && !attr.ngKeyup) {elem.on('keydown', function (event) {var keyCode = event.which || event.keyCode; if (keyCode === 32 || keyCode === 13) {scope.$apply(callback);}function callback() {fn(scope, {$event: event });}});}}};}, };}, ]) .directive('ngDblclick', [ '$aria', function ($aria) {return function (scope, elem, attr) {if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {elem.attr('tabindex', 0);}};}, ]);})(window, window.angular); (function (window, angular) {'use strict'; var ELEMENT_NODE = 1; var COMMENT_NODE = 8; var ADD_CLASS_SUFFIX = '-add'; var REMOVE_CLASS_SUFFIX = '-remove'; var EVENT_CLASS_PREFIX = 'ng-'; var ACTIVE_CLASS_SUFFIX = '-active'; var PREPARE_CLASS_SUFFIX = '-prepare'; var NG_ANIMATE_CLASSNAME = 'ng-animate'; var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren'; var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT; if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {CSS_PREFIX = '-webkit-'; TRANSITION_PROP = 'WebkitTransition'; TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';}else {TRANSITION_PROP = 'transition'; TRANSITIONEND_EVENT = 'transitionend';}if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {CSS_PREFIX = '-webkit-'; ANIMATION_PROP = 'WebkitAnimation'; ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';}else {ANIMATION_PROP = 'animation'; ANIMATIONEND_EVENT = 'animationend';}var DURATION_KEY = 'Duration'; var PROPERTY_KEY = 'Property'; var DELAY_KEY = 'Delay'; var TIMING_KEY = 'TimingFunction'; var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount'; var ANIMATION_PLAYSTATE_KEY = 'PlayState'; var SAFE_FAST_FORWARD_DURATION_VALUE = 9999; var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY; var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY; var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY; var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY; var ngMinErr = angular.$$minErr('ng'); function assertArg(arg, name, reason) {if (!arg) {throw ngMinErr('areq', "Argument '{0}' is {1}", name || '?', reason || 'required');}return arg;}function mergeClasses(a, b) {if (!a && !b) return ''; if (!a) return b; if (!b) return a; if (isArray(a)) a = a.join(' '); if (isArray(b)) b = b.join(' '); return a + ' ' + b;}function packageStyles(options) {var styles = {}; if (options && (options.to || options.from)) {styles.to = options.to; styles.from = options.from;}return styles;}function pendClasses(classes, fix, isPrefix) {var className = ''; classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : []; forEach(classes, function (klass, i) {if (klass && klass.length > 0) {className += i > 0 ? ' ' : ''; className += isPrefix ? fix + klass : klass + fix;}}); return className;}function removeFromArray(arr, val) {var index = arr.indexOf(val); if (val >= 0) {arr.splice(index, 1);}}function stripCommentsFromElement(element) {if (element instanceof jqLite) {switch (element.length) {case 0: return element; case 1: if (element[0].nodeType === ELEMENT_NODE) {return element;}break; default: return jqLite(extractElementNode(element));}}if (element.nodeType === ELEMENT_NODE) {return jqLite(element);}}function extractElementNode(element) {if (!element[0]) return element; for (var i = 0; i < element.length; i++) {var elm = element[i]; if (elm.nodeType === ELEMENT_NODE) {return elm;}}}function $$addClass($$jqLite, element, className) {forEach(element, function (elm) {$$jqLite.addClass(elm, className);});}function $$removeClass($$jqLite, element, className) {forEach(element, function (elm) {$$jqLite.removeClass(elm, className);});}function applyAnimationClassesFactory($$jqLite) {return function (element, options) {if (options.addClass) {$$addClass($$jqLite, element, options.addClass); options.addClass = null;}if (options.removeClass) {$$removeClass($$jqLite, element, options.removeClass); options.removeClass = null;}};}function prepareAnimationOptions(options) {options = options || {}; if (!options.$$prepared) {var domOperation = options.domOperation || noop; options.domOperation = function () {options.$$domOperationFired = true; domOperation(); domOperation = noop;}; options.$$prepared = true;}return options;}function applyAnimationStyles(element, options) {applyAnimationFromStyles(element, options); applyAnimationToStyles(element, options);}function applyAnimationFromStyles(element, options) {if (options.from) {element.css(options.from); options.from = null;}}function applyAnimationToStyles(element, options) {if (options.to) {element.css(options.to); options.to = null;}}function mergeAnimationDetails(element, oldAnimation, newAnimation) {var target = oldAnimation.options || {}; var newOptions = newAnimation.options || {}; var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || ''); var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || ''); var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove); if (newOptions.preparationClasses) {target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses); delete newOptions.preparationClasses;}var realDomOperation = target.domOperation !== noop ? target.domOperation : null; extend(target, newOptions); if (realDomOperation) {target.domOperation = realDomOperation;}if (classes.addClass) {target.addClass = classes.addClass;}else {target.addClass = null;}if (classes.removeClass) {target.removeClass = classes.removeClass;}else {target.removeClass = null;}oldAnimation.addClass = target.addClass; oldAnimation.removeClass = target.removeClass; return target;}function resolveElementClasses(existing, toAdd, toRemove) {var ADD_CLASS = 1; var REMOVE_CLASS = -1; var flags = {}; existing = splitClassesToLookup(existing); toAdd = splitClassesToLookup(toAdd); forEach(toAdd, function (value, key) {flags[key] = ADD_CLASS;}); toRemove = splitClassesToLookup(toRemove); forEach(toRemove, function (value, key) {flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;}); var classes = {addClass: '', removeClass: '', }; forEach(flags, function (val, klass) {var prop, allow; if (val === ADD_CLASS) {prop = 'addClass'; allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];}else if (val === REMOVE_CLASS) {prop = 'removeClass'; allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];}if (allow) {if (classes[prop].length) {classes[prop] += ' ';}classes[prop] += klass;}}); function splitClassesToLookup(classes) {if (isString(classes)) {classes = classes.split(' ');}var obj = {}; forEach(classes, function (klass) {if (klass.length) {obj[klass] = true;}}); return obj;}return classes;}function getDomNode(element) {return element instanceof jqLite ? element[0] : element;}function applyGeneratedPreparationClasses(element, event, options) {var classes = ''; if (event) {classes = pendClasses(event, EVENT_CLASS_PREFIX, true);}if (options.addClass) {classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));}if (options.removeClass) {classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));}if (classes.length) {options.preparationClasses = classes; element.addClass(classes);}}function clearGeneratedClasses(element, options) {if (options.preparationClasses) {element.removeClass(options.preparationClasses); options.preparationClasses = null;}if (options.activeClasses) {element.removeClass(options.activeClasses); options.activeClasses = null;}}function blockTransitions(node, duration) {var value = duration ? '-' + duration + 's' : ''; applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]); return [TRANSITION_DELAY_PROP, value];}function blockKeyframeAnimations(node, applyBlock) {var value = applyBlock ? 'paused' : ''; var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY; applyInlineStyle(node, [key, value]); return [key, value];}function applyInlineStyle(node, styleTuple) {var prop = styleTuple[0]; var value = styleTuple[1]; node.style[prop] = value;}function concatWithSpace(a, b) {if (!a) return b; if (!b) return a; return a + ' ' + b;}var $$rAFSchedulerFactory = [ '$$rAF', function ($$rAF) {var queue, cancelFn; function scheduler(tasks) {queue = queue.concat(tasks); nextTick();}queue = scheduler.queue = []; scheduler.waitUntilQuiet = function (fn) {if (cancelFn) cancelFn(); cancelFn = $$rAF(function () {cancelFn = null; fn(); nextTick();});}; return scheduler; function nextTick() {if (!queue.length) return; var items = queue.shift(); for (var i = 0; i < items.length; i++) {items[i]();}if (!cancelFn) {$$rAF(function () {if (!cancelFn) nextTick();});}}}, ]; var $$AnimateChildrenDirective = [ '$interpolate', function ($interpolate) {return {link: function (scope, element, attrs) {var val = attrs.ngAnimateChildren; if (isString(val) && val.length === 0) {element.data(NG_ANIMATE_CHILDREN_DATA, true);}else {setData($interpolate(val)(scope)); attrs.$observe('ngAnimateChildren', setData);}function setData(value) {value = value === 'on' || value === 'true'; element.data(NG_ANIMATE_CHILDREN_DATA, value);}}, };}, ]; var ANIMATE_TIMER_KEY = '$$animateCss'; var ONE_SECOND = 1000; var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3; var CLOSING_TIME_BUFFER = 1.5; var DETECT_CSS_PROPERTIES = {transitionDuration: TRANSITION_DURATION_PROP, transitionDelay: TRANSITION_DELAY_PROP, transitionProperty: TRANSITION_PROP + PROPERTY_KEY, animationDuration: ANIMATION_DURATION_PROP, animationDelay: ANIMATION_DELAY_PROP, animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY, }; var DETECT_STAGGER_CSS_PROPERTIES = {transitionDuration: TRANSITION_DURATION_PROP, transitionDelay: TRANSITION_DELAY_PROP, animationDuration: ANIMATION_DURATION_PROP, animationDelay: ANIMATION_DELAY_PROP, }; function getCssKeyframeDurationStyle(duration) {return [ANIMATION_DURATION_PROP, duration + 's'];}function getCssDelayStyle(delay, isKeyframeAnimation) {var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP; return [prop, delay + 's'];}function computeCssStyles($window, element, properties) {var styles = Object.create(null); var detectedStyles = $window.getComputedStyle(element) || {}; forEach(properties, function (formalStyleName, actualStyleName) {var val = detectedStyles[formalStyleName]; if (val) {var c = val.charAt(0); if (c === '-' || c === '+' || c >= 0) {val = parseMaxTime(val);}if (val === 0) {val = null;}styles[actualStyleName] = val;}}); return styles;}function parseMaxTime(str) {var maxValue = 0; var values = str.split(/\s*,\s*/); forEach(values, function (value) {if (value.charAt(value.length - 1) === 's') {value = value.substring(0, value.length - 1);}value = parseFloat(value) || 0; maxValue = maxValue ? Math.max(value, maxValue) : value;}); return maxValue;}function truthyTimingValue(val) {return val === 0 || val != null;}function getCssTransitionDurationStyle(duration, applyOnlyDuration) {var style = TRANSITION_PROP; var value = duration + 's'; if (applyOnlyDuration) {style += DURATION_KEY;}else {value += ' linear all';}return [style, value];}function createLocalCacheLookup() {var cache = Object.create(null); return {flush: function () {cache = Object.create(null);}, count: function (key) {var entry = cache[key]; return entry ? entry.total : 0;}, get: function (key) {var entry = cache[key]; return entry && entry.value;}, put: function (key, value) {if (!cache[key]) {cache[key] = {total: 1, value: value };}else {cache[key].total++;}}, };}function registerRestorableStyles(backup, node, properties) {forEach(properties, function (prop) {backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);});}var $AnimateCssProvider = [ '$animateProvider', function ($animateProvider) {var gcsLookup = createLocalCacheLookup(); var gcsStaggerLookup = createLocalCacheLookup(); this.$get = [ '$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function ($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {var applyAnimationClasses = applyAnimationClassesFactory($$jqLite); var parentCounter = 0; function gcsHashFn(node, extraClasses) {var KEY = '$$ngAnimateParentKey'; var parentNode = node.parentNode; var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter); return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;}function computeCachedCssStyles(node, className, cacheKey, properties) {var timings = gcsLookup.get(cacheKey); if (!timings) {timings = computeCssStyles($window, node, properties); if (timings.animationIterationCount === 'infinite') {timings.animationIterationCount = 1;}}gcsLookup.put(cacheKey, timings); return timings;}function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {var stagger; if (gcsLookup.count(cacheKey) > 0) {stagger = gcsStaggerLookup.get(cacheKey); if (!stagger) {var staggerClassName = pendClasses(className, '-stagger'); $$jqLite.addClass(node, staggerClassName); stagger = computeCssStyles($window, node, properties); stagger.animationDuration = Math.max(stagger.animationDuration, 0); stagger.transitionDuration = Math.max(stagger.transitionDuration, 0); $$jqLite.removeClass(node, staggerClassName); gcsStaggerLookup.put(cacheKey, stagger);}}return stagger || {};}var rafWaitQueue = []; function waitUntilQuiet(callback) {rafWaitQueue.push(callback); $$rAFScheduler.waitUntilQuiet(function () {gcsLookup.flush(); gcsStaggerLookup.flush(); var pageWidth = $$forceReflow(); for (var i = 0; i < rafWaitQueue.length; i++) {rafWaitQueue[i](pageWidth);}rafWaitQueue.length = 0;});}function computeTimings(node, className, cacheKey) {var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES); var aD = timings.animationDelay; var tD = timings.transitionDelay; timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD; timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration); return timings;}return function init(element, initialOptions) {var options = initialOptions || {}; if (!options.$$prepared) {options = prepareAnimationOptions(copy(options));}var restoreStyles = {}; var node = getDomNode(element); if (!node || !node.parentNode || !$$animateQueue.enabled()) {return closeAndReturnNoopAnimator();}var temporaryStyles = []; var classes = element.attr('class'); var styles = packageStyles(options); var animationClosed; var animationPaused; var animationCompleted; var runner; var runnerHost; var maxDelay; var maxDelayTime; var maxDuration; var maxDurationTime; var startTime; var events = []; if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {return closeAndReturnNoopAnimator();}var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event; var isStructural = method && options.structural; var structuralClassName = ''; var addRemoveClassName = ''; if (isStructural) {structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);}else if (method) {structuralClassName = method;}if (options.addClass) {addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);}if (options.removeClass) {if (addRemoveClassName.length) {addRemoveClassName += ' ';}addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);}if (options.applyClassesEarly && addRemoveClassName.length) {applyAnimationClasses(element, options);}var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim(); var fullClassName = classes + ' ' + preparationClasses; var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX); var hasToStyles = styles.to && Object.keys(styles.to).length > 0; var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0; if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {return closeAndReturnNoopAnimator();}var cacheKey, stagger; if (options.stagger > 0) {var staggerVal = parseFloat(options.stagger); stagger = {transitionDelay: staggerVal, animationDelay: staggerVal, transitionDuration: 0, animationDuration: 0, };}else {cacheKey = gcsHashFn(node, fullClassName); stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);}if (!options.$$skipPreparationClasses) {$$jqLite.addClass(element, preparationClasses);}var applyOnlyDuration; if (options.transitionStyle) {var transitionStyle = [TRANSITION_PROP, options.transitionStyle]; applyInlineStyle(node, transitionStyle); temporaryStyles.push(transitionStyle);}if (options.duration >= 0) {applyOnlyDuration = node.style[TRANSITION_PROP].length > 0; var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration); applyInlineStyle(node, durationStyle); temporaryStyles.push(durationStyle);}if (options.keyframeStyle) {var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle]; applyInlineStyle(node, keyframeStyle); temporaryStyles.push(keyframeStyle);}var itemIndex = stagger ? (options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey)) : 0; var isFirst = itemIndex === 0; if (isFirst && !options.skipBlocking) {blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);}var timings = computeTimings(node, fullClassName, cacheKey); var relativeDelay = timings.maxDelay; maxDelay = Math.max(relativeDelay, 0); maxDuration = timings.maxDuration; var flags = {}; flags.hasTransitions = timings.transitionDuration > 0; flags.hasAnimations = timings.animationDuration > 0; flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === 'all'; flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions)); flags.applyAnimationDuration = options.duration && flags.hasAnimations; flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions); flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations; flags.recalculateTimingStyles = addRemoveClassName.length > 0; if (flags.applyTransitionDuration || flags.applyAnimationDuration) {maxDuration = options.duration ? parseFloat(options.duration) : maxDuration; if (flags.applyTransitionDuration) {flags.hasTransitions = true; timings.transitionDuration = maxDuration; applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0; temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));}if (flags.applyAnimationDuration) {flags.hasAnimations = true; timings.animationDuration = maxDuration; temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));}}if (maxDuration === 0 && !flags.recalculateTimingStyles) {return closeAndReturnNoopAnimator();}if (options.delay != null) {var delayStyle; if (typeof options.delay !== 'boolean') {delayStyle = parseFloat(options.delay); maxDelay = Math.max(delayStyle, 0);}if (flags.applyTransitionDelay) {temporaryStyles.push(getCssDelayStyle(delayStyle));}if (flags.applyAnimationDelay) {temporaryStyles.push(getCssDelayStyle(delayStyle, true));}}if (options.duration == null && timings.transitionDuration > 0) {flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;}maxDelayTime = maxDelay * ONE_SECOND; maxDurationTime = maxDuration * ONE_SECOND; if (!options.skipBlocking) {flags.blockTransition = timings.transitionDuration > 0; flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;}if (options.from) {if (options.cleanupStyles) {registerRestorableStyles(restoreStyles, node, Object.keys(options.from));}applyAnimationFromStyles(element, options);}if (flags.blockTransition || flags.blockKeyframeAnimation) {applyBlocking(maxDuration);}else if (!options.skipBlocking) {blockTransitions(node, false);}return {$$willAnimate: true, end: endFn, start: function () {if (animationClosed) return; runnerHost = {end: endFn, cancel: cancelFn, resume: null, pause: null, }; runner = new $$AnimateRunner(runnerHost); waitUntilQuiet(start); return runner;}, }; function endFn() {close();}function cancelFn() {close(true);}function close(rejected) {if (animationClosed || (animationCompleted && animationPaused)) return; animationClosed = true; animationPaused = false; if (!options.$$skipPreparationClasses) {$$jqLite.removeClass(element, preparationClasses);}$$jqLite.removeClass(element, activeClasses); blockKeyframeAnimations(node, false); blockTransitions(node, false); forEach(temporaryStyles, function (entry) {node.style[entry[0]] = '';}); applyAnimationClasses(element, options); applyAnimationStyles(element, options); if (Object.keys(restoreStyles).length) {forEach(restoreStyles, function (value, prop) {if (value) {node.style.setProperty(prop, value);}else {node.style.removeProperty(prop);}});}if (options.onDone) {options.onDone();}if (events && events.length) {element.off(events.join(' '), onAnimationProgress);}var animationTimerData = element.data(ANIMATE_TIMER_KEY); if (animationTimerData) {$timeout.cancel(animationTimerData[0].timer); element.removeData(ANIMATE_TIMER_KEY);}if (runner) {runner.complete(!rejected);}}function applyBlocking(duration) {if (flags.blockTransition) {blockTransitions(node, duration);}if (flags.blockKeyframeAnimation) {blockKeyframeAnimations(node, !!duration);}}function closeAndReturnNoopAnimator() {runner = new $$AnimateRunner({end: endFn, cancel: cancelFn, }); waitUntilQuiet(noop); close(); return {$$willAnimate: false, start: function () {return runner;}, end: endFn, };}function onAnimationProgress(event) {event.stopPropagation(); var ev = event.originalEvent || event; var timeStamp = ev.$manualTimeStamp || Date.now(); var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)); if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {animationCompleted = true; close();}}function start() {if (animationClosed) return; if (!node.parentNode) {close(); return;}var playPause = function (playAnimation) {if (!animationCompleted) {animationPaused = !playAnimation; if (timings.animationDuration) {var value = blockKeyframeAnimations(node, animationPaused); if (animationPaused) {temporaryStyles.push(value);}else {removeFromArray(temporaryStyles, value);}}}else if (animationPaused && playAnimation) {animationPaused = false; close();}}; var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay); if (maxStagger) {$timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);}else {triggerAnimationStart();}runnerHost.resume = function () {playPause(true);}; runnerHost.pause = function () {playPause(false);}; function triggerAnimationStart() {if (animationClosed) return; applyBlocking(false); forEach(temporaryStyles, function (entry) {var key = entry[0]; var value = entry[1]; node.style[key] = value;}); applyAnimationClasses(element, options); $$jqLite.addClass(element, activeClasses); if (flags.recalculateTimingStyles) {fullClassName = node.getAttribute('class') + ' ' + preparationClasses; cacheKey = gcsHashFn(node, fullClassName); timings = computeTimings(node, fullClassName, cacheKey); relativeDelay = timings.maxDelay; maxDelay = Math.max(relativeDelay, 0); maxDuration = timings.maxDuration; if (maxDuration === 0) {close(); return;}flags.hasTransitions = timings.transitionDuration > 0; flags.hasAnimations = timings.animationDuration > 0;}if (flags.applyAnimationDelay) {relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay; maxDelay = Math.max(relativeDelay, 0); timings.animationDelay = relativeDelay; delayStyle = getCssDelayStyle(relativeDelay, true); temporaryStyles.push(delayStyle); node.style[delayStyle[0]] = delayStyle[1];}maxDelayTime = maxDelay * ONE_SECOND; maxDurationTime = maxDuration * ONE_SECOND; if (options.easing) {var easeProp, easeVal = options.easing; if (flags.hasTransitions) {easeProp = TRANSITION_PROP + TIMING_KEY; temporaryStyles.push([easeProp, easeVal]); node.style[easeProp] = easeVal;}if (flags.hasAnimations) {easeProp = ANIMATION_PROP + TIMING_KEY; temporaryStyles.push([easeProp, easeVal]); node.style[easeProp] = easeVal;}}if (timings.transitionDuration) {events.push(TRANSITIONEND_EVENT);}if (timings.animationDuration) {events.push(ANIMATIONEND_EVENT);}startTime = Date.now(); var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime; var endTime = startTime + timerTime; var animationsData = element.data(ANIMATE_TIMER_KEY) || []; var setupFallbackTimer = true; if (animationsData.length) {var currentTimerData = animationsData[0]; setupFallbackTimer = endTime > currentTimerData.expectedEndTime; if (setupFallbackTimer) {$timeout.cancel(currentTimerData.timer);}else {animationsData.push(close);}}if (setupFallbackTimer) {var timer = $timeout(onAnimationExpired, timerTime, false); animationsData[0] = {timer: timer, expectedEndTime: endTime, }; animationsData.push(close); element.data(ANIMATE_TIMER_KEY, animationsData);}if (events.length) {element.on(events.join(' '), onAnimationProgress);}if (options.to) {if (options.cleanupStyles) {registerRestorableStyles(restoreStyles, node, Object.keys(options.to));}applyAnimationToStyles(element, options);}}function onAnimationExpired() {var animationsData = element.data(ANIMATE_TIMER_KEY); if (animationsData) {for (var i = 1; i < animationsData.length; i++) {animationsData[i]();}element.removeData(ANIMATE_TIMER_KEY);}}}};}, ];}, ]; var $$AnimateCssDriverProvider = [ '$$animationProvider', function ($$animationProvider) {$$animationProvider.drivers.push('$$animateCssDriver'); var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim'; var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor'; var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out'; var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in'; function isDocumentFragment(node) {return node.parentNode && node.parentNode.nodeType === 11;}this.$get = [ '$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {if (!$sniffer.animations && !$sniffer.transitions) return noop; var bodyNode = $document[0].body; var rootNode = getDomNode($rootElement); var rootBodyElement = jqLite( isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode, ); return function initDriverFn(animationDetails) {return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);}; function filterCssClasses(classes) {return classes.replace(/\bng-\S+\b/g, '');}function getUniqueValues(a, b) {if (isString(a)) a = a.split(' '); if (isString(b)) b = b.split(' '); return a .filter(function (val) {return b.indexOf(val) === -1;}) .join(' ');}function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {var clone = jqLite(getDomNode(outAnchor).cloneNode(true)); var startingClasses = filterCssClasses(getClassVal(clone)); outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME); inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME); clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME); rootBodyElement.append(clone); var animatorIn, animatorOut = prepareOutAnimation(); if (!animatorOut) {animatorIn = prepareInAnimation(); if (!animatorIn) {return end();}}var startingAnimator = animatorOut || animatorIn; return {start: function () {var runner; var currentAnimation = startingAnimator.start(); currentAnimation.done(function () {currentAnimation = null; if (!animatorIn) {animatorIn = prepareInAnimation(); if (animatorIn) {currentAnimation = animatorIn.start(); currentAnimation.done(function () {currentAnimation = null; end(); runner.complete();}); return currentAnimation;}}end(); runner.complete();}); runner = new $$AnimateRunner({end: endFn, cancel: endFn, }); return runner; function endFn() {if (currentAnimation) {currentAnimation.end();}}}, }; function calculateAnchorStyles(anchor) {var styles = {}; var coords = getDomNode(anchor).getBoundingClientRect(); forEach(['width', 'height', 'top', 'left'], function (key) {var value = coords[key]; switch (key) {case 'top': value += bodyNode.scrollTop; break; case 'left': value += bodyNode.scrollLeft; break;}styles[key] = Math.floor(value) + 'px';}); return styles;}function prepareOutAnimation() {var animator = $animateCss(clone, {addClass: NG_OUT_ANCHOR_CLASS_NAME, delay: true, from: calculateAnchorStyles(outAnchor), }); return animator.$$willAnimate ? animator : null;}function getClassVal(element) {return element.attr('class') || '';}function prepareInAnimation() {var endingClasses = filterCssClasses(getClassVal(inAnchor)); var toAdd = getUniqueValues(endingClasses, startingClasses); var toRemove = getUniqueValues(startingClasses, endingClasses); var animator = $animateCss(clone, {to: calculateAnchorStyles(inAnchor), addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd, removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove, delay: true, }); return animator.$$willAnimate ? animator : null;}function end() {clone.remove(); outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME); inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);}}function prepareFromToAnchorAnimation(from, to, classes, anchors) {var fromAnimation = prepareRegularAnimation(from, noop); var toAnimation = prepareRegularAnimation(to, noop); var anchorAnimations = []; forEach(anchors, function (anchor) {var outElement = anchor['out']; var inElement = anchor['in']; var animator = prepareAnchoredAnimation(classes, outElement, inElement); if (animator) {anchorAnimations.push(animator);}}); if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return; return {start: function () {var animationRunners = []; if (fromAnimation) {animationRunners.push(fromAnimation.start());}if (toAnimation) {animationRunners.push(toAnimation.start());}forEach(anchorAnimations, function (animation) {animationRunners.push(animation.start());}); var runner = new $$AnimateRunner({end: endFn, cancel: endFn, }); $$AnimateRunner.all(animationRunners, function (status) {runner.complete(status);}); return runner; function endFn() {forEach(animationRunners, function (runner) {runner.end();});}}, };}function prepareRegularAnimation(animationDetails) {var element = animationDetails.element; var options = animationDetails.options || {}; if (animationDetails.structural) {options.event = animationDetails.event; options.structural = true; options.applyClassesEarly = true; if (animationDetails.event === 'leave') {options.onDone = options.domOperation;}}if (options.preparationClasses) {options.event = concatWithSpace(options.event, options.preparationClasses);}var animator = $animateCss(element, options); return animator.$$willAnimate ? animator : null;}}, ];}, ]; var $$AnimateJsProvider = [ '$animateProvider', function ($animateProvider) {this.$get = [ '$injector', '$$AnimateRunner', '$$jqLite', function ($injector, $$AnimateRunner, $$jqLite) {var applyAnimationClasses = applyAnimationClassesFactory($$jqLite); return function (element, event, classes, options) {var animationClosed = false; if (arguments.length === 3 && isObject(classes)) {options = classes; classes = null;}options = prepareAnimationOptions(options); if (!classes) {classes = element.attr('class') || ''; if (options.addClass) {classes += ' ' + options.addClass;}if (options.removeClass) {classes += ' ' + options.removeClass;}}var classesToAdd = options.addClass; var classesToRemove = options.removeClass; var animations = lookupAnimations(classes); var before, after; if (animations.length) {var afterFn, beforeFn; if (event === 'leave') {beforeFn = 'leave'; afterFn = 'afterLeave';}else {beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1); afterFn = event;}if (event !== 'enter' && event !== 'move') {before = packageAnimations(element, event, options, animations, beforeFn);}after = packageAnimations(element, event, options, animations, afterFn);}if (!before && !after) return; function applyOptions() {options.domOperation(); applyAnimationClasses(element, options);}function close() {animationClosed = true; applyOptions(); applyAnimationStyles(element, options);}var runner; return {$$willAnimate: true, end: function () {if (runner) {runner.end();}else {close(); runner = new $$AnimateRunner(); runner.complete(true);}return runner;}, start: function () {if (runner) {return runner;}runner = new $$AnimateRunner(); var closeActiveAnimations; var chain = []; if (before) {chain.push(function (fn) {closeActiveAnimations = before(fn);});}if (chain.length) {chain.push(function (fn) {applyOptions(); fn(true);});}else {applyOptions();}if (after) {chain.push(function (fn) {closeActiveAnimations = after(fn);});}runner.setHost({end: function () {endAnimations();}, cancel: function () {endAnimations(true);}, }); $$AnimateRunner.chain(chain, onComplete); return runner; function onComplete(success) {close(success); runner.complete(success);}function endAnimations(cancelled) {if (!animationClosed) {(closeActiveAnimations || noop)(cancelled); onComplete(cancelled);}}}, }; function executeAnimationFn(fn, element, event, options, onDone) {var args; switch (event) {case 'animate': args = [element, options.from, options.to, onDone]; break; case 'setClass': args = [element, classesToAdd, classesToRemove, onDone]; break; case 'addClass': args = [element, classesToAdd, onDone]; break; case 'removeClass': args = [element, classesToRemove, onDone]; break; default: args = [element, onDone]; break;}args.push(options); var value = fn.apply(fn, args); if (value) {if (isFunction(value.start)) {value = value.start();}if (value instanceof $$AnimateRunner) {value.done(onDone);}else if (isFunction(value)) {return value;}}return noop;}function groupEventedAnimations(element, event, options, animations, fnName) {var operations = []; forEach(animations, function (ani) {var animation = ani[fnName]; if (!animation) return; operations.push(function () {var runner; var endProgressCb; var resolved = false; var onAnimationComplete = function (rejected) {if (!resolved) {resolved = true; (endProgressCb || noop)(rejected); runner.complete(!rejected);}}; runner = new $$AnimateRunner({end: function () {onAnimationComplete();}, cancel: function () {onAnimationComplete(true);}, }); endProgressCb = executeAnimationFn(animation, element, event, options, function (result) {var cancelled = result === false; onAnimationComplete(cancelled);}); return runner;});}); return operations;}function packageAnimations(element, event, options, animations, fnName) {var operations = groupEventedAnimations(element, event, options, animations, fnName); if (operations.length === 0) {var a, b; if (fnName === 'beforeSetClass') {a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass'); b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');}else if (fnName === 'setClass') {a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass'); b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');}if (a) {operations = operations.concat(a);}if (b) {operations = operations.concat(b);}}if (operations.length === 0) return; return function startAnimation(callback) {var runners = []; if (operations.length) {forEach(operations, function (animateFn) {runners.push(animateFn());});}if (runners.length) {$$AnimateRunner.all(runners, callback);}else {callback();}return function endFn(reject) {forEach(runners, function (runner) {if (reject) {runner.cancel();}else {runner.end();}});};};}}; function lookupAnimations(classes) {classes = isArray(classes) ? classes : classes.split(' '); var matches = [], flagMap = {}; for (var i = 0; i < classes.length; i++) {var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass]; if (animationFactory && !flagMap[klass]) {matches.push($injector.get(animationFactory)); flagMap[klass] = true;}}return matches;}}, ];}, ]; var $$AnimateJsDriverProvider = [ '$$animationProvider', function ($$animationProvider) {$$animationProvider.drivers.push('$$animateJsDriver'); this.$get = [ '$$animateJs', '$$AnimateRunner', function ($$animateJs, $$AnimateRunner) {return function initDriverFn(animationDetails) {if (animationDetails.from && animationDetails.to) {var fromAnimation = prepareAnimation(animationDetails.from); var toAnimation = prepareAnimation(animationDetails.to); if (!fromAnimation && !toAnimation) return; return {start: function () {var animationRunners = []; if (fromAnimation) {animationRunners.push(fromAnimation.start());}if (toAnimation) {animationRunners.push(toAnimation.start());}$$AnimateRunner.all(animationRunners, done); var runner = new $$AnimateRunner({end: endFnFactory(), cancel: endFnFactory(), }); return runner; function endFnFactory() {return function () {forEach(animationRunners, function (runner) {runner.end();});};}function done(status) {runner.complete(status);}}, };}else {return prepareAnimation(animationDetails);}}; function prepareAnimation(animationDetails) {var element = animationDetails.element; var event = animationDetails.event; var options = animationDetails.options; var classes = animationDetails.classes; return $$animateJs(element, event, classes, options);}}, ];}, ]; var NG_ANIMATE_ATTR_NAME = 'data-ng-animate'; var NG_ANIMATE_PIN_DATA = '$ngAnimatePin'; var $$AnimateQueueProvider = [ '$animateProvider', function ($animateProvider) {var PRE_DIGEST_STATE = 1; var RUNNING_STATE = 2; var ONE_SPACE = ' '; var rules = (this.rules = {skip: [], cancel: [], join: [], }); function makeTruthyCssClassMap(classString) {if (!classString) {return null;}var keys = classString.split(ONE_SPACE); var map = Object.create(null); forEach(keys, function (key) {map[key] = true;}); return map;}function hasMatchingClasses(newClassString, currentClassString) {if (newClassString && currentClassString) {var currentClassMap = makeTruthyCssClassMap(currentClassString); return newClassString.split(ONE_SPACE).some(function (className) {return currentClassMap[className];});}}function isAllowed(ruleType, currentAnimation, previousAnimation) {return rules[ruleType].some(function (fn) {return fn(currentAnimation, previousAnimation);});}function hasAnimationClasses(animation, and) {var a = (animation.addClass || '').length > 0; var b = (animation.removeClass || '').length > 0; return and ? a && b : a || b;}rules.join.push(function (newAnimation, currentAnimation) {return !newAnimation.structural && hasAnimationClasses(newAnimation);}); rules.skip.push(function (newAnimation, currentAnimation) {return !newAnimation.structural && !hasAnimationClasses(newAnimation);}); rules.skip.push(function (newAnimation, currentAnimation) {return currentAnimation.event === 'leave' && newAnimation.structural;}); rules.skip.push(function (newAnimation, currentAnimation) {return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;}); rules.cancel.push(function (newAnimation, currentAnimation) {return currentAnimation.structural && newAnimation.structural;}); rules.cancel.push(function (newAnimation, currentAnimation) {return currentAnimation.state === RUNNING_STATE && newAnimation.structural;}); rules.cancel.push(function (newAnimation, currentAnimation) {if (currentAnimation.structural) return false; var nA = newAnimation.addClass; var nR = newAnimation.removeClass; var cA = currentAnimation.addClass; var cR = currentAnimation.removeClass; if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {return false;}return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);}); this.$get = [ '$$rAF', '$rootScope', '$rootElement', '$document', '$$Map', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', '$$isDocumentHidden', function ( $$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden, ) {var activeAnimationsLookup = new $$Map(); var disabledElementsLookup = new $$Map(); var animationsEnabled = null; function postDigestTaskFactory() {var postDigestCalled = false; return function (fn) {if (postDigestCalled) {fn();}else {$rootScope.$$postDigest(function () {postDigestCalled = true; fn();});}};}var deregisterWatch = $rootScope.$watch( function () {return $templateRequest.totalPendingRequests === 0;}, function (isEmpty) {if (!isEmpty) return; deregisterWatch(); $rootScope.$$postDigest(function () {$rootScope.$$postDigest(function () {if (animationsEnabled === null) {animationsEnabled = true;}});});}, ); var callbackRegistry = Object.create(null); var customFilter = $animateProvider.customFilter(); var classNameFilter = $animateProvider.classNameFilter(); var returnTrue = function () {return true;}; var isAnimatableByFilter = customFilter || returnTrue; var isAnimatableClassName = !classNameFilter ? returnTrue : function (node, options) {var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' '); return classNameFilter.test(className);}; var applyAnimationClasses = applyAnimationClassesFactory($$jqLite); function normalizeAnimationDetails(element, animation) {return mergeAnimationDetails(element, animation, {});}var contains = window.Node.prototype.contains || function (arg) {return this === arg || !!(this.compareDocumentPosition(arg) & 16);}; function findCallbacks(targetParentNode, targetNode, event) {var matches = []; var entries = callbackRegistry[event]; if (entries) {forEach(entries, function (entry) {if (contains.call(entry.node, targetNode)) {matches.push(entry.callback);}else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {matches.push(entry.callback);}});}return matches;}function filterFromRegistry(list, matchContainer, matchCallback) {var containerNode = extractElementNode(matchContainer); return list.filter(function (entry) {var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback); return !isMatch;});}function cleanupEventListeners(phase, node) {if (phase === 'close' && !node.parentNode) {$animate.off(node);}}var $animate = {on: function (event, container, callback) {var node = extractElementNode(container); callbackRegistry[event] = callbackRegistry[event] || []; callbackRegistry[event].push({node: node, callback: callback, }); jqLite(container).on('$destroy', function () {var animationDetails = activeAnimationsLookup.get(node); if (!animationDetails) {$animate.off(event, container, callback);}});}, off: function (event, container, callback) {if (arguments.length === 1 && !isString(arguments[0])) {container = arguments[0]; for (var eventType in callbackRegistry) {callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);}return;}var entries = callbackRegistry[event]; if (!entries) return; callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);}, pin: function (element, parentElement) {assertArg(isElement(element), 'element', 'not an element'); assertArg(isElement(parentElement), 'parentElement', 'not an element'); element.data(NG_ANIMATE_PIN_DATA, parentElement);}, push: function (element, event, options, domOperation) {options = options || {}; options.domOperation = domOperation; return queueAnimation(element, event, options);}, enabled: function (element, bool) {var argCount = arguments.length; if (argCount === 0) {bool = !!animationsEnabled;}else {var hasElement = isElement(element); if (!hasElement) {bool = animationsEnabled = !!element;}else {var node = getDomNode(element); if (argCount === 1) {bool = !disabledElementsLookup.get(node);}else {disabledElementsLookup.set(node, !bool);}}}return bool;}, }; return $animate; function queueAnimation(originalElement, event, initialOptions) {var options = copy(initialOptions); var element = stripCommentsFromElement(originalElement); var node = getDomNode(element); var parentNode = node && node.parentNode; options = prepareAnimationOptions(options); var runner = new $$AnimateRunner(); var runInNextPostDigestOrNow = postDigestTaskFactory(); if (isArray(options.addClass)) {options.addClass = options.addClass.join(' ');}if (options.addClass && !isString(options.addClass)) {options.addClass = null;}if (isArray(options.removeClass)) {options.removeClass = options.removeClass.join(' ');}if (options.removeClass && !isString(options.removeClass)) {options.removeClass = null;}if (options.from && !isObject(options.from)) {options.from = null;}if (options.to && !isObject(options.to)) {options.to = null;}if (!animationsEnabled || !node || !isAnimatableByFilter(node, event, initialOptions) || !isAnimatableClassName(node, options)) {close(); return runner;}var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0; var documentHidden = $$isDocumentHidden(); var skipAnimations = documentHidden || disabledElementsLookup.get(node); var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {}; var hasExistingAnimation = !!existingAnimation.state; if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {skipAnimations = !areAnimationsAllowed(node, parentNode, event);}if (skipAnimations) {if (documentHidden) notifyProgress(runner, event, 'start'); close(); if (documentHidden) notifyProgress(runner, event, 'close'); return runner;}if (isStructural) {closeChildAnimations(node);}var newAnimation = {structural: isStructural, element: element, event: event, addClass: options.addClass, removeClass: options.removeClass, close: close, options: options, runner: runner, }; if (hasExistingAnimation) {var skipAnimationFlag = isAllowed('skip', newAnimation, existingAnimation); if (skipAnimationFlag) {if (existingAnimation.state === RUNNING_STATE) {close(); return runner;}else {mergeAnimationDetails(element, existingAnimation, newAnimation); return existingAnimation.runner;}}var cancelAnimationFlag = isAllowed('cancel', newAnimation, existingAnimation); if (cancelAnimationFlag) {if (existingAnimation.state === RUNNING_STATE) {existingAnimation.runner.end();}else if (existingAnimation.structural) {existingAnimation.close();}else {mergeAnimationDetails(element, existingAnimation, newAnimation); return existingAnimation.runner;}}else {var joinAnimationFlag = isAllowed('join', newAnimation, existingAnimation); if (joinAnimationFlag) {if (existingAnimation.state === RUNNING_STATE) {normalizeAnimationDetails(element, newAnimation);}else {applyGeneratedPreparationClasses(element, isStructural ? event : null, options); event = newAnimation.event = existingAnimation.event; options = mergeAnimationDetails(element, existingAnimation, newAnimation); return existingAnimation.runner;}}}}else {normalizeAnimationDetails(element, newAnimation);}var isValidAnimation = newAnimation.structural; if (!isValidAnimation) {isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);}if (!isValidAnimation) {close(); clearElementAnimationState(node); return runner;}var counter = (existingAnimation.counter || 0) + 1; newAnimation.counter = counter; markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation); $rootScope.$$postDigest(function () {element = stripCommentsFromElement(originalElement); var animationDetails = activeAnimationsLookup.get(node); var animationCancelled = !animationDetails; animationDetails = animationDetails || {}; var parentElement = element.parent() || []; var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails)); if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {if (animationCancelled) {applyAnimationClasses(element, options); applyAnimationStyles(element, options);}if (animationCancelled || (isStructural && animationDetails.event !== event)) {options.domOperation(); runner.end();}if (!isValidAnimation) {clearElementAnimationState(node);}return;}event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event; markElementAnimationState(node, RUNNING_STATE); var realRunner = $$animation(element, event, animationDetails.options); runner.setHost(realRunner); notifyProgress(runner, event, 'start', {}); realRunner.done(function (status) {close(!status); var animationDetails = activeAnimationsLookup.get(node); if (animationDetails && animationDetails.counter === counter) {clearElementAnimationState(node);}notifyProgress(runner, event, 'close', {});});}); return runner; function notifyProgress(runner, event, phase, data) {runInNextPostDigestOrNow(function () {var callbacks = findCallbacks(parentNode, node, event); if (callbacks.length) {$$rAF(function () {forEach(callbacks, function (callback) {callback(element, phase, data);}); cleanupEventListeners(phase, node);});}else {cleanupEventListeners(phase, node);}}); runner.progress(event, phase, data);}function close(reject) {clearGeneratedClasses(element, options); applyAnimationClasses(element, options); applyAnimationStyles(element, options); options.domOperation(); runner.complete(!reject);}}function closeChildAnimations(node) {var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']'); forEach(children, function (child) {var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10); var animationDetails = activeAnimationsLookup.get(child); if (animationDetails) {switch (state) {case RUNNING_STATE: animationDetails.runner.end(); case PRE_DIGEST_STATE: activeAnimationsLookup.delete(child); break;}}});}function clearElementAnimationState(node) {node.removeAttribute(NG_ANIMATE_ATTR_NAME); activeAnimationsLookup.delete(node);}function areAnimationsAllowed(node, parentNode, event) {var bodyNode = $document[0].body; var rootNode = getDomNode($rootElement); var bodyNodeDetected = node === bodyNode || node.nodeName === 'HTML'; var rootNodeDetected = node === rootNode; var parentAnimationDetected = false; var elementDisabled = disabledElementsLookup.get(node); var animateChildren; var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA); if (parentHost) {parentNode = getDomNode(parentHost);}while (parentNode) {if (!rootNodeDetected) {rootNodeDetected = parentNode === rootNode;}if (parentNode.nodeType !== ELEMENT_NODE) {break;}var details = activeAnimationsLookup.get(parentNode) || {}; if (!parentAnimationDetected) {var parentNodeDisabled = disabledElementsLookup.get(parentNode); if (parentNodeDisabled === true && elementDisabled !== false) {elementDisabled = true; break;}else if (parentNodeDisabled === false) {elementDisabled = false;}parentAnimationDetected = details.structural;}if (isUndefined(animateChildren) || animateChildren === true) {var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA); if (isDefined(value)) {animateChildren = value;}}if (parentAnimationDetected && animateChildren === false) break; if (!bodyNodeDetected) {bodyNodeDetected = parentNode === bodyNode;}if (bodyNodeDetected && rootNodeDetected) {break;}if (!rootNodeDetected) {parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA); if (parentHost) {parentNode = getDomNode(parentHost); continue;}}parentNode = parentNode.parentNode;}var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true; return allowAnimation && rootNodeDetected && bodyNodeDetected;}function markElementAnimationState(node, state, details) {details = details || {}; details.state = state; node.setAttribute(NG_ANIMATE_ATTR_NAME, state); var oldValue = activeAnimationsLookup.get(node); var newValue = oldValue ? extend(oldValue, details) : details; activeAnimationsLookup.set(node, newValue);}}, ];}, ]; var $$AnimationProvider = [ '$animateProvider', function ($animateProvider) {var NG_ANIMATE_REF_ATTR = 'ng-animate-ref'; var drivers = (this.drivers = []); var RUNNER_STORAGE_KEY = '$$animationRunner'; function setRunner(element, runner) {element.data(RUNNER_STORAGE_KEY, runner);}function removeRunner(element) {element.removeData(RUNNER_STORAGE_KEY);}function getRunner(element) {return element.data(RUNNER_STORAGE_KEY);}this.$get = [ '$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler', function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {var animationQueue = []; var applyAnimationClasses = applyAnimationClassesFactory($$jqLite); function sortAnimations(animations) {var tree = {children: [] }; var i, lookup = new $$Map(); for (i = 0; i < animations.length; i++) {var animation = animations[i]; lookup.set( animation.domNode, (animations[i] = {domNode: animation.domNode, fn: animation.fn, children: [], }), );}for (i = 0; i < animations.length; i++) {processNode(animations[i]);}return flatten(tree); function processNode(entry) {if (entry.processed) return entry; entry.processed = true; var elementNode = entry.domNode; var parentNode = elementNode.parentNode; lookup.set(elementNode, entry); var parentEntry; while (parentNode) {parentEntry = lookup.get(parentNode); if (parentEntry) {if (!parentEntry.processed) {parentEntry = processNode(parentEntry);}break;}parentNode = parentNode.parentNode;}(parentEntry || tree).children.push(entry); return entry;}function flatten(tree) {var result = []; var queue = []; var i; for (i = 0; i < tree.children.length; i++) {queue.push(tree.children[i]);}var remainingLevelEntries = queue.length; var nextLevelEntries = 0; var row = []; for (i = 0; i < queue.length; i++) {var entry = queue[i]; if (remainingLevelEntries <= 0) {remainingLevelEntries = nextLevelEntries; nextLevelEntries = 0; result.push(row); row = [];}row.push(entry.fn); entry.children.forEach(function (childEntry) {nextLevelEntries++; queue.push(childEntry);}); remainingLevelEntries--;}if (row.length) {result.push(row);}return result;}}return function (element, event, options) {options = prepareAnimationOptions(options); var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0; var runner = new $$AnimateRunner({end: function () {close();}, cancel: function () {close(true);}, }); if (!drivers.length) {close(); return runner;}setRunner(element, runner); var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass)); var tempClasses = options.tempClasses; if (tempClasses) {classes += ' ' + tempClasses; options.tempClasses = null;}var prepareClassName; if (isStructural) {prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX; $$jqLite.addClass(element, prepareClassName);}animationQueue.push({element: element, classes: classes, event: event, structural: isStructural, options: options, beforeStart: beforeStart, close: close, }); element.on('$destroy', handleDestroyedElement); if (animationQueue.length > 1) return runner; $rootScope.$$postDigest(function () {var animations = []; forEach(animationQueue, function (entry) {if (getRunner(entry.element)) {animations.push(entry);}else {entry.close();}}); animationQueue.length = 0; var groupedAnimations = groupAnimations(animations); var toBeSortedAnimations = []; forEach(groupedAnimations, function (animationEntry) {toBeSortedAnimations.push({domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element), fn: function triggerAnimationStart() {animationEntry.beforeStart(); var startAnimationFn, closeFn = animationEntry.close; var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element; if (getRunner(targetElement)) {var operation = invokeFirstDriver(animationEntry); if (operation) {startAnimationFn = operation.start;}}if (!startAnimationFn) {closeFn();}else {var animationRunner = startAnimationFn(); animationRunner.done(function (status) {closeFn(!status);}); updateAnimationRunners(animationEntry, animationRunner);}}, });}); $$rAFScheduler(sortAnimations(toBeSortedAnimations));}); return runner; function getAnchorNodes(node) {var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']'; var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR); var anchors = []; forEach(items, function (node) {var attr = node.getAttribute(NG_ANIMATE_REF_ATTR); if (attr && attr.length) {anchors.push(node);}}); return anchors;}function groupAnimations(animations) {var preparedAnimations = []; var refLookup = {}; forEach(animations, function (animation, index) {var element = animation.element; var node = getDomNode(element); var event = animation.event; var enterOrMove = ['enter', 'move'].indexOf(event) >= 0; var anchorNodes = animation.structural ? getAnchorNodes(node) : []; if (anchorNodes.length) {var direction = enterOrMove ? 'to' : 'from'; forEach(anchorNodes, function (anchor) {var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR); refLookup[key] = refLookup[key] || {}; refLookup[key][direction] = {animationID: index, element: jqLite(anchor), };});}else {preparedAnimations.push(animation);}}); var usedIndicesLookup = {}; var anchorGroups = {}; forEach(refLookup, function (operations, key) {var from = operations.from; var to = operations.to; if (!from || !to) {var index = from ? from.animationID : to.animationID; var indexKey = index.toString(); if (!usedIndicesLookup[indexKey]) {usedIndicesLookup[indexKey] = true; preparedAnimations.push(animations[index]);}return;}var fromAnimation = animations[from.animationID]; var toAnimation = animations[to.animationID]; var lookupKey = from.animationID.toString(); if (!anchorGroups[lookupKey]) {var group = (anchorGroups[lookupKey] = {structural: true, beforeStart: function () {fromAnimation.beforeStart(); toAnimation.beforeStart();}, close: function () {fromAnimation.close(); toAnimation.close();}, classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes), from: fromAnimation, to: toAnimation, anchors: [], }); if (group.classes.length) {preparedAnimations.push(group);}else {preparedAnimations.push(fromAnimation); preparedAnimations.push(toAnimation);}}anchorGroups[lookupKey].anchors.push({out: from.element, in: to.element, });}); return preparedAnimations;}function cssClassesIntersection(a, b) {a = a.split(' '); b = b.split(' '); var matches = []; for (var i = 0; i < a.length; i++) {var aa = a[i]; if (aa.substring(0, 3) === 'ng-') continue; for (var j = 0; j < b.length; j++) {if (aa === b[j]) {matches.push(aa); break;}}}return matches.join(' ');}function invokeFirstDriver(animationDetails) {for (var i = drivers.length - 1; i >= 0; i--) {var driverName = drivers[i]; var factory = $injector.get(driverName); var driver = factory(animationDetails); if (driver) {return driver;}}}function beforeStart() {element.addClass(NG_ANIMATE_CLASSNAME); if (tempClasses) {$$jqLite.addClass(element, tempClasses);}if (prepareClassName) {$$jqLite.removeClass(element, prepareClassName); prepareClassName = null;}}function updateAnimationRunners(animation, newRunner) {if (animation.from && animation.to) {update(animation.from.element); update(animation.to.element);}else {update(animation.element);}function update(element) {var runner = getRunner(element); if (runner) runner.setHost(newRunner);}}function handleDestroyedElement() {var runner = getRunner(element); if (runner && (event !== 'leave' || !options.$$domOperationFired)) {runner.end();}}function close(rejected) {element.off('$destroy', handleDestroyedElement); removeRunner(element); applyAnimationClasses(element, options); applyAnimationStyles(element, options); options.domOperation(); if (tempClasses) {$$jqLite.removeClass(element, tempClasses);}element.removeClass(NG_ANIMATE_CLASSNAME); runner.complete(!rejected);}};}, ];}, ]; var ngAnimateSwapDirective = [ '$animate', '$rootScope', function ($animate, $rootScope) {return {restrict: 'A', transclude: 'element', terminal: true, priority: 600, link: function (scope, $element, attrs, ctrl, $transclude) {var previousElement, previousScope; scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function (value) {if (previousElement) {$animate.leave(previousElement);}if (previousScope) {previousScope.$destroy(); previousScope = null;}if (value || value === 0) {previousScope = scope.$new(); $transclude(previousScope, function (element) {previousElement = element; $animate.enter(element, null, $element);});}});}, };}, ]; var copy; var extend; var forEach; var isArray; var isDefined; var isElement; var isFunction; var isObject; var isString; var isUndefined; var jqLite; var noop; angular .module('ngAnimate', [], function initAngularHelpers() {noop = angular.noop; copy = angular.copy; extend = angular.extend; jqLite = angular.element; forEach = angular.forEach; isArray = angular.isArray; isString = angular.isString; isObject = angular.isObject; isUndefined = angular.isUndefined; isDefined = angular.isDefined; isFunction = angular.isFunction; isElement = angular.isElement;}) .info({angularVersion: '1.6.6' }) .directive('ngAnimateSwap', ngAnimateSwapDirective) .directive('ngAnimateChildren', $$AnimateChildrenDirective) .factory('$$rAFScheduler', $$rAFSchedulerFactory) .provider('$$animateQueue', $$AnimateQueueProvider) .provider('$$animation', $$AnimationProvider) .provider('$animateCss', $AnimateCssProvider) .provider('$$animateCssDriver', $$AnimateCssDriverProvider) .provider('$$animateJs', $$AnimateJsProvider) .provider('$$animateJsDriver', $$AnimateJsDriverProvider);})(window, window.angular); (function (window, angular, undefined) {'use strict'; (function () {'use strict'; angular.module('ngMaterial', [ 'ng', 'ngAnimate', 'ngAria', 'material.core', 'material.core.gestures', 'material.core.interaction', 'material.core.layout', 'material.core.meta', 'material.core.theming.palette', 'material.core.theming', 'material.core.animate', 'material.components.autocomplete', 'material.components.backdrop', 'material.components.bottomSheet', 'material.components.button', 'material.components.card', 'material.components.chips', 'material.components.checkbox', 'material.components.colors', 'material.components.content', 'material.components.datepicker', 'material.components.dialog', 'material.components.divider', 'material.components.fabActions', 'material.components.fabShared', 'material.components.fabSpeedDial', 'material.components.fabToolbar', 'material.components.icon', 'material.components.gridList', 'material.components.input', 'material.components.list', 'material.components.menu', 'material.components.menuBar', 'material.components.navBar', 'material.components.panel', 'material.components.progressCircular', 'material.components.progressLinear', 'material.components.radioButton', 'material.components.select', 'material.components.showHide', 'material.components.sidenav', 'material.components.slider', 'material.components.sticky', 'material.components.subheader', 'material.components.swipe', 'material.components.switch', 'material.components.tabs', 'material.components.toast', 'material.components.toolbar', 'material.components.tooltip', 'material.components.truncate', 'material.components.virtualRepeat', 'material.components.whiteframe', ]);})(); (function () {'use strict'; DetectNgTouch.$inject = ['$log', '$injector']; MdCoreConfigure.$inject = ['$provide', '$mdThemingProvider']; rAFDecorator.$inject = ['$delegate']; qDecorator.$inject = ['$delegate']; angular .module('material.core', [ 'ngAnimate', 'material.core.animate', 'material.core.layout', 'material.core.interaction', 'material.core.gestures', 'material.core.theming', ]) .config(MdCoreConfigure) .run(DetectNgTouch); function DetectNgTouch($log, $injector) {if ($injector.has('$swipe')) {var msg = '' + 'You are using the ngTouch module. \n' + 'AngularJS Material already has mobile click, tap, and swipe support... \n' + 'ngTouch is not supported with AngularJS Material!'; $log.warn(msg);}}function MdCoreConfigure($provide, $mdThemingProvider) {$provide.decorator('$$rAF', ['$delegate', rAFDecorator]); $provide.decorator('$q', ['$delegate', qDecorator]); $mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('pink').warnPalette('deep-orange').backgroundPalette('grey');}function rAFDecorator($delegate) {$delegate.throttle = function (cb) {var queuedArgs, alreadyQueued, queueCb, context; return function debounced() {queuedArgs = arguments; context = this; queueCb = cb; if (!alreadyQueued) {alreadyQueued = true; $delegate(function () {queueCb.apply(context, Array.prototype.slice.call(queuedArgs)); alreadyQueued = false;});}};}; return $delegate;}function qDecorator($delegate) {if (!$delegate.resolve) {$delegate.resolve = $delegate.when;}return $delegate;}})(); (function () {'use strict'; MdAutofocusDirective.$inject = ['$parse']; angular .module('material.core') .directive('mdAutofocus', MdAutofocusDirective) .directive('mdAutoFocus', MdAutofocusDirective) .directive('mdSidenavFocus', MdAutofocusDirective); function MdAutofocusDirective($parse) {return {restrict: 'A', link: {pre: preLink, }, }; function preLink(scope, element, attr) {var attrExp = attr.mdAutoFocus || attr.mdAutofocus || attr.mdSidenavFocus; updateExpression($parse(attrExp)(scope)); if (attrExp) {scope.$watch(attrExp, updateExpression);}function updateExpression(value) {if (angular.isUndefined(value)) {value = true;}element.toggleClass('md-autofocus', !!value);}}}})(); (function () {'use strict'; angular.module('material.core').factory('$mdColorUtil', ColorUtilFactory); function ColorUtilFactory() {function hexToRgba(color) {var hex = color[0] === '#' ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), green = hex.substr(dig, dig), blue = hex.substr(dig * 2); if (dig === 1) {red += red; green += green; blue += blue;}return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';}function rgbaToHex(color) {color = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i); var hex = color && color.length === 4 ? '#' + ('0' + parseInt(color[1], 10).toString(16)).slice(-2) + ('0' + parseInt(color[2], 10).toString(16)).slice(-2) + ('0' + parseInt(color[3], 10).toString(16)).slice(-2) : ''; return hex.toUpperCase();}function rgbToRgba(color) {return color.replace(')', ', 0.1)').replace('(', 'a(');}function rgbaToRgb(color) {return color ? color.replace('rgba', 'rgb').replace(/,[^\),]+\)/, ')') : 'rgb(0,0,0)';}return {rgbaToHex: rgbaToHex, hexToRgba: hexToRgba, rgbToRgba: rgbToRgba, rgbaToRgb: rgbaToRgb, };}})(); (function () {'use strict'; angular.module('material.core').factory('$mdConstant', MdConstantFactory); function MdConstantFactory() {var prefixTestEl = document.createElement('div'); var vendorPrefix = getVendorPrefix(prefixTestEl); var isWebkit = /webkit/i.test(vendorPrefix); var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g; function vendorProperty(name) {var prefixedName = vendorPrefix + '-' + name; var ucPrefix = camelCase(prefixedName); var lcPrefix = ucPrefix.charAt(0).toLowerCase() + ucPrefix.substring(1); return hasStyleProperty(prefixTestEl, name) ? name : hasStyleProperty(prefixTestEl, ucPrefix) ? ucPrefix : hasStyleProperty(prefixTestEl, lcPrefix) ? lcPrefix : name;}function hasStyleProperty(testElement, property) {return angular.isDefined(testElement.style[property]);}function camelCase(input) {return input.replace(SPECIAL_CHARS_REGEXP, function (matches, separator, letter, offset) {return offset ? letter.toUpperCase() : letter;});}function getVendorPrefix(testElement) {var prop, match; var vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/; for (prop in testElement.style) {if ((match = vendorRegex.exec(prop))) {return match[0];}}}var self = {isInputKey: function (e) {return e.keyCode >= 31 && e.keyCode <= 90;}, isNumPadKey: function (e) {return 3 === e.location && e.keyCode >= 97 && e.keyCode <= 105;}, isMetaKey: function (e) {return e.keyCode >= 91 && e.keyCode <= 93;}, isFnLockKey: function (e) {return e.keyCode >= 112 && e.keyCode <= 145;}, isNavigationKey: function (e) {var kc = self.KEY_CODE, NAVIGATION_KEYS = [kc.SPACE, kc.ENTER, kc.UP_ARROW, kc.DOWN_ARROW]; return NAVIGATION_KEYS.indexOf(e.keyCode) != -1;}, hasModifierKey: function (e) {return e.ctrlKey || e.metaKey || e.altKey;}, ELEMENT_MAX_PIXELS: 1533917, BEFORE_NG_ARIA: 210, KEY_CODE: {COMMA: 188, SEMICOLON: 186, ENTER: 13, ESCAPE: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT_ARROW: 37, UP_ARROW: 38, RIGHT_ARROW: 39, DOWN_ARROW: 40, TAB: 9, BACKSPACE: 8, DELETE: 46, }, CSS: {TRANSITIONEND: 'transitionend' + (isWebkit ? ' webkitTransitionEnd' : ''), ANIMATIONEND: 'animationend' + (isWebkit ? ' webkitAnimationEnd' : ''), TRANSFORM: vendorProperty('transform'), TRANSFORM_ORIGIN: vendorProperty('transformOrigin'), TRANSITION: vendorProperty('transition'), TRANSITION_DURATION: vendorProperty('transitionDuration'), ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'), ANIMATION_DURATION: vendorProperty('animationDuration'), ANIMATION_NAME: vendorProperty('animationName'), ANIMATION_TIMING: vendorProperty('animationTimingFunction'), ANIMATION_DIRECTION: vendorProperty('animationDirection'), }, MEDIA: {xs: '(max-width: 599px)', 'gt-xs': '(min-width: 600px)', sm: '(min-width: 600px) and (max-width: 959px)', 'gt-sm': '(min-width: 960px)', md: '(min-width: 960px) and (max-width: 1279px)', 'gt-md': '(min-width: 1280px)', lg: '(min-width: 1280px) and (max-width: 1919px)', 'gt-lg': '(min-width: 1920px)', xl: '(min-width: 1920px)', landscape: '(orientation: landscape)', portrait: '(orientation: portrait)', print: 'print', }, MEDIA_PRIORITY: ['xl', 'gt-lg', 'lg', 'gt-md', 'md', 'gt-sm', 'sm', 'gt-xs', 'xs', 'landscape', 'portrait', 'print'], }; return self;}})(); (function () {'use strict'; angular.module('material.core').config([ '$provide', function ($provide) {$provide.decorator('$mdUtil', [ '$delegate', function ($delegate) {$delegate.iterator = MdIterator; return $delegate;}, ]);}, ]); function MdIterator(items, reloop) {var trueFn = function () {return true;}; if (items && !angular.isArray(items)) {items = Array.prototype.slice.call(items);}reloop = !!reloop; var _items = items || []; return {items: getItems, count: count, inRange: inRange, contains: contains, indexOf: indexOf, itemAt: itemAt, findBy: findBy, add: add, remove: remove, first: first, last: last, next: angular.bind(null, findSubsequentItem, false), previous: angular.bind(null, findSubsequentItem, true), hasPrevious: hasPrevious, hasNext: hasNext, }; function getItems() {return [].concat(_items);}function count() {return _items.length;}function inRange(index) {return _items.length && index > -1 && index < _items.length;}function hasNext(item) {return item ? inRange(indexOf(item) + 1) : false;}function hasPrevious(item) {return item ? inRange(indexOf(item) - 1) : false;}function itemAt(index) {return inRange(index) ? _items[index] : null;}function findBy(key, val) {return _items.filter(function (item) {return item[key] === val;});}function add(item, index) {if (!item) return -1; if (!angular.isNumber(index)) {index = _items.length;}_items.splice(index, 0, item); return indexOf(item);}function remove(item) {if (contains(item)) {_items.splice(indexOf(item), 1);}}function indexOf(item) {return _items.indexOf(item);}function contains(item) {return item && indexOf(item) > -1;}function first() {return _items.length ? _items[0] : null;}function last() {return _items.length ? _items[_items.length - 1] : null;}function findSubsequentItem(backwards, item, validate, limit) {validate = validate || trueFn; var curIndex = indexOf(item); while (true) {if (!inRange(curIndex)) return null; var nextIndex = curIndex + (backwards ? -1 : 1); var foundItem = null; if (inRange(nextIndex)) {foundItem = _items[nextIndex];}else if (reloop) {foundItem = backwards ? last() : first(); nextIndex = indexOf(foundItem);}if (foundItem === null || nextIndex === limit) return null; if (validate(foundItem)) return foundItem; if (angular.isUndefined(limit)) limit = nextIndex; curIndex = nextIndex;}}}})(); (function () {'use strict'; mdMediaFactory.$inject = ['$mdConstant', '$rootScope', '$window']; angular.module('material.core').factory('$mdMedia', mdMediaFactory); function mdMediaFactory($mdConstant, $rootScope, $window) {var queries = {}; var mqls = {}; var results = {}; var normalizeCache = {}; $mdMedia.getResponsiveAttribute = getResponsiveAttribute; $mdMedia.getQuery = getQuery; $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes; return $mdMedia; function $mdMedia(query) {var validated = queries[query]; if (angular.isUndefined(validated)) {validated = queries[query] = validate(query);}var result = results[validated]; if (angular.isUndefined(result)) {result = add(validated);}return result;}function validate(query) {return $mdConstant.MEDIA[query] || (query.charAt(0) !== '(' ? '(' + query + ')' : query);}function add(query) {var result = mqls[query]; if (!result) {result = mqls[query] = $window.matchMedia(query);}result.addListener(onQueryChange); return (results[result.media] = !!result.matches);}function onQueryChange(query) {$rootScope.$evalAsync(function () {results[query.media] = !!query.matches;});}function getQuery(name) {return mqls[name];}function getResponsiveAttribute(attrs, attrName) {for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {var mediaName = $mdConstant.MEDIA_PRIORITY[i]; if (!mqls[queries[mediaName]].matches) {continue;}var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName); if (attrs[normalizedName]) {return attrs[normalizedName];}}return attrs[getNormalizedName(attrs, attrName)];}function watchResponsiveAttributes(attrNames, attrs, watchFn) {var unwatchFns = []; attrNames.forEach(function (attrName) {var normalizedName = getNormalizedName(attrs, attrName); if (angular.isDefined(attrs[normalizedName])) {unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));}for (var mediaName in $mdConstant.MEDIA) {normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName); if (angular.isDefined(attrs[normalizedName])) {unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));}}}); return function unwatch() {unwatchFns.forEach(function (fn) {fn();});};}function getNormalizedName(attrs, attrName) {return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));}}})(); (function () {'use strict'; angular.module('material.core').config([ '$provide', function ($provide) {$provide.decorator('$mdUtil', [ '$delegate', function ($delegate) {$delegate.prefixer = MdPrefixer; return $delegate;}, ]);}, ]); function MdPrefixer(initialAttributes, buildSelector) {var PREFIXES = ['data', 'x']; if (initialAttributes) {return buildSelector ? _buildSelector(initialAttributes) : _buildList(initialAttributes);}return {buildList: _buildList, buildSelector: _buildSelector, hasAttribute: _hasAttribute, removeAttribute: _removeAttribute, }; function _buildList(attributes) {attributes = angular.isArray(attributes) ? attributes : [attributes]; attributes.forEach(function (item) {PREFIXES.forEach(function (prefix) {attributes.push(prefix + '-' + item);});}); return attributes;}function _buildSelector(attributes) {attributes = angular.isArray(attributes) ? attributes : [attributes]; return _buildList(attributes) .map(function (item) {return '[' + item + ']';}) .join(',');}function _hasAttribute(element, attribute) {element = _getNativeElement(element); if (!element) {return false;}var prefixedAttrs = _buildList(attribute); for (var i = 0; i < prefixedAttrs.length; i++) {if (element.hasAttribute(prefixedAttrs[i])) {return true;}}return false;}function _removeAttribute(element, attribute) {element = _getNativeElement(element); if (!element) {return;}_buildList(attribute).forEach(function (prefixedAttribute) {element.removeAttribute(prefixedAttribute);});}function _getNativeElement(element) {element = element[0] || element; if (element.nodeType) {return element;}}}})(); (function () {'use strict'; UtilFactory.$inject = ['$document', '$timeout', '$compile', '$rootScope', '$$mdAnimate', '$interpolate', '$log', '$rootElement', '$window', '$$rAF']; var nextUniqueId = 0; angular.module('material.core').factory('$mdUtil', UtilFactory); function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window, $$rAF) {var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = startSymbol === '{{' && endSymbol === '}}'; var hasComputedStyle = function (target, key, expectedVal) {var hasValue = false; if (target && target.length) {var computedStyles = $window.getComputedStyle(target[0]); hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);}return hasValue;}; function validateCssValue(value) {return !value ? '0' : hasPx(value) || hasPercent(value) ? value : value + 'px';}function hasPx(value) {return String(value).indexOf('px') > -1;}function hasPercent(value) {return String(value).indexOf('%') > -1;}var $mdUtil = {dom: {}, now: window.performance && window.performance.now ? angular.bind(window.performance, window.performance.now) : Date.now || function () {return new Date().getTime();}, getModelOption: function (ngModelCtrl, optionName) {if (!ngModelCtrl.$options) {return;}var $options = ngModelCtrl.$options; return $options.getOption ? $options.getOption(optionName) : $options[optionName];}, bidi: function (element, property, lValue, rValue) {var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl'); if (arguments.length == 0) return ltr ? 'ltr' : 'rtl'; var elem = angular.element(element); if (ltr && angular.isDefined(lValue)) {elem.css(property, validateCssValue(lValue));}else if (!ltr && angular.isDefined(rValue)) {elem.css(property, validateCssValue(rValue));}}, bidiProperty: function (element, lProperty, rProperty, value) {var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl'); var elem = angular.element(element); if (ltr && angular.isDefined(lProperty)) {elem.css(lProperty, validateCssValue(value)); elem.css(rProperty, '');}else if (!ltr && angular.isDefined(rProperty)) {elem.css(rProperty, validateCssValue(value)); elem.css(lProperty, '');}}, clientRect: function (element, offsetParent, isOffsetRect) {var node = getNode(element); offsetParent = getNode(offsetParent || node.offsetParent || document.body); var nodeRect = node.getBoundingClientRect(); var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {left: 0, top: 0, width: 0, height: 0 }; return {left: nodeRect.left - offsetRect.left, top: nodeRect.top - offsetRect.top, width: nodeRect.width, height: nodeRect.height, };}, offsetRect: function (element, offsetParent) {return $mdUtil.clientRect(element, offsetParent, true);}, nodesToArray: function (nodes) {nodes = nodes || []; var results = []; for (var i = 0; i < nodes.length; ++i) {results.push(nodes.item(i));}return results;}, getViewportTop: function () {return window.scrollY || window.pageYOffset || 0;}, findFocusTarget: function (containerEl, attributeVal) {var AUTO_FOCUS = this.prefixer('md-autofocus', true); var elToFocus; elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS); if (!elToFocus && attributeVal != AUTO_FOCUS) {elToFocus = scanForFocusable(containerEl, this.prefixer('md-auto-focus', true)); if (!elToFocus) {elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);}}return elToFocus; function scanForFocusable(target, selector) {var elFound, items = target[0].querySelectorAll(selector); if (items && items.length) {items.length && angular.forEach(items, function (it) {it = angular.element(it); var isFocusable = it.hasClass('md-autofocus'); if (isFocusable) elFound = it;});}return elFound;}}, disableScrollAround: function (element, parent, options) {options = options || {}; $mdUtil.disableScrollAround._count = Math.max(0, $mdUtil.disableScrollAround._count || 0); $mdUtil.disableScrollAround._count++; if ($mdUtil.disableScrollAround._restoreScroll) {return $mdUtil.disableScrollAround._restoreScroll;}var body = $document[0].body; var restoreBody = disableBodyScroll(); var restoreElement = disableElementScroll(parent); return ($mdUtil.disableScrollAround._restoreScroll = function () {if (--$mdUtil.disableScrollAround._count <= 0) {restoreBody(); restoreElement(); delete $mdUtil.disableScrollAround._restoreScroll;}}); function disableElementScroll(element) {element = angular.element(element || body); var scrollMask; if (options.disableScrollMask) {scrollMask = element;}else {scrollMask = angular.element('<div class="md-scroll-mask">' + ' <div class="md-scroll-mask-bar"></div>' + '</div>'); element.append(scrollMask);}scrollMask.on('wheel', preventDefault); scrollMask.on('touchmove', preventDefault); return function restoreElementScroll() {scrollMask.off('wheel'); scrollMask.off('touchmove'); if (!options.disableScrollMask && scrollMask[0].parentNode) {scrollMask[0].parentNode.removeChild(scrollMask[0]);}}; function preventDefault(e) {e.preventDefault();}}function disableBodyScroll() {var documentElement = $document[0].documentElement; var prevDocumentStyle = documentElement.style.cssText || ''; var prevBodyStyle = body.style.cssText || ''; var viewportTop = $mdUtil.getViewportTop(); var clientWidth = body.clientWidth; var hasVerticalScrollbar = body.scrollHeight > body.clientHeight + 1; var scrollElement = documentElement.scrollTop > 0 ? documentElement : body; if (hasVerticalScrollbar) {angular.element(body).css({position: 'fixed', width: '100%', top: -viewportTop + 'px', });}if (body.clientWidth < clientWidth) {body.style.overflow = 'hidden';}if (hasVerticalScrollbar) {documentElement.style.overflowY = 'scroll';}return function restoreScroll() {body.style.cssText = prevBodyStyle; documentElement.style.cssText = prevDocumentStyle; scrollElement.scrollTop = viewportTop;};}}, enableScrolling: function () {var restoreFn = this.disableScrollAround._restoreScroll; restoreFn && restoreFn();}, floatingScrollbars: function () {if (this.floatingScrollbars.cached === undefined) {var tempNode = angular.element('<div><div></div></div>').css({width: '100%', 'z-index': -1, position: 'absolute', height: '35px', 'overflow-y': 'scroll', }); tempNode.children().css('height', '60px'); $document[0].body.appendChild(tempNode[0]); this.floatingScrollbars.cached = tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth; tempNode.remove();}return this.floatingScrollbars.cached;}, forceFocus: function (element) {var node = element[0] || element; document.addEventListener( 'click', function focusOnClick(ev) {if (ev.target === node && ev.$focus) {node.focus(); ev.stopImmediatePropagation(); ev.preventDefault(); node.removeEventListener('click', focusOnClick);}}, true, ); var newEvent = document.createEvent('MouseEvents'); newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null); newEvent.$material = true; newEvent.$focus = true; node.dispatchEvent(newEvent);}, createBackdrop: function (scope, addClass) {return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);}, supplant: function (template, values, pattern) {pattern = pattern || /\{([^\{\}]*)\}/g; return template.replace(pattern, function (a, b) {var p = b.split('.'), r = values; try {for (var s in p) {if (p.hasOwnProperty(s)) {r = r[p[s]];}}}catch (e) {r = a;}return typeof r === 'string' || typeof r === 'number' ? r : a;});}, fakeNgModel: function () {return {$fake: true, $setTouched: angular.noop, $setViewValue: function (value) {this.$viewValue = value; this.$render(value); this.$viewChangeListeners.forEach(function (cb) {cb();});}, $isEmpty: function (value) {return ('' + value).length === 0;}, $parsers: [], $formatters: [], $viewChangeListeners: [], $render: angular.noop, };}, debounce: function (func, wait, scope, invokeApply) {var timer; return function debounced() {var context = scope, args = Array.prototype.slice.call(arguments); $timeout.cancel(timer); timer = $timeout( function () {timer = undefined; func.apply(context, args);}, wait || 10, invokeApply, );};}, throttle: function throttle(func, delay) {var recent; return function throttled() {var context = this; var args = arguments; var now = $mdUtil.now(); if (!recent || now - recent > delay) {func.apply(context, args); recent = now;}};}, time: function time(cb) {var start = $mdUtil.now(); cb(); return $mdUtil.now() - start;}, valueOnUse: function (scope, key, getter) {var value = null, args = Array.prototype.slice.call(arguments); var params = args.length > 3 ? args.slice(3) : []; Object.defineProperty(scope, key, {get: function () {if (value === null) value = getter.apply(scope, params); return value;}, });}, nextUid: function () {return '' + nextUniqueId++;}, disconnectScope: function disconnectScope(scope) {if (!scope) return; if (scope.$root === scope) return; if (scope.$$destroyed) return; var parent = scope.$parent; scope.$$disconnected = true; if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling; if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling; if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling; if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling; scope.$$nextSibling = scope.$$prevSibling = null;}, reconnectScope: function reconnectScope(scope) {if (!scope) return; if (scope.$root === scope) return; if (!scope.$$disconnected) return; var child = scope; var parent = child.$parent; child.$$disconnected = false; child.$$prevSibling = parent.$$childTail; if (parent.$$childHead) {parent.$$childTail.$$nextSibling = child; parent.$$childTail = child;}else {parent.$$childHead = parent.$$childTail = child;}}, getClosest: function getClosest(el, validateWith, onlyParent) {if (angular.isString(validateWith)) {var tagName = validateWith.toUpperCase(); validateWith = function (el) {return el.nodeName.toUpperCase() === tagName;};}if (el instanceof angular.element) el = el[0]; if (onlyParent) el = el.parentNode; if (!el) return null; do {if (validateWith(el)) {return el;}}while ((el = el.parentNode)); return null;}, elementContains: function (node, child) {var hasContains = window.Node && window.Node.prototype && Node.prototype.contains; var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function (arg) {return node === child || !!(this.compareDocumentPosition(arg) & 16);}); return findFn(child);}, extractElementByName: function (element, nodeName, scanDeep, warnNotFound) {var found = scanTree(element); if (!found && !!warnNotFound) {$log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));}return angular.element(found || element); function scanTree(element) {return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);}function scanLevel(element) {if (element) {for (var i = 0, len = element.length; i < len; i++) {if (element[i].nodeName.toLowerCase() === nodeName) {return element[i];}}}return null;}function scanChildren(element) {var found; if (element) {for (var i = 0, len = element.length; i < len; i++) {var target = element[i]; if (!found) {for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) {found = found || scanTree([target.childNodes[j]]);}}}}return found;}}, initOptionalProperties: function (scope, attr, defaults) {defaults = defaults || {}; angular.forEach(scope.$$isolateBindings, function (binding, key) {if (binding.optional && angular.isUndefined(scope[key])) {var attrIsDefined = angular.isDefined(attr[binding.attrName]); scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;}});}, nextTick: function (callback, digest, scope) {var nextTick = $mdUtil.nextTick; var timeout = nextTick.timeout; var queue = nextTick.queue || []; queue.push({scope: scope, callback: callback }); if (digest == null) digest = true; nextTick.digest = nextTick.digest || digest; nextTick.queue = queue; return timeout || (nextTick.timeout = $timeout(processQueue, 0, false)); function processQueue() {var queue = nextTick.queue; var digest = nextTick.digest; nextTick.queue = []; nextTick.timeout = null; nextTick.digest = false; queue.forEach(function (queueItem) {var skip = queueItem.scope && queueItem.scope.$$destroyed; if (!skip) {queueItem.callback();}}); if (digest) $rootScope.$digest();}}, processTemplate: function (template) {if (usesStandardSymbols) {return template;}else {if (!template || !angular.isString(template)) return template; return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);}}, getParentWithPointerEvents: function (element) {var parent = element.parent(); while (hasComputedStyle(parent, 'pointer-events', 'none')) {parent = parent.parent();}return parent;}, getNearestContentElement: function (element) {var current = element.parent()[0]; while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {current = current.parentNode;}return current;}, checkStickySupport: function () {var stickyProp; var testEl = angular.element('<div>'); $document[0].body.appendChild(testEl[0]); var stickyProps = ['sticky', '-webkit-sticky']; for (var i = 0; i < stickyProps.length; ++i) {testEl.css({position: stickyProps[i], top: 0, 'z-index': 2, }); if (testEl.css('position') == stickyProps[i]) {stickyProp = stickyProps[i]; break;}}testEl.remove(); return stickyProp;}, parseAttributeBoolean: function (value, negatedCheck) {return value === '' || (!!value && (negatedCheck === false || (value !== 'false' && value !== '0')));}, hasComputedStyle: hasComputedStyle, isParentFormSubmitted: function (element) {var parent = $mdUtil.getClosest(element, 'form'); var form = parent ? angular.element(parent).controller('form') : null; return form ? form.$submitted : false;}, animateScrollTo: function (element, scrollEnd, duration) {var scrollStart = element.scrollTop; var scrollChange = scrollEnd - scrollStart; var scrollingDown = scrollStart < scrollEnd; var startTime = $mdUtil.now(); $$rAF(scrollChunk); function scrollChunk() {var newPosition = calculateNewPosition(); element.scrollTop = newPosition; if (scrollingDown ? newPosition < scrollEnd : newPosition > scrollEnd) {$$rAF(scrollChunk);}}function calculateNewPosition() {var easeDuration = duration || 1000; var currentTime = $mdUtil.now() - startTime; return ease(currentTime, scrollStart, scrollChange, easeDuration);}function ease(currentTime, start, change, duration) {if (currentTime > duration) {return start + change;}var ts = (currentTime /= duration) * currentTime; var tc = ts * currentTime; return start + change * (-2 * tc + 3 * ts);}}, uniq: function (array) {if (!array) {return;}return array.filter(function (value, index, self) {return self.indexOf(value) === index;});}, }; $mdUtil.dom.animator = $$mdAnimate($mdUtil); return $mdUtil; function getNode(el) {return el[0] || el;}}angular.element.prototype.focus = angular.element.prototype.focus || function () {if (this.length) {this[0].focus();}return this;}; angular.element.prototype.blur = angular.element.prototype.blur || function () {if (this.length) {this[0].blur();}return this;};})(); (function () {'use strict'; MdAriaService.$inject = ['$$rAF', '$log', '$window', '$interpolate']; angular.module('material.core').provider('$mdAria', MdAriaProvider); function MdAriaProvider() {var config = {showWarnings: true, }; return {disableWarnings: disableWarnings, $get: [ '$$rAF', '$log', '$window', '$interpolate', function ($$rAF, $log, $window, $interpolate) {return MdAriaService.apply(config, arguments);}, ], }; function disableWarnings() {config.showWarnings = false;}}function MdAriaService($$rAF, $log, $window, $interpolate) {var showWarnings = this.showWarnings; return {expect: expect, expectAsync: expectAsync, expectWithText: expectWithText, expectWithoutText: expectWithoutText, getText: getText, hasAriaLabel: hasAriaLabel, parentHasAriaLabel: parentHasAriaLabel, }; function expect(element, attrName, defaultValue) {var node = angular.element(element)[0] || element; if (node && (!node.hasAttribute(attrName) || node.getAttribute(attrName).length === 0) && !childHasAttribute(node, attrName)) {defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : ''; if (defaultValue.length) {element.attr(attrName, defaultValue);}else if (showWarnings) {$log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);}}}function expectAsync(element, attrName, defaultValueGetter) {$$rAF(function () {expect(element, attrName, defaultValueGetter());});}function expectWithText(element, attrName) {var content = getText(element) || ''; var hasBinding = content.indexOf($interpolate.startSymbol()) > -1; if (hasBinding) {expectAsync(element, attrName, function () {return getText(element);});}else {expect(element, attrName, content);}}function expectWithoutText(element, attrName) {var content = getText(element); var hasBinding = content.indexOf($interpolate.startSymbol()) > -1; if (!hasBinding && !content) {expect(element, attrName, content);}}function getText(element) {element = element[0] || element; var walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false); var text = ''; var node; while ((node = walker.nextNode())) {if (!isAriaHiddenNode(node)) {text += node.textContent;}}return text.trim() || ''; function isAriaHiddenNode(node) {while (node.parentNode && (node = node.parentNode) !== element) {if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {return true;}}}}function childHasAttribute(node, attrName) {var hasChildren = node.hasChildNodes(), hasAttr = false; function isHidden(el) {var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el); return style.display === 'none';}if (hasChildren) {var children = node.childNodes; for (var i = 0; i < children.length; i++) {var child = children[i]; if (child.nodeType === 1 && child.hasAttribute(attrName)) {if (!isHidden(child)) {hasAttr = true;}}}}return hasAttr;}function hasAriaLabel(element) {var node = angular.element(element)[0] || element; if (!node.hasAttribute) {return false;}return node.hasAttribute('aria-label') || node.hasAttribute('aria-labelledby') || node.hasAttribute('aria-describedby');}function parentHasAriaLabel(element, level) {level = level || 1; var node = angular.element(element)[0] || element; if (!node.parentNode) {return false;}if (performCheck(node.parentNode)) {return true;}level--; if (level) {return parentHasAriaLabel(node.parentNode, level);}return false; function performCheck(parentNode) {if (!hasAriaLabel(parentNode)) {return false;}if (parentNode.hasAttribute('role')) {switch (parentNode.getAttribute('role').toLowerCase()) {case 'command': case 'definition': case 'directory': case 'grid': case 'list': case 'listitem': case 'log': case 'marquee': case 'menu': case 'menubar': case 'note': case 'presentation': case 'separator': case 'scrollbar': case 'status': case 'tablist': return false;}}switch (parentNode.tagName.toLowerCase()) {case 'abbr': case 'acronym': case 'address': case 'applet': case 'audio': case 'b': case 'bdi': case 'bdo': case 'big': case 'blockquote': case 'br': case 'canvas': case 'caption': case 'center': case 'cite': case 'code': case 'col': case 'data': case 'dd': case 'del': case 'dfn': case 'dir': case 'div': case 'dl': case 'em': case 'embed': case 'fieldset': case 'figcaption': case 'font': case 'h1': case 'h2': case 'h3': case 'h4': case 'h5': case 'h6': case 'hgroup': case 'html': case 'i': case 'ins': case 'isindex': case 'kbd': case 'keygen': case 'label': case 'legend': case 'li': case 'map': case 'mark': case 'menu': case 'object': case 'ol': case 'output': case 'pre': case 'presentation': case 'q': case 'rt': case 'ruby': case 'samp': case 'small': case 'source': case 'span': case 'status': case 'strike': case 'strong': case 'sub': case 'sup': case 'svg': case 'tbody': case 'td': case 'th': case 'thead': case 'time': case 'tr': case 'track': case 'tt': case 'ul': case 'var': return false;}return true;}}}})(); (function () {'use strict'; angular.module('material.core').provider('$mdCompiler', MdCompilerProvider); MdCompilerProvider.$inject = ['$compileProvider']; function MdCompilerProvider($compileProvider) {var provider = this; var respectPreAssignBindingsEnabled = false; this.respectPreAssignBindingsEnabled = function (respected) {if (angular.isDefined(respected)) {respectPreAssignBindingsEnabled = respected; return this;}return respectPreAssignBindingsEnabled;}; function getPreAssignBindingsEnabled() {if (!respectPreAssignBindingsEnabled) {return true;}if (typeof $compileProvider.preAssignBindingsEnabled === 'function') {return $compileProvider.preAssignBindingsEnabled();}if (angular.version.major === 1 && angular.version.minor < 6) {return true;}return false;}this.$get = [ '$q', '$templateRequest', '$injector', '$compile', '$controller', function ($q, $templateRequest, $injector, $compile, $controller) {return new MdCompilerService($q, $templateRequest, $injector, $compile, $controller);}, ]; function MdCompilerService($q, $templateRequest, $injector, $compile, $controller) {this.$q = $q; this.$templateRequest = $templateRequest; this.$injector = $injector; this.$compile = $compile; this.$controller = $controller;}MdCompilerService.prototype.compile = function (options) {if (options.contentElement) {return this._prepareContentElement(options);}else {return this._compileTemplate(options);}}; MdCompilerService.prototype._prepareContentElement = function (options) {var contentElement = this._fetchContentElement(options); return this.$q.resolve({element: contentElement.element, cleanup: contentElement.restore, locals: {}, link: function () {return contentElement.element;}, });}; MdCompilerService.prototype._compileTemplate = function (options) {var self = this; var templateUrl = options.templateUrl; var template = options.template || ''; var resolve = angular.extend({}, options.resolve); var locals = angular.extend({}, options.locals); var transformTemplate = options.transformTemplate || angular.identity; angular.forEach(resolve, function (value, key) {if (angular.isString(value)) {resolve[key] = self.$injector.get(value);}else {resolve[key] = self.$injector.invoke(value);}}); angular.extend(resolve, locals); if (templateUrl) {resolve.$$ngTemplate = this.$templateRequest(templateUrl);}else {resolve.$$ngTemplate = this.$q.when(template);}return this.$q.all(resolve).then(function (locals) {var template = transformTemplate(locals.$$ngTemplate, options); var element = options.element || angular.element('<div>').html(template.trim()).contents(); return self._compileElement(locals, element, options);});}; MdCompilerService.prototype._compileElement = function (locals, element, options) {var self = this; var ngLinkFn = this.$compile(element); var compileData = {element: element, cleanup: element.remove.bind(element), locals: locals, link: linkFn, }; function linkFn(scope) {locals.$scope = scope; if (options.controller) {var injectLocals = angular.extend({}, locals, {$element: element, }); var ctrl = self._createController(options, injectLocals, locals); element.data('$ngControllerController', ctrl); element.children().data('$ngControllerController', ctrl); compileData.controller = ctrl;}return ngLinkFn(scope);}return compileData;}; MdCompilerService.prototype._createController = function (options, injectLocals, locals) {var invokeCtrl = this.$controller(options.controller, injectLocals, true, options.controllerAs); if (getPreAssignBindingsEnabled() && options.bindToController) {angular.extend(invokeCtrl.instance, locals);}var ctrl = invokeCtrl(); if (!getPreAssignBindingsEnabled() && options.bindToController) {angular.extend(invokeCtrl.instance, locals);}angular.isFunction(ctrl.$onInit) && ctrl.$onInit(); return ctrl;}; MdCompilerService.prototype._fetchContentElement = function (options) {var contentEl = options.contentElement; var restoreFn = null; if (angular.isString(contentEl)) {contentEl = document.querySelector(contentEl); restoreFn = createRestoreFn(contentEl);}else {contentEl = contentEl[0] || contentEl; if (document.contains(contentEl)) {restoreFn = createRestoreFn(contentEl);}else {restoreFn = function () {if (contentEl.parentNode) {contentEl.parentNode.removeChild(contentEl);}};}}return {element: angular.element(contentEl), restore: restoreFn, }; function createRestoreFn(element) {var parent = element.parentNode; var nextSibling = element.nextElementSibling; return function () {if (!nextSibling) {parent.appendChild(element);}else {parent.insertBefore(element, nextSibling);}};}};}})(); (function () {'use strict'; MdGesture.$inject = ['$$MdGestureHandler', '$$rAF', '$timeout']; attachToDocument.$inject = ['$mdGesture', '$$MdGestureHandler']; var HANDLERS = {}; var pointer, lastPointer, forceSkipClickHijack = false, maxClickDistance = 6; var lastLabelClickPos = null; var isInitialized = false; angular .module('material.core.gestures', []) .provider('$mdGesture', MdGestureProvider) .factory('$$MdGestureHandler', MdGestureHandler) .run(attachToDocument); function MdGestureProvider() {}MdGestureProvider.prototype = {skipClickHijack: function () {return (forceSkipClickHijack = true);}, setMaxClickDistance: function (clickDistance) {maxClickDistance = parseInt(clickDistance);}, $get: [ '$$MdGestureHandler', '$$rAF', '$timeout', function ($$MdGestureHandler, $$rAF, $timeout) {return new MdGesture($$MdGestureHandler, $$rAF, $timeout);}, ], }; function MdGesture($$MdGestureHandler, $$rAF, $timeout) {var userAgent = navigator.userAgent || navigator.vendor || window.opera; var isIos = userAgent.match(/ipad|iphone|ipod/i); var isAndroid = userAgent.match(/android/i); var touchActionProperty = getTouchAction(); var hasJQuery = typeof window.jQuery !== 'undefined' && angular.element === window.jQuery; var self = {handler: addHandler, register: register, isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack, }; if (self.isHijackingClicks) {self.handler('click', {options: {maxDistance: maxClickDistance, }, onEnd: checkDistanceAndEmit('click'), }); self.handler('focus', {options: {maxDistance: maxClickDistance, }, onEnd: function (ev, pointer) {if (pointer.distance < this.state.options.maxDistance && canFocus(ev.target)) {this.dispatchEvent(ev, 'focus', pointer); ev.target.focus();}}, }); self.handler('mouseup', {options: {maxDistance: maxClickDistance, }, onEnd: checkDistanceAndEmit('mouseup'), }); self.handler('mousedown', {onStart: function (ev) {this.dispatchEvent(ev, 'mousedown');}, });}function checkDistanceAndEmit(eventName) {return function (ev, pointer) {if (pointer.distance < this.state.options.maxDistance) {this.dispatchEvent(ev, eventName, pointer);}};}function register(element, handlerName, options) {var handler = HANDLERS[handlerName.replace(/^\$md./, '')]; if (!handler) {throw new Error('Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object.keys(HANDLERS).join(', '));}return handler.registerElement(element, options);}function addHandler(name, definition) {var handler = new $$MdGestureHandler(name); angular.extend(handler, definition); HANDLERS[name] = handler; return self;}return ( self .handler('press', {onStart: function (ev, pointer) {this.dispatchEvent(ev, '$md.pressdown');}, onEnd: function (ev, pointer) {this.dispatchEvent(ev, '$md.pressup');}, }) .handler('hold', {options: {maxDistance: 6, delay: 500, }, onCancel: function () {$timeout.cancel(this.state.timeout);}, onStart: function (ev, pointer) {if (!this.state.registeredParent) return this.cancel(); this.state.pos = {x: pointer.x, y: pointer.y }; this.state.timeout = $timeout( angular.bind(this, function holdDelayFn() {this.dispatchEvent(ev, '$md.hold'); this.cancel();}), this.state.options.delay, false, );}, onMove: function (ev, pointer) {if (!touchActionProperty && ev.type === 'touchmove') ev.preventDefault(); var dx = this.state.pos.x - pointer.x; var dy = this.state.pos.y - pointer.y; if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {this.cancel();}}, onEnd: function () {this.onCancel();}, }) .handler('drag', {options: {minDistance: 6, horizontal: true, cancelMultiplier: 1.5, }, onSetup: function (element, options) {if (touchActionProperty) {this.oldTouchAction = element[0].style[touchActionProperty]; element[0].style[touchActionProperty] = options.horizontal ? 'pan-y' : 'pan-x';}}, onCleanup: function (element) {if (this.oldTouchAction) {element[0].style[touchActionProperty] = this.oldTouchAction;}}, onStart: function (ev) {if (!this.state.registeredParent) this.cancel();}, onMove: function (ev, pointer) {var shouldStartDrag, shouldCancel; if (!touchActionProperty && ev.type === 'touchmove') ev.preventDefault(); if (!this.state.dragPointer) {if (this.state.options.horizontal) {shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance; shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;}else {shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance; shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;}if (shouldStartDrag) {this.state.dragPointer = makeStartPointer(ev); updatePointerState(ev, this.state.dragPointer); this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);}else if (shouldCancel) {this.cancel();}}else {this.dispatchDragMove(ev);}}, dispatchDragMove: $$rAF.throttle(function (ev) {if (this.state.isRunning) {updatePointerState(ev, this.state.dragPointer); this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);}}), onEnd: function (ev, pointer) {if (this.state.dragPointer) {updatePointerState(ev, this.state.dragPointer); this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);}}, }) .handler('swipe', {options: {minVelocity: 0.65, minDistance: 10, }, onEnd: function (ev, pointer) {var eventType; if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight'; this.dispatchEvent(ev, eventType);}else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown'; this.dispatchEvent(ev, eventType);}}, }) ); function getTouchAction() {var testEl = document.createElement('div'); var vendorPrefixes = ['', 'webkit', 'Moz', 'MS', 'ms', 'o']; for (var i = 0; i < vendorPrefixes.length; i++) {var prefix = vendorPrefixes[i]; var property = prefix ? prefix + 'TouchAction' : 'touchAction'; if (angular.isDefined(testEl.style[property])) {return property;}}}}function GestureHandler(name) {this.name = name; this.state = {};}function MdGestureHandler() {var hasJQuery = typeof window.jQuery !== 'undefined' && angular.element === window.jQuery; GestureHandler.prototype = {options: {}, dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent, onSetup: angular.noop, onCleanup: angular.noop, onStart: angular.noop, onMove: angular.noop, onEnd: angular.noop, onCancel: angular.noop, start: function (ev, pointer) {if (this.state.isRunning) return; var parentTarget = this.getNearestParent(ev.target); var parentTargetOptions = (parentTarget && parentTarget.$mdGesture[this.name]) || {}; this.state = {isRunning: true, options: angular.extend({}, this.options, parentTargetOptions), registeredParent: parentTarget, }; this.onStart(ev, pointer);}, move: function (ev, pointer) {if (!this.state.isRunning) return; this.onMove(ev, pointer);}, end: function (ev, pointer) {if (!this.state.isRunning) return; this.onEnd(ev, pointer); this.state.isRunning = false;}, cancel: function (ev, pointer) {this.onCancel(ev, pointer); this.state = {};}, getNearestParent: function (node) {var current = node; while (current) {if ((current.$mdGesture || {})[this.name]) {return current;}current = current.parentNode;}return null;}, registerElement: function (element, options) {var self = this; element[0].$mdGesture = element[0].$mdGesture || {}; element[0].$mdGesture[this.name] = options || {}; element.on('$destroy', onDestroy); self.onSetup(element, options || {}); return onDestroy; function onDestroy() {delete element[0].$mdGesture[self.name]; element.off('$destroy', onDestroy); self.onCleanup(element, options || {});}}, }; return GestureHandler; function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {eventPointer = eventPointer || pointer; var eventObj = new angular.element.Event(eventType); eventObj.$material = true; eventObj.pointer = eventPointer; eventObj.srcEvent = srcEvent; angular.extend(eventObj, {clientX: eventPointer.x, clientY: eventPointer.y, screenX: eventPointer.x, screenY: eventPointer.y, pageX: eventPointer.x, pageY: eventPointer.y, ctrlKey: srcEvent.ctrlKey, altKey: srcEvent.altKey, shiftKey: srcEvent.shiftKey, metaKey: srcEvent.metaKey, }); angular.element(eventPointer.target).trigger(eventObj);}function nativeDispatchEvent(srcEvent, eventType, eventPointer) {eventPointer = eventPointer || pointer; var eventObj; if (eventType === 'click' || eventType == 'mouseup' || eventType == 'mousedown') {eventObj = document.createEvent('MouseEvents'); eventObj.initMouseEvent( eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null, );}else {eventObj = document.createEvent('CustomEvent'); eventObj.initCustomEvent(eventType, true, true, {});}eventObj.$material = true; eventObj.pointer = eventPointer; eventObj.srcEvent = srcEvent; eventPointer.target.dispatchEvent(eventObj);}}function attachToDocument($mdGesture, $$MdGestureHandler) {document.contains || (document.contains = function (node) {return document.body.contains(node);}); if (!isInitialized && $mdGesture.isHijackingClicks) {document.addEventListener('click', clickHijacker, true); document.addEventListener('mouseup', mouseInputHijacker, true); document.addEventListener('mousedown', mouseInputHijacker, true); document.addEventListener('focus', mouseInputHijacker, true); isInitialized = true;}function mouseInputHijacker(ev) {var isKeyClick = !ev.clientX && !ev.clientY; if ( !isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev) && (ev.type !== 'mousedown' || (!canFocus(ev.target) && !canFocus(document.activeElement))) ) {ev.preventDefault(); ev.stopPropagation();}}function clickHijacker(ev) {var isKeyClick = ev.clientX === 0 && ev.clientY === 0; var isSubmitEvent = ev.target && ev.target.type === 'submit'; if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev) && !isSubmitEvent) {ev.preventDefault(); ev.stopPropagation(); lastLabelClickPos = null;}else {lastLabelClickPos = null; if (ev.target.tagName.toLowerCase() == 'label') {lastLabelClickPos = {x: ev.x, y: ev.y };}}}var START_EVENTS = 'mousedown touchstart pointerdown'; var MOVE_EVENTS = 'mousemove touchmove pointermove'; var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel'; angular .element(document) .on(START_EVENTS, gestureStart) .on(MOVE_EVENTS, gestureMove) .on(END_EVENTS, gestureEnd) .on('$$mdGestureReset', function gestureClearCache() {lastPointer = pointer = null;}); function runHandlers(handlerEvent, event) {var handler; for (var name in HANDLERS) {handler = HANDLERS[name]; if (handler instanceof $$MdGestureHandler) {if (handlerEvent === 'start') {handler.cancel();}handler[handlerEvent](event, pointer);}}}function gestureStart(ev) {if (pointer) return; var now = +Date.now(); if (lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500) {return;}pointer = makeStartPointer(ev); runHandlers('start', ev);}function gestureMove(ev) {if (!pointer || !typesMatch(ev, pointer)) return; updatePointerState(ev, pointer); runHandlers('move', ev);}function gestureEnd(ev) {if (!pointer || !typesMatch(ev, pointer)) return; updatePointerState(ev, pointer); pointer.endTime = +Date.now(); if (ev.type !== 'pointercancel') {runHandlers('end', ev);}lastPointer = pointer; pointer = null;}}function makeStartPointer(ev) {var point = getEventPoint(ev); var startPointer = {startTime: +Date.now(), target: ev.target, type: ev.type.charAt(0), }; startPointer.startX = startPointer.x = point.pageX; startPointer.startY = startPointer.y = point.pageY; return startPointer;}function typesMatch(ev, pointer) {return ev && pointer && ev.type.charAt(0) === pointer.type;}function isInputEventFromLabelClick(event) {return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;}function updatePointerState(ev, pointer) {var point = getEventPoint(ev); var x = (pointer.x = point.pageX); var y = (pointer.y = point.pageY); pointer.distanceX = x - pointer.startX; pointer.distanceY = y - pointer.startY; pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY); pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : ''; pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : ''; pointer.duration = +Date.now() - pointer.startTime; pointer.velocityX = pointer.distanceX / pointer.duration; pointer.velocityY = pointer.distanceY / pointer.duration;}function getEventPoint(ev) {ev = ev.originalEvent || ev; return (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;}function canFocus(element) {return ( !!element && element.getAttribute('tabindex') != '-1' && !element.hasAttribute('disabled') && (element.hasAttribute('tabindex') || element.hasAttribute('href') || element.isContentEditable || ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'].indexOf(element.nodeName) != -1) );}})(); (function () {'use strict'; MdInteractionService.$inject = ['$timeout', '$mdUtil']; angular.module('material.core.interaction', []).service('$mdInteraction', MdInteractionService); function MdInteractionService($timeout, $mdUtil) {this.$timeout = $timeout; this.$mdUtil = $mdUtil; this.bodyElement = angular.element(document.body); this.isBuffering = false; this.bufferTimeout = null; this.lastInteractionType = null; this.lastInteractionTime = null; this.inputEventMap = {keydown: 'keyboard', mousedown: 'mouse', mouseenter: 'mouse', touchstart: 'touch', pointerdown: 'pointer', MSPointerDown: 'pointer', }; this.iePointerMap = {2: 'touch', 3: 'touch', 4: 'mouse', }; this.initializeEvents();}MdInteractionService.prototype.initializeEvents = function () {var pointerEvent = 'MSPointerEvent' in window ? 'MSPointerDown' : 'PointerEvent' in window ? 'pointerdown' : null; this.bodyElement.on('keydown mousedown', this.onInputEvent.bind(this)); if ('ontouchstart' in document.documentElement) {this.bodyElement.on('touchstart', this.onBufferInputEvent.bind(this));}if (pointerEvent) {this.bodyElement.on(pointerEvent, this.onInputEvent.bind(this));}}; MdInteractionService.prototype.onInputEvent = function (event) {if (this.isBuffering) {return;}var type = this.inputEventMap[event.type]; if (type === 'pointer') {type = this.iePointerMap[event.pointerType] || event.pointerType;}this.lastInteractionType = type; this.lastInteractionTime = this.$mdUtil.now();}; MdInteractionService.prototype.onBufferInputEvent = function (event) {this.$timeout.cancel(this.bufferTimeout); this.onInputEvent(event); this.isBuffering = true; this.bufferTimeout = this.$timeout( function () {this.isBuffering = false;}.bind(this), 650, false, );}; MdInteractionService.prototype.getLastInteractionType = function () {return this.lastInteractionType;}; MdInteractionService.prototype.isUserInvoked = function (checkDelay) {var delay = angular.isNumber(checkDelay) ? checkDelay : 15; return this.lastInteractionTime >= this.$mdUtil.now() - delay;};})(); (function () {'use strict'; angular.module('material.core').provider('$$interimElement', InterimElementProvider); function InterimElementProvider() {InterimElementFactory.$inject = [ '$document', '$q', '$rootScope', '$timeout', '$rootElement', '$animate', '$mdUtil', '$mdCompiler', '$mdTheming', '$injector', '$exceptionHandler', ]; createInterimElementProvider.$get = InterimElementFactory; return createInterimElementProvider; function createInterimElementProvider(interimFactoryName) {factory.$inject = ['$$interimElement', '$injector']; var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove']; var customMethods = {}; var providerConfig = {presets: {}, }; var provider = {setDefaults: setDefaults, addPreset: addPreset, addMethod: addMethod, $get: factory, }; provider.addPreset('build', {methods: [ 'controller', 'controllerAs', 'resolve', 'multiple', 'template', 'templateUrl', 'themable', 'transformTemplate', 'parent', 'contentElement', ], }); return provider; function setDefaults(definition) {providerConfig.optionsFactory = definition.options; providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS); return provider;}function addMethod(name, fn) {customMethods[name] = fn; return provider;}function addPreset(name, definition) {definition = definition || {}; definition.methods = definition.methods || []; definition.options = definition.options || function () {return {};}; if (/^cancel|hide|show$/.test(name)) {throw new Error("Preset '" + name + "' in " + interimFactoryName + ' is reserved!');}if (definition.methods.indexOf('_options') > -1) {throw new Error("Method '_options' in " + interimFactoryName + ' is reserved!');}providerConfig.presets[name] = {methods: definition.methods.concat(EXPOSED_METHODS), optionsFactory: definition.options, argOption: definition.argOption, }; return provider;}function addPresetMethod(presetName, methodName, method) {providerConfig.presets[presetName][methodName] = method;}function factory($$interimElement, $injector) {var defaultMethods; var defaultOptions; var interimElementService = $$interimElement(); var publicService = {hide: interimElementService.hide, cancel: interimElementService.cancel, show: showInterimElement, destroy: destroyInterimElement, }; defaultMethods = providerConfig.methods || []; defaultOptions = invokeFactory(providerConfig.optionsFactory, {}); angular.forEach(customMethods, function (fn, name) {publicService[name] = fn;}); angular.forEach(providerConfig.presets, function (definition, name) {var presetDefaults = invokeFactory(definition.optionsFactory, {}); var presetMethods = (definition.methods || []).concat(defaultMethods); angular.extend(presetDefaults, {$type: name }); function Preset(opts) {this._options = angular.extend({}, presetDefaults, opts);}angular.forEach(presetMethods, function (name) {Preset.prototype[name] = function (value) {this._options[name] = value; return this;};}); if (definition.argOption) {var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1); publicService[methodName] = function (arg) {var config = publicService[name](arg); return publicService.show(config);};}publicService[name] = function (arg) {if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {return new Preset()[definition.argOption](arg);}else {return new Preset(arg);}};}); return publicService; function showInterimElement(opts) {opts = opts || {}; if (opts._options) opts = opts._options; return interimElementService.show(angular.extend({}, defaultOptions, opts));}function destroyInterimElement(opts) {return interimElementService.destroy(opts);}function invokeFactory(factory, defaultVal) {var locals = {}; locals[interimFactoryName] = publicService; return $injector.invoke( factory || function () {return defaultVal;}, {}, locals, );}}}function InterimElementFactory( $document, $q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector, $exceptionHandler, ) {return function createInterimElementService() {var SHOW_CANCELLED = false; var service; var showPromises = []; var hidePromises = []; var showingInterims = []; return (service = {show: show, hide: waitForInterim(hide), cancel: waitForInterim(cancel), destroy: destroy, $injector_: $injector, }); function show(options) {options = options || {}; var interimElement = new InterimElement(options || {}); var hideAction = options.multiple ? $q.resolve() : $q.all(showPromises); if (!options.multiple) {hideAction = hideAction.then(function () {var promiseArray = hidePromises.concat(showingInterims.map(service.cancel)); return $q.all(promiseArray);});}var showAction = hideAction.then(function () {return interimElement .show() .catch(function (reason) {return reason;}) .finally(function () {showPromises.splice(showPromises.indexOf(showAction), 1); showingInterims.push(interimElement);});}); showPromises.push(showAction); interimElement.deferred.promise.catch(function (fault) {if (fault instanceof Error) {$exceptionHandler(fault);}return fault;}); return interimElement.deferred.promise;}function hide(reason, options) {options = options || {}; if (options.closeAll) {return $q.all(showingInterims.slice().reverse().map(closeElement));}else if (options.closeTo !== undefined) {return $q.all(showingInterims.slice(options.closeTo).map(closeElement));}return closeElement(showingInterims[showingInterims.length - 1]); function closeElement(interim) {var hideAction = interim .remove(reason, false, options || {}) .catch(function (reason) {return reason;}) .finally(function () {hidePromises.splice(hidePromises.indexOf(hideAction), 1);}); showingInterims.splice(showingInterims.indexOf(interim), 1); hidePromises.push(hideAction); return interim.deferred.promise;}}function cancel(reason, options) {var interim = showingInterims.pop(); if (!interim) {return $q.when(reason);}var cancelAction = interim .remove(reason, true, options || {}) .catch(function (reason) {return reason;}) .finally(function () {hidePromises.splice(hidePromises.indexOf(cancelAction), 1);}); hidePromises.push(cancelAction); return interim.deferred.promise.catch(angular.noop);}function waitForInterim(callbackFn) {return function () {var fnArguments = arguments; if (!showingInterims.length) {if (showPromises.length) {return showPromises[0].finally(function () {return callbackFn.apply(service, fnArguments);});}return $q.when('No interim elements currently showing up.');}return callbackFn.apply(service, fnArguments);};}function destroy(targetEl) {var interim = !targetEl ? showingInterims.shift() : null; var parentEl = angular.element(targetEl).length && angular.element(targetEl)[0].parentNode; if (parentEl) {var filtered = showingInterims.filter(function (entry) {return entry.options.element[0] === parentEl;}); if (filtered.length) {interim = filtered[0]; showingInterims.splice(showingInterims.indexOf(interim), 1);}}return interim ? interim.remove(SHOW_CANCELLED, false, {$destroy: true }) : $q.when(SHOW_CANCELLED);}function InterimElement(options) {var self, element, showAction = $q.when(true); options = configureScopeAndTransitions(options); return (self = {options: options, deferred: $q.defer(), show: createAndTransitionIn, remove: transitionOutAndRemove, }); function createAndTransitionIn() {return $q(function (resolve, reject) {options.onCompiling && options.onCompiling(options); compileElement(options) .then(function (compiledData) {element = linkElement(compiledData, options); options.cleanupElement = compiledData.cleanup; showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);}) .catch(rejectAll); function rejectAll(fault) {self.deferred.reject(fault); reject(fault);}});}function transitionOutAndRemove(response, isCancelled, opts) {if (!element) return $q.when(false); options = angular.extend(options || {}, opts || {}); options.cancelAutoHide && options.cancelAutoHide(); options.element.triggerHandler('$mdInterimElementRemove'); if (options.$destroy === true) {return hideElement(options.element, options).then(function () {(isCancelled && rejectAll(response)) || resolveAll(response);});}else {$q.when(showAction).finally(function () {hideElement(options.element, options).then(function () {isCancelled ? rejectAll(response) : resolveAll(response);}, rejectAll);}); return self.deferred.promise;}function resolveAll(response) {self.deferred.resolve(response);}function rejectAll(fault) {self.deferred.reject(fault);}}function configureScopeAndTransitions(options) {options = options || {}; if (options.template) {options.template = $mdUtil.processTemplate(options.template);}return angular.extend( {preserveScope: false, cancelAutoHide: angular.noop, scope: options.scope || $rootScope.$new(options.isolateScope), onShow: function transitionIn(scope, element, options) {return $animate.enter(element, options.parent);}, onRemove: function transitionOut(scope, element) {return (element && $animate.leave(element)) || $q.when();}, }, options, );}function compileElement(options) {var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null; return ( compiled || $q(function (resolve) {resolve({locals: {}, link: function () {return options.element;}, });}) );}function linkElement(compileData, options) {angular.extend(compileData.locals, options); var element = compileData.link(options.scope); options.element = element; options.parent = findParent(element, options); if (options.themable) $mdTheming(element); return element;}function findParent(element, options) {var parent = options.parent; if (angular.isFunction(parent)) {parent = parent(options.scope, element, options);}else if (angular.isString(parent)) {parent = angular.element($document[0].querySelector(parent));}else {parent = angular.element(parent);}if (!(parent || {}).length) {var el; if ($rootElement[0] && $rootElement[0].querySelector) {el = $rootElement[0].querySelector(':not(svg) > body');}if (!el) el = $rootElement[0]; if (el.nodeName == '#comment') {el = $document[0].body;}return angular.element(el);}return parent;}function startAutoHide() {var autoHideTimer, cancelAutoHide = angular.noop; if (options.hideDelay) {autoHideTimer = $timeout(service.hide, options.hideDelay); cancelAutoHide = function () {$timeout.cancel(autoHideTimer);};}options.cancelAutoHide = function () {cancelAutoHide(); options.cancelAutoHide = undefined;};}function showElement(element, options, controller) {var notifyShowing = options.onShowing || angular.noop; var notifyComplete = options.onComplete || angular.noop; try {notifyShowing(options.scope, element, options, controller);}catch (e) {return $q.reject(e);}return $q(function (resolve, reject) {try {$q.when(options.onShow(options.scope, element, options, controller)).then(function () {notifyComplete(options.scope, element, options); startAutoHide(); resolve(element);}, reject);}catch (e) {reject(e.message);}});}function hideElement(element, options) {var announceRemoving = options.onRemoving || angular.noop; return $q(function (resolve, reject) {try {var action = $q.when(options.onRemove(options.scope, element, options) || true); announceRemoving(element, action); if (options.$destroy) {resolve(element); if (!options.preserveScope && options.scope) {action.then(function () {options.scope.$destroy();});}}else {action.then(function () {if (!options.preserveScope && options.scope) {options.scope.$destroy();}resolve(element);}, reject);}}catch (e) {reject(e.message);}});}}};}}})(); (function () {'use strict'; (function () {'use strict'; var $mdUtil, $interpolate, $log; var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g; var WHITESPACE = /\s+/g; var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow']; var LAYOUT_OPTIONS = ['row', 'column']; var ALIGNMENT_MAIN_AXIS = ['', 'start', 'center', 'end', 'stretch', 'space-around', 'space-between']; var ALIGNMENT_CROSS_AXIS = ['', 'start', 'center', 'end', 'stretch']; var config = {enabled: true, breakpoints: [], }; registerLayoutAPI(angular.module('material.core.layout', ['ng'])); function registerLayoutAPI(module) {var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i; var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g; var BREAKPOINTS = ['', 'xs', 'gt-xs', 'sm', 'gt-sm', 'md', 'gt-md', 'lg', 'gt-lg', 'xl', 'print']; var API_WITH_VALUES = ['layout', 'flex', 'flex-order', 'flex-offset', 'layout-align']; var API_NO_VALUES = ['show', 'hide', 'layout-padding', 'layout-margin']; angular.forEach(BREAKPOINTS, function (mqb) {angular.forEach(API_WITH_VALUES, function (name) {var fullName = mqb ? name + '-' + mqb : name; module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));}); angular.forEach(API_NO_VALUES, function (name) {var fullName = mqb ? name + '-' + mqb : name; module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));});}); module .provider('$$mdLayout', function () {return {$get: angular.noop, validateAttributeValue: validateAttributeValue, validateAttributeUsage: validateAttributeUsage, disableLayouts: function (isDisabled) {config.enabled = isDisabled !== true;}, };}) .directive('mdLayoutCss', disableLayoutDirective) .directive('ngCloak', buildCloakInterceptor('ng-cloak')) .directive('layoutWrap', attributeWithoutValue('layout-wrap')) .directive('layoutNowrap', attributeWithoutValue('layout-nowrap')) .directive('layoutNoWrap', attributeWithoutValue('layout-no-wrap')) .directive('layoutFill', attributeWithoutValue('layout-fill')) .directive('layoutLtMd', warnAttrNotSupported('layout-lt-md', true)) .directive('layoutLtLg', warnAttrNotSupported('layout-lt-lg', true)) .directive('flexLtMd', warnAttrNotSupported('flex-lt-md', true)) .directive('flexLtLg', warnAttrNotSupported('flex-lt-lg', true)) .directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md')) .directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg')) .directive('flexOrderLtMd', warnAttrNotSupported('flex-order-lt-md')) .directive('flexOrderLtLg', warnAttrNotSupported('flex-order-lt-lg')) .directive('offsetLtMd', warnAttrNotSupported('flex-offset-lt-md')) .directive('offsetLtLg', warnAttrNotSupported('flex-offset-lt-lg')) .directive('hideLtMd', warnAttrNotSupported('hide-lt-md')) .directive('hideLtLg', warnAttrNotSupported('hide-lt-lg')) .directive('showLtMd', warnAttrNotSupported('show-lt-md')) .directive('showLtLg', warnAttrNotSupported('show-lt-lg')) .config(detectDisabledLayouts); function directiveNormalize(name) {return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {return offset ? letter.toUpperCase() : letter;});}}function detectDisabledLayouts() {var isDisabled = !!document.querySelector('[md-layouts-disabled]'); config.enabled = !isDisabled;}function disableLayoutDirective() {config.enabled = false; return {restrict: 'A', priority: '900', };}function buildCloakInterceptor(className) {return [ '$timeout', function ($timeout) {return {restrict: 'A', priority: -10, compile: function (element) {if (!config.enabled) return angular.noop; element.addClass(className); return function (scope, element) {$timeout( function () {element.removeClass(className);}, 10, false, );};}, };}, ];}function attributeWithObserve(className) {return [ '$mdUtil', '$interpolate', '$log', function (_$mdUtil_, _$interpolate_, _$log_) {$mdUtil = _$mdUtil_; $interpolate = _$interpolate_; $log = _$log_; return {restrict: 'A', compile: function (element, attr) {var linkFn; if (config.enabled) {validateAttributeUsage(className, attr, element, $log); validateAttributeValue(className, getNormalizedAttrValue(className, attr, ''), buildUpdateFn(element, className, attr)); linkFn = translateWithValueToCssClass;}return linkFn || angular.noop;}, };}, ]; function translateWithValueToCssClass(scope, element, attrs) {var updateFn = updateClassWithValue(element, className, attrs); var unwatch = attrs.$observe(attrs.$normalize(className), updateFn); updateFn(getNormalizedAttrValue(className, attrs, '')); scope.$on('$destroy', function () {unwatch();});}}function attributeWithoutValue(className) {return [ '$mdUtil', '$interpolate', '$log', function (_$mdUtil_, _$interpolate_, _$log_) {$mdUtil = _$mdUtil_; $interpolate = _$interpolate_; $log = _$log_; return {restrict: 'A', compile: function (element, attr) {var linkFn; if (config.enabled) {validateAttributeValue(className, getNormalizedAttrValue(className, attr, ''), buildUpdateFn(element, className, attr)); translateToCssClass(null, element); linkFn = translateToCssClass;}return linkFn || angular.noop;}, };}, ]; function translateToCssClass(scope, element) {element.addClass(className);}}function updateClassWithValue(element, className) {var lastClass; return function updateClassFn(newValue) {var value = validateAttributeValue(className, newValue || ''); if (angular.isDefined(value)) {if (lastClass) element.removeClass(lastClass); lastClass = !value ? className : className + '-' + value.trim().replace(WHITESPACE, '-'); element.addClass(lastClass);}};}function warnAttrNotSupported(className) {var parts = className.split('-'); return [ '$log', function ($log) {$log.warn(className + 'has been deprecated. Please use a `' + parts[0] + '-gt-<xxx>` variant.'); return angular.noop;}, ];}function validateAttributeUsage(className, attr, element, $log) {var message, usage, url; var nodeName = element[0].nodeName.toLowerCase(); switch (className.replace(SUFFIXES, '')) {case 'flex': if (nodeName == 'md-button' || nodeName == 'fieldset') {usage = '<' + nodeName + ' ' + className + '></' + nodeName + '>'; url = 'https: message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details."; $log.warn($mdUtil.supplant(message, [usage, url]));}}}function validateAttributeValue(className, value, updateFn) {var origValue; if (!needsInterpolation(value)) {switch (className.replace(SUFFIXES, '')) {case 'layout': if (!findIn(value, LAYOUT_OPTIONS)) {value = LAYOUT_OPTIONS[0];}break; case 'flex': if (!findIn(value, FLEX_OPTIONS)) {if (isNaN(value)) {value = '';}}break; case 'flex-offset': case 'flex-order': if (!value || isNaN(+value)) {value = '0';}break; case 'layout-align': var axis = extractAlignAxis(value); value = $mdUtil.supplant('{main}-{cross}', axis); break; case 'layout-padding': case 'layout-margin': case 'layout-fill': case 'layout-wrap': case 'layout-nowrap': case 'layout-nowrap': value = ''; break;}if (value != origValue) {(updateFn || angular.noop)(value);}}return value ? value.trim() : '';}function buildUpdateFn(element, className, attrs) {return function updateAttrValue(fallback) {if (!needsInterpolation(fallback)) {attrs[attrs.$normalize(className)] = fallback;}};}function needsInterpolation(value) {return (value || '').indexOf($interpolate.startSymbol()) > -1;}function getNormalizedAttrValue(className, attrs, defaultVal) {var normalizedAttr = attrs.$normalize(className); return attrs[normalizedAttr] ? attrs[normalizedAttr].trim().replace(WHITESPACE, '-') : defaultVal || null;}function findIn(item, list, replaceWith) {item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item; var found = false; if (item) {list.forEach(function (it) {it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it; found = found || it === item;});}return found;}function extractAlignAxis(attrValue) {var axis = {main: 'start', cross: 'stretch', }, values; attrValue = attrValue || ''; if (attrValue.indexOf('-') === 0 || attrValue.indexOf(' ') === 0) {attrValue = 'none' + attrValue;}values = attrValue.toLowerCase().trim().replace(WHITESPACE, '-').split('-'); if (values.length && values[0] === 'space') {values = [values[0] + '-' + values[1], values[2]];}if (values.length > 0) axis.main = values[0] || axis.main; if (values.length > 1) axis.cross = values[1] || axis.cross; if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0) axis.main = 'start'; if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0) axis.cross = 'stretch'; return axis;}})();})(); (function () {'use strict'; MdLiveAnnouncer.$inject = ['$timeout']; angular.module('material.core').service('$mdLiveAnnouncer', MdLiveAnnouncer); function MdLiveAnnouncer($timeout) {this._$timeout = $timeout; this._liveElement = this._createLiveElement(); this._announceTimeout = 100;}MdLiveAnnouncer.prototype.announce = function (message, politeness) {if (!politeness) {politeness = 'polite';}var self = this; self._liveElement.textContent = ''; self._liveElement.setAttribute('aria-live', politeness); self._$timeout( function () {self._liveElement.textContent = message;}, self._announceTimeout, false, );}; MdLiveAnnouncer.prototype._createLiveElement = function () {var liveEl = document.createElement('div'); liveEl.classList.add('md-visually-hidden'); liveEl.setAttribute('role', 'status'); liveEl.setAttribute('aria-atomic', 'true'); liveEl.setAttribute('aria-live', 'polite'); document.body.appendChild(liveEl); return liveEl;};})(); (function () {'use strict'; angular.module('material.core.meta', []).provider('$$mdMeta', function () {var head = angular.element(document.head); var metaElements = {}; function mapExistingElement(name) {if (metaElements[name]) {return true;}var element = document.getElementsByName(name)[0]; if (!element) {return false;}metaElements[name] = angular.element(element); return true;}function setMeta(name, content) {mapExistingElement(name); if (!metaElements[name]) {var newMeta = angular.element('<meta name="' + name + '" content="' + content + '"/>'); head.append(newMeta); metaElements[name] = newMeta;}else {metaElements[name].attr('content', content);}return function () {metaElements[name].attr('content', ''); metaElements[name].remove(); delete metaElements[name];};}function getMeta(name) {if (!mapExistingElement(name)) {throw Error("$$mdMeta: could not find a meta tag with the name '" + name + "'");}return metaElements[name].attr('content');}var module = {setMeta: setMeta, getMeta: getMeta, }; return angular.extend({}, module, {$get: function () {return module;}, });});})(); (function () {'use strict'; ComponentRegistry.$inject = ['$log', '$q']; angular.module('material.core').factory('$mdComponentRegistry', ComponentRegistry); function ComponentRegistry($log, $q) {var self; var instances = []; var pendings = {}; return (self = {notFoundError: function (handle, msgContext) {$log.error((msgContext || '') + 'No instance found for handle', handle);}, getInstances: function () {return instances;}, get: function (handle) {if (!isValidID(handle)) return null; var i, j, instance; for (i = 0, j = instances.length; i < j; i++) {instance = instances[i]; if (instance.$$mdHandle === handle) {return instance;}}return null;}, register: function (instance, handle) {if (!handle) return angular.noop; instance.$$mdHandle = handle; instances.push(instance); resolveWhen(); return deregister; function deregister() {var index = instances.indexOf(instance); if (index !== -1) {instances.splice(index, 1);}}function resolveWhen() {var dfd = pendings[handle]; if (dfd) {dfd.forEach(function (promise) {promise.resolve(instance);}); delete pendings[handle];}}}, when: function (handle) {if (isValidID(handle)) {var deferred = $q.defer(); var instance = self.get(handle); if (instance) {deferred.resolve(instance);}else {if (pendings[handle] === undefined) {pendings[handle] = [];}pendings[handle].push(deferred);}return deferred.promise;}return $q.reject('Invalid `md-component-id` value.');}, }); function isValidID(handle) {return handle && handle !== '';}}})(); (function () {'use strict'; (function () {'use strict'; MdButtonInkRipple.$inject = ['$mdInkRipple']; angular.module('material.core').factory('$mdButtonInkRipple', MdButtonInkRipple); function MdButtonInkRipple($mdInkRipple) {return {attach: function attachRipple(scope, element, options) {options = angular.extend(optionsForElement(element), options); return $mdInkRipple.attach(scope, element, options);}, }; function optionsForElement(element) {if (element.hasClass('md-icon-button')) {return {isMenuItem: element.hasClass('md-menu-item'), fitRipple: true, center: true, };}else {return {isMenuItem: element.hasClass('md-menu-item'), dimBackground: true, };}}}})();})(); (function () {'use strict'; (function () {'use strict'; MdCheckboxInkRipple.$inject = ['$mdInkRipple']; angular.module('material.core').factory('$mdCheckboxInkRipple', MdCheckboxInkRipple); function MdCheckboxInkRipple($mdInkRipple) {return {attach: attach, }; function attach(scope, element, options) {return $mdInkRipple.attach( scope, element, angular.extend( {center: true, dimBackground: false, fitRipple: true, }, options, ), );}}})();})(); (function () {'use strict'; (function () {'use strict'; MdListInkRipple.$inject = ['$mdInkRipple']; angular.module('material.core').factory('$mdListInkRipple', MdListInkRipple); function MdListInkRipple($mdInkRipple) {return {attach: attach, }; function attach(scope, element, options) {return $mdInkRipple.attach( scope, element, angular.extend( {center: false, dimBackground: true, outline: false, rippleSize: 'full', }, options, ), );}}})();})(); (function () {'use strict'; InkRippleCtrl.$inject = ['$scope', '$element', 'rippleOptions', '$window', '$timeout', '$mdUtil', '$mdColorUtil']; InkRippleDirective.$inject = ['$mdButtonInkRipple', '$mdCheckboxInkRipple']; angular .module('material.core') .provider('$mdInkRipple', InkRippleProvider) .directive('mdInkRipple', InkRippleDirective) .directive('mdNoInk', attrNoDirective) .directive('mdNoBar', attrNoDirective) .directive('mdNoStretch', attrNoDirective); var DURATION = 450; function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {return {controller: angular.noop, link: function (scope, element, attr) {attr.hasOwnProperty('mdInkRippleCheckbox') ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);}, };}function InkRippleProvider() {var isDisabledGlobally = false; return {disableInkRipple: disableInkRipple, $get: [ '$injector', function ($injector) {return {attach: attach }; function attach(scope, element, options) {if (isDisabledGlobally || element.controller('mdNoInk')) return angular.noop; return $injector.instantiate(InkRippleCtrl, {$scope: scope, $element: element, rippleOptions: options, });}}, ], }; function disableInkRipple() {isDisabledGlobally = true;}}function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil, $mdColorUtil) {this.$window = $window; this.$timeout = $timeout; this.$mdUtil = $mdUtil; this.$mdColorUtil = $mdColorUtil; this.$scope = $scope; this.$element = $element; this.options = rippleOptions; this.mousedown = false; this.ripples = []; this.timeout = null; this.lastRipple = null; $mdUtil.valueOnUse(this, 'container', this.createContainer); this.$element.addClass('md-ink-ripple'); ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple); ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color); this.bindEvents();}function autoCleanup(self, cleanupFn) {if (self.mousedown || self.lastRipple) {self.mousedown = false; self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);}}InkRippleCtrl.prototype.color = function (value) {var self = this; if (angular.isDefined(value)) {self._color = self._parseColor(value);}return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor()); function getElementColor() {var items = self.options && self.options.colorElement ? self.options.colorElement : []; var elem = items.length ? items[0] : self.$element[0]; return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';}}; InkRippleCtrl.prototype.calculateColor = function () {return this.color();}; InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier) {multiplier = multiplier || 1; var colorUtil = this.$mdColorUtil; if (!color) return; if (color.indexOf('rgba') === 0) return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')'); if (color.indexOf('rgb') === 0) return colorUtil.rgbToRgba(color); if (color.indexOf('#') === 0) return colorUtil.hexToRgba(color);}; InkRippleCtrl.prototype.bindEvents = function () {this.$element.on('mousedown', angular.bind(this, this.handleMousedown)); this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup)); this.$element.on('mouseleave', angular.bind(this, this.handleMouseup)); this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));}; InkRippleCtrl.prototype.handleMousedown = function (event) {if (this.mousedown) return; if (event.hasOwnProperty('originalEvent')) event = event.originalEvent; this.mousedown = true; if (this.options.center) {this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);}else {if (event.srcElement !== this.$element[0]) {var layerRect = this.$element[0].getBoundingClientRect(); var layerX = event.clientX - layerRect.left; var layerY = event.clientY - layerRect.top; this.createRipple(layerX, layerY);}else {this.createRipple(event.offsetX, event.offsetY);}}}; InkRippleCtrl.prototype.handleMouseup = function () {autoCleanup(this, this.clearRipples);}; InkRippleCtrl.prototype.handleTouchmove = function () {autoCleanup(this, this.deleteRipples);}; InkRippleCtrl.prototype.deleteRipples = function () {for (var i = 0; i < this.ripples.length; i++) {this.ripples[i].remove();}}; InkRippleCtrl.prototype.clearRipples = function () {for (var i = 0; i < this.ripples.length; i++) {this.fadeInComplete(this.ripples[i]);}}; InkRippleCtrl.prototype.createContainer = function () {var container = angular.element('<div class="md-ripple-container"></div>'); this.$element.append(container); return container;}; InkRippleCtrl.prototype.clearTimeout = function () {if (this.timeout) {this.$timeout.cancel(this.timeout); this.timeout = null;}}; InkRippleCtrl.prototype.isRippleAllowed = function () {var element = this.$element[0]; do {if (!element.tagName || element.tagName === 'BODY') break; if (element && angular.isFunction(element.hasAttribute)) {if (element.hasAttribute('disabled')) return false; if (this.inkRipple() === 'false' || this.inkRipple() === '0') return false;}}while ((element = element.parentNode)); return true;}; InkRippleCtrl.prototype.inkRipple = function () {return this.$element.attr('md-ink-ripple');}; InkRippleCtrl.prototype.createRipple = function (left, top) {if (!this.isRippleAllowed()) return; var ctrl = this; var colorUtil = ctrl.$mdColorUtil; var ripple = angular.element('<div class="md-ripple"></div>'); var width = this.$element.prop('clientWidth'); var height = this.$element.prop('clientHeight'); var x = Math.max(Math.abs(width - left), left) * 2; var y = Math.max(Math.abs(height - top), top) * 2; var size = getSize(this.options.fitRipple, x, y); var color = this.calculateColor(); ripple.css({left: left + 'px', top: top + 'px', background: 'black', width: size + 'px', height: size + 'px', backgroundColor: colorUtil.rgbaToRgb(color), borderColor: colorUtil.rgbaToRgb(color), }); this.lastRipple = ripple; this.clearTimeout(); this.timeout = this.$timeout( function () {ctrl.clearTimeout(); if (!ctrl.mousedown) ctrl.fadeInComplete(ripple);}, DURATION * 0.35, false, ); if (this.options.dimBackground) this.container.css({backgroundColor: color }); this.container.append(ripple); this.ripples.push(ripple); ripple.addClass('md-ripple-placed'); this.$mdUtil.nextTick(function () {ripple.addClass('md-ripple-scaled md-ripple-active'); ctrl.$timeout( function () {ctrl.clearRipples();}, DURATION, false, );}, false); function getSize(fit, x, y) {return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));}}; InkRippleCtrl.prototype.fadeInComplete = function (ripple) {if (this.lastRipple === ripple) {if (!this.timeout && !this.mousedown) {this.removeRipple(ripple);}}else {this.removeRipple(ripple);}}; InkRippleCtrl.prototype.removeRipple = function (ripple) {var ctrl = this; var index = this.ripples.indexOf(ripple); if (index < 0) return; this.ripples.splice(this.ripples.indexOf(ripple), 1); ripple.removeClass('md-ripple-active'); ripple.addClass('md-ripple-remove'); if (this.ripples.length === 0) this.container.css({backgroundColor: '' }); this.$timeout( function () {ctrl.fadeOutComplete(ripple);}, DURATION, false, );}; InkRippleCtrl.prototype.fadeOutComplete = function (ripple) {ripple.remove(); this.lastRipple = null;}; function attrNoDirective() {return {controller: angular.noop };}})(); (function () {'use strict'; (function () {'use strict'; MdTabInkRipple.$inject = ['$mdInkRipple']; angular.module('material.core').factory('$mdTabInkRipple', MdTabInkRipple); function MdTabInkRipple($mdInkRipple) {return {attach: attach, }; function attach(scope, element, options) {return $mdInkRipple.attach( scope, element, angular.extend( {center: false, dimBackground: true, outline: false, rippleSize: 'full', }, options, ), );}}})();})(); (function () {'use strict'; angular.module('material.core.theming.palette', []).constant('$mdColorPalette', {red: {50: '#ffebee', 100: '#ffcdd2', 200: '#ef9a9a', 300: '#e57373', 400: '#ef5350', 500: '#f44336', 600: '#e53935', 700: '#d32f2f', 800: '#c62828', 900: '#b71c1c', A100: '#ff8a80', A200: '#ff5252', A400: '#ff1744', A700: '#d50000', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 300 A100', contrastStrongLightColors: '400 500 600 700 A200 A400 A700', }, pink: {50: '#fce4ec', 100: '#f8bbd0', 200: '#f48fb1', 300: '#f06292', 400: '#ec407a', 500: '#e91e63', 600: '#d81b60', 700: '#c2185b', 800: '#ad1457', 900: '#880e4f', A100: '#ff80ab', A200: '#ff4081', A400: '#f50057', A700: '#c51162', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 A100', contrastStrongLightColors: '500 600 A200 A400 A700', }, purple: {50: '#f3e5f5', 100: '#e1bee7', 200: '#ce93d8', 300: '#ba68c8', 400: '#ab47bc', 500: '#9c27b0', 600: '#8e24aa', 700: '#7b1fa2', 800: '#6a1b9a', 900: '#4a148c', A100: '#ea80fc', A200: '#e040fb', A400: '#d500f9', A700: '#aa00ff', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 A100', contrastStrongLightColors: '300 400 A200 A400 A700', }, 'deep-purple': {50: '#ede7f6', 100: '#d1c4e9', 200: '#b39ddb', 300: '#9575cd', 400: '#7e57c2', 500: '#673ab7', 600: '#5e35b1', 700: '#512da8', 800: '#4527a0', 900: '#311b92', A100: '#b388ff', A200: '#7c4dff', A400: '#651fff', A700: '#6200ea', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 A100', contrastStrongLightColors: '300 400 A200', }, indigo: {50: '#e8eaf6', 100: '#c5cae9', 200: '#9fa8da', 300: '#7986cb', 400: '#5c6bc0', 500: '#3f51b5', 600: '#3949ab', 700: '#303f9f', 800: '#283593', 900: '#1a237e', A100: '#8c9eff', A200: '#536dfe', A400: '#3d5afe', A700: '#304ffe', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 A100', contrastStrongLightColors: '300 400 A200 A400', }, blue: {50: '#e3f2fd', 100: '#bbdefb', 200: '#90caf9', 300: '#64b5f6', 400: '#42a5f5', 500: '#2196f3', 600: '#1e88e5', 700: '#1976d2', 800: '#1565c0', 900: '#0d47a1', A100: '#82b1ff', A200: '#448aff', A400: '#2979ff', A700: '#2962ff', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 300 400 A100', contrastStrongLightColors: '500 600 700 A200 A400 A700', }, 'light-blue': {50: '#e1f5fe', 100: '#b3e5fc', 200: '#81d4fa', 300: '#4fc3f7', 400: '#29b6f6', 500: '#03a9f4', 600: '#039be5', 700: '#0288d1', 800: '#0277bd', 900: '#01579b', A100: '#80d8ff', A200: '#40c4ff', A400: '#00b0ff', A700: '#0091ea', contrastDefaultColor: 'dark', contrastLightColors: '600 700 800 900 A700', contrastStrongLightColors: '600 700 800 A700', }, cyan: {50: '#e0f7fa', 100: '#b2ebf2', 200: '#80deea', 300: '#4dd0e1', 400: '#26c6da', 500: '#00bcd4', 600: '#00acc1', 700: '#0097a7', 800: '#00838f', 900: '#006064', A100: '#84ffff', A200: '#18ffff', A400: '#00e5ff', A700: '#00b8d4', contrastDefaultColor: 'dark', contrastLightColors: '700 800 900', contrastStrongLightColors: '700 800 900', }, teal: {50: '#e0f2f1', 100: '#b2dfdb', 200: '#80cbc4', 300: '#4db6ac', 400: '#26a69a', 500: '#009688', 600: '#00897b', 700: '#00796b', 800: '#00695c', 900: '#004d40', A100: '#a7ffeb', A200: '#64ffda', A400: '#1de9b6', A700: '#00bfa5', contrastDefaultColor: 'dark', contrastLightColors: '500 600 700 800 900', contrastStrongLightColors: '500 600 700', }, green: {50: '#e8f5e9', 100: '#c8e6c9', 200: '#a5d6a7', 300: '#81c784', 400: '#66bb6a', 500: '#4caf50', 600: '#43a047', 700: '#388e3c', 800: '#2e7d32', 900: '#1b5e20', A100: '#b9f6ca', A200: '#69f0ae', A400: '#00e676', A700: '#00c853', contrastDefaultColor: 'dark', contrastLightColors: '500 600 700 800 900', contrastStrongLightColors: '500 600 700', }, 'light-green': {50: '#f1f8e9', 100: '#dcedc8', 200: '#c5e1a5', 300: '#aed581', 400: '#9ccc65', 500: '#8bc34a', 600: '#7cb342', 700: '#689f38', 800: '#558b2f', 900: '#33691e', A100: '#ccff90', A200: '#b2ff59', A400: '#76ff03', A700: '#64dd17', contrastDefaultColor: 'dark', contrastLightColors: '700 800 900', contrastStrongLightColors: '700 800 900', }, lime: {50: '#f9fbe7', 100: '#f0f4c3', 200: '#e6ee9c', 300: '#dce775', 400: '#d4e157', 500: '#cddc39', 600: '#c0ca33', 700: '#afb42b', 800: '#9e9d24', 900: '#827717', A100: '#f4ff81', A200: '#eeff41', A400: '#c6ff00', A700: '#aeea00', contrastDefaultColor: 'dark', contrastLightColors: '900', contrastStrongLightColors: '900', }, yellow: {50: '#fffde7', 100: '#fff9c4', 200: '#fff59d', 300: '#fff176', 400: '#ffee58', 500: '#ffeb3b', 600: '#fdd835', 700: '#fbc02d', 800: '#f9a825', 900: '#f57f17', A100: '#ffff8d', A200: '#ffff00', A400: '#ffea00', A700: '#ffd600', contrastDefaultColor: 'dark', }, amber: {50: '#fff8e1', 100: '#ffecb3', 200: '#ffe082', 300: '#ffd54f', 400: '#ffca28', 500: '#ffc107', 600: '#ffb300', 700: '#ffa000', 800: '#ff8f00', 900: '#ff6f00', A100: '#ffe57f', A200: '#ffd740', A400: '#ffc400', A700: '#ffab00', contrastDefaultColor: 'dark', }, orange: {50: '#fff3e0', 100: '#ffe0b2', 200: '#ffcc80', 300: '#ffb74d', 400: '#ffa726', 500: '#ff9800', 600: '#fb8c00', 700: '#f57c00', 800: '#ef6c00', 900: '#e65100', A100: '#ffd180', A200: '#ffab40', A400: '#ff9100', A700: '#ff6d00', contrastDefaultColor: 'dark', contrastLightColors: '800 900', contrastStrongLightColors: '800 900', }, 'deep-orange': {50: '#fbe9e7', 100: '#ffccbc', 200: '#ffab91', 300: '#ff8a65', 400: '#ff7043', 500: '#ff5722', 600: '#f4511e', 700: '#e64a19', 800: '#d84315', 900: '#bf360c', A100: '#ff9e80', A200: '#ff6e40', A400: '#ff3d00', A700: '#dd2c00', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 300 400 A100 A200', contrastStrongLightColors: '500 600 700 800 900 A400 A700', }, brown: {50: '#efebe9', 100: '#d7ccc8', 200: '#bcaaa4', 300: '#a1887f', 400: '#8d6e63', 500: '#795548', 600: '#6d4c41', 700: '#5d4037', 800: '#4e342e', 900: '#3e2723', A100: '#d7ccc8', A200: '#bcaaa4', A400: '#8d6e63', A700: '#5d4037', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 A100 A200', contrastStrongLightColors: '300 400', }, grey: {50: '#fafafa', 100: '#f5f5f5', 200: '#eeeeee', 300: '#e0e0e0', 400: '#bdbdbd', 500: '#9e9e9e', 600: '#757575', 700: '#616161', 800: '#424242', 900: '#212121', A100: '#ffffff', A200: '#000000', A400: '#303030', A700: '#616161', contrastDefaultColor: 'dark', contrastLightColors: '600 700 800 900 A200 A400 A700', }, 'blue-grey': {50: '#eceff1', 100: '#cfd8dc', 200: '#b0bec5', 300: '#90a4ae', 400: '#78909c', 500: '#607d8b', 600: '#546e7a', 700: '#455a64', 800: '#37474f', 900: '#263238', A100: '#cfd8dc', A200: '#b0bec5', A400: '#78909c', A700: '#455a64', contrastDefaultColor: 'light', contrastDarkColors: '50 100 200 300 A100 A200', contrastStrongLightColors: '400 500 700', }, });})(); (function () {'use strict'; (function (angular) {'use strict'; detectDisabledThemes.$inject = ['$mdThemingProvider']; ThemingDirective.$inject = ['$mdTheming', '$interpolate', '$parse', '$mdUtil', '$q', '$log']; ThemableDirective.$inject = ['$mdTheming']; ThemingProvider.$inject = ['$mdColorPalette', '$$mdMetaProvider']; generateAllThemes.$inject = ['$injector', '$mdTheming']; angular .module('material.core.theming', ['material.core.theming.palette', 'material.core.meta']) .directive('mdTheme', ThemingDirective) .directive('mdThemable', ThemableDirective) .directive('mdThemesDisabled', disableThemesDirective) .provider('$mdTheming', ThemingProvider) .config(detectDisabledThemes) .run(generateAllThemes); function detectDisabledThemes($mdThemingProvider) {var isDisabled = !!document.querySelector('[md-themes-disabled]'); $mdThemingProvider.disableTheming(isDisabled);}var GENERATED = {}; var PALETTES; var DARK_FOREGROUND = {name: 'dark', 1: 'rgba(0,0,0,0.87)', 2: 'rgba(0,0,0,0.54)', 3: 'rgba(0,0,0,0.38)', 4: 'rgba(0,0,0,0.12)', }; var LIGHT_FOREGROUND = {name: 'light', 1: 'rgba(255,255,255,1.0)', 2: 'rgba(255,255,255,0.7)', 3: 'rgba(255,255,255,0.5)', 4: 'rgba(255,255,255,0.12)', }; var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)'; var LIGHT_SHADOW = ''; var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)'); var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)'); var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)'); var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background']; var DEFAULT_COLOR_TYPE = 'primary'; var LIGHT_DEFAULT_HUES = {accent: {default: 'A200', 'hue-1': 'A100', 'hue-2': 'A400', 'hue-3': 'A700', }, background: {default: '50', 'hue-1': 'A100', 'hue-2': '100', 'hue-3': '300', }, }; var DARK_DEFAULT_HUES = {background: {default: 'A400', 'hue-1': '800', 'hue-2': '900', 'hue-3': 'A200', }, }; THEME_COLOR_TYPES.forEach(function (colorType) {var defaultDefaultHues = {default: '500', 'hue-1': '300', 'hue-2': '800', 'hue-3': 'A100', }; if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues; if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;}); var VALID_HUE_VALUES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'A100', 'A200', 'A400', 'A700']; var themeConfig = {disableTheming: false, generateOnDemand: false, registeredStyles: [], nonce: null, }; function ThemingProvider($mdColorPalette, $$mdMetaProvider) {ThemingService.$inject = ['$rootScope', '$mdUtil', '$q', '$log']; PALETTES = {}; var THEMES = {}; var themingProvider; var alwaysWatchTheme = false; var defaultTheme = 'default'; angular.extend(PALETTES, $mdColorPalette); var setBrowserColor = function (color) {var removeChrome = $$mdMetaProvider.setMeta('theme-color', color); var removeWindows = $$mdMetaProvider.setMeta('msapplication-navbutton-color', color); return function () {removeChrome(); removeWindows();};}; var enableBrowserColor = function (options) {options = angular.isObject(options) ? options : {}; var theme = options.theme || 'default'; var hue = options.hue || '800'; var palette = PALETTES[options.palette] || PALETTES[THEMES[theme].colors[options.palette || 'primary'].name]; var color = angular.isObject(palette[hue]) ? palette[hue].hex : palette[hue]; return setBrowserColor(color);}; return (themingProvider = {definePalette: definePalette, extendPalette: extendPalette, theme: registerTheme, configuration: function () {return angular.extend({}, themeConfig, {defaultTheme: defaultTheme, alwaysWatchTheme: alwaysWatchTheme, registeredStyles: [].concat(themeConfig.registeredStyles), });}, disableTheming: function (isDisabled) {themeConfig.disableTheming = angular.isUndefined(isDisabled) || !!isDisabled;}, registerStyles: function (styles) {themeConfig.registeredStyles.push(styles);}, setNonce: function (nonceValue) {themeConfig.nonce = nonceValue;}, generateThemesOnDemand: function (onDemand) {themeConfig.generateOnDemand = onDemand;}, setDefaultTheme: function (theme) {defaultTheme = theme;}, alwaysWatchTheme: function (alwaysWatch) {alwaysWatchTheme = alwaysWatch;}, enableBrowserColor: enableBrowserColor, $get: ThemingService, _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES, _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES, _PALETTES: PALETTES, _THEMES: THEMES, _parseRules: parseRules, _rgba: rgba, }); function definePalette(name, map) {map = map || {}; PALETTES[name] = checkPaletteValid(name, map); return themingProvider;}function extendPalette(name, map) {return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));}function checkPaletteValid(name, map) {var missingColors = VALID_HUE_VALUES.filter(function (field) {return !map[field];}); if (missingColors.length) {throw new Error('Missing colors %1 in palette %2!'.replace('%1', missingColors.join(', ')).replace('%2', name));}return map;}function registerTheme(name, inheritFrom) {if (THEMES[name]) return THEMES[name]; inheritFrom = inheritFrom || 'default'; var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom; var theme = new Theme(name); if (parentTheme) {angular.forEach(parentTheme.colors, function (color, colorType) {theme.colors[colorType] = {name: color.name, hues: angular.extend({}, color.hues), };});}THEMES[name] = theme; return theme;}function Theme(name) {var self = this; self.name = name; self.colors = {}; self.dark = setDark; setDark(false); function setDark(isDark) {isDark = arguments.length === 0 ? true : !!isDark; if (isDark === self.isDark) return; self.isDark = isDark; self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND; self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW; var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES; var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES; angular.forEach(newDefaultHues, function (newDefaults, colorType) {var color = self.colors[colorType]; var oldDefaults = oldDefaultHues[colorType]; if (color) {for (var hueName in color.hues) {if (color.hues[hueName] === oldDefaults[hueName]) {color.hues[hueName] = newDefaults[hueName];}}}}); return self;}THEME_COLOR_TYPES.forEach(function (colorType) {var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType]; self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {var color = (self.colors[colorType] = {name: paletteName, hues: angular.extend({}, defaultHues, hues), }); Object.keys(color.hues).forEach(function (name) {if (!defaultHues[name]) {throw new Error( "Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4" .replace('%1', name) .replace('%2', self.name) .replace('%3', paletteName) .replace('%4', Object.keys(defaultHues).join(', ')), );}}); Object.keys(color.hues) .map(function (key) {return color.hues[key];}) .forEach(function (hueValue) {if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {throw new Error( "Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5" .replace('%1', hueValue) .replace('%2', self.name) .replace('%3', colorType) .replace('%4', paletteName) .replace('%5', VALID_HUE_VALUES.join(', ')), );}}); return self;}; self[colorType + 'Color'] = function () {var args = Array.prototype.slice.call(arguments); console.warn( '$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' + 'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.', ); return self[colorType + 'Palette'].apply(self, args);};});}function ThemingService($rootScope, $mdUtil, $q, $log) {var applyTheme = function (scope, el) {if (el === undefined) {el = scope; scope = undefined;}if (scope === undefined) {scope = $rootScope;}applyTheme.inherit(el, el);}; Object.defineProperty(applyTheme, 'THEMES', {get: function () {return angular.extend({}, THEMES);}, }); Object.defineProperty(applyTheme, 'PALETTES', {get: function () {return angular.extend({}, PALETTES);}, }); Object.defineProperty(applyTheme, 'ALWAYS_WATCH', {get: function () {return alwaysWatchTheme;}, }); applyTheme.inherit = inheritTheme; applyTheme.registered = registered; applyTheme.defaultTheme = function () {return defaultTheme;}; applyTheme.generateTheme = function (name) {generateTheme(THEMES[name], name, themeConfig.nonce);}; applyTheme.defineTheme = function (name, options) {options = options || {}; var theme = registerTheme(name); if (options.primary) {theme.primaryPalette(options.primary);}if (options.accent) {theme.accentPalette(options.accent);}if (options.warn) {theme.warnPalette(options.warn);}if (options.background) {theme.backgroundPalette(options.background);}if (options.dark) {theme.dark();}this.generateTheme(name); return $q.resolve(name);}; applyTheme.setBrowserColor = enableBrowserColor; return applyTheme; function registered(themeName) {if (themeName === undefined || themeName === '') return true; return applyTheme.THEMES[themeName] !== undefined;}function inheritTheme(el, parent) {var ctrl = parent.controller('mdTheme') || el.data('$mdThemeController'); updateThemeClass(lookupThemeName()); if (ctrl) {var watchTheme = alwaysWatchTheme || ctrl.$shouldWatch || $mdUtil.parseAttributeBoolean(el.attr('md-theme-watch')); var unwatch = ctrl.registerChanges(function (name) {updateThemeClass(name); if (!watchTheme) {unwatch();}else {el.on('$destroy', unwatch);}});}function lookupThemeName() {return (ctrl && ctrl.$mdTheme) || (defaultTheme == 'default' ? '' : defaultTheme);}function updateThemeClass(theme) {if (!theme) return; if (!registered(theme)) {$log.warn("Attempted to use unregistered theme '" + theme + "'. " + 'Register it with $mdThemingProvider.theme().');}var oldTheme = el.data('$mdThemeName'); if (oldTheme) el.removeClass('md-' + oldTheme + '-theme'); el.addClass('md-' + theme + '-theme'); el.data('$mdThemeName', theme); if (ctrl) {el.data('$mdThemeController', ctrl);}}}}}function ThemingDirective($mdTheming, $interpolate, $parse, $mdUtil, $q, $log) {return {priority: 101, link: {pre: function (scope, el, attrs) {var registeredCallbacks = []; var startSymbol = $interpolate.startSymbol(); var endSymbol = $interpolate.endSymbol(); var theme = attrs.mdTheme.trim(); var hasInterpolation = theme.substr(0, startSymbol.length) === startSymbol && theme.lastIndexOf(endSymbol) === theme.length - endSymbol.length; var oneTimeOperator = '::'; var oneTimeBind = attrs.mdTheme.split(startSymbol).join('').split(endSymbol).join('').trim().substr(0, oneTimeOperator.length) === oneTimeOperator; var ctrl = {registerChanges: function (cb, context) {if (context) {cb = angular.bind(context, cb);}registeredCallbacks.push(cb); return function () {var index = registeredCallbacks.indexOf(cb); if (index > -1) {registeredCallbacks.splice(index, 1);}};}, $setTheme: function (theme) {if (!$mdTheming.registered(theme)) {$log.warn("attempted to use unregistered theme '" + theme + "'");}ctrl.$mdTheme = theme; for (var i = registeredCallbacks.length; i--; ) {registeredCallbacks[i](theme);}}, $shouldWatch: $mdUtil.parseAttributeBoolean(el.attr('md-theme-watch')) || $mdTheming.ALWAYS_WATCH || (hasInterpolation && !oneTimeBind), }; el.data('$mdThemeController', ctrl); var getTheme = function () {var interpolation = $interpolate(attrs.mdTheme)(scope); return $parse(interpolation)(scope) || interpolation;}; var setParsedTheme = function (theme) {if (typeof theme === 'string') {return ctrl.$setTheme(theme);}$q.when(angular.isFunction(theme) ? theme() : theme).then(function (name) {ctrl.$setTheme(name);});}; setParsedTheme(getTheme()); var unwatch = scope.$watch(getTheme, function (theme) {if (theme) {setParsedTheme(theme); if (!ctrl.$shouldWatch) {unwatch();}}});}, }, };}function disableThemesDirective() {themeConfig.disableTheming = true; return {restrict: 'A', priority: '900', };}function ThemableDirective($mdTheming) {return $mdTheming;}function parseRules(theme, colorType, rules) {checkValidPalette(theme, colorType); rules = rules.replace(/THEME_NAME/g, theme.name); var generatedRules = []; var color = theme.colors[colorType]; var themeNameRegex = new RegExp('\\.md-' + theme.name + '-theme', 'g'); var hueRegex = new RegExp('(\'|")?{{\\s*(' + colorType + ')-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}("|\')?', 'g'); var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g; var palette = PALETTES[color.name]; rules = rules.replace(simpleVariableRegex, function (match, colorType, hue, opacity, contrast) {if (colorType === 'foreground') {if (hue == 'shadow') {return theme.foregroundShadow;}else {return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];}}if (hue.indexOf('hue') === 0 || hue === 'default') {hue = theme.colors[colorType].hues[hue];}return rgba((PALETTES[theme.colors[colorType].name][hue] || '')[contrast ? 'contrast' : 'value'], opacity);}); angular.forEach(color.hues, function (hueValue, hueName) {var newRule = rules.replace(hueRegex, function (match, _, colorType, hueType, opacity) {return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);}); if (hueName !== 'default') {newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);}if (theme.name == 'default') {var themeRuleRegex = /((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g; newRule = newRule.replace(themeRuleRegex, function (match, start, end) {return match + ', ' + start + end;});}generatedRules.push(newRule);}); return generatedRules;}var rulesByType = {}; function generateAllThemes($injector, $mdTheming) {var head = document.head; var firstChild = head ? head.firstElementChild : null; var themeCss = !themeConfig.disableTheming && $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : ''; themeCss += themeConfig.registeredStyles.join(''); if (!firstChild) return; if (themeCss.length === 0) return; angular.forEach(PALETTES, sanitizePalette); var rules = themeCss .split(/\}(?!(\}|'|"|;))/) .filter(function (rule) {return rule && rule.trim().length;}) .map(function (rule) {return rule.trim() + '}';}); var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g'); THEME_COLOR_TYPES.forEach(function (type) {rulesByType[type] = '';}); rules.forEach(function (rule) {var match = rule.match(ruleMatchRegex); for (var i = 0, type; (type = THEME_COLOR_TYPES[i]); i++) {if (rule.indexOf('.md-' + type) > -1) {return (rulesByType[type] += rule);}}for (i = 0; (type = THEME_COLOR_TYPES[i]); i++) {if (rule.indexOf(type) > -1) {return (rulesByType[type] += rule);}}return (rulesByType[DEFAULT_COLOR_TYPE] += rule);}); if (themeConfig.generateOnDemand) return; angular.forEach($mdTheming.THEMES, function (theme) {if (!GENERATED[theme.name] && !($mdTheming.defaultTheme() !== 'default' && theme.name === 'default')) {generateTheme(theme, theme.name, themeConfig.nonce);}}); function sanitizePalette(palette, name) {var defaultContrast = palette.contrastDefaultColor; var lightColors = palette.contrastLightColors || []; var strongLightColors = palette.contrastStrongLightColors || []; var darkColors = palette.contrastDarkColors || []; if (typeof lightColors === 'string') lightColors = lightColors.split(' '); if (typeof strongLightColors === 'string') strongLightColors = strongLightColors.split(' '); if (typeof darkColors === 'string') darkColors = darkColors.split(' '); delete palette.contrastDefaultColor; delete palette.contrastLightColors; delete palette.contrastStrongLightColors; delete palette.contrastDarkColors; angular.forEach(palette, function (hueValue, hueName) {if (angular.isObject(hueValue)) return; var rgbValue = colorToRgbaArray(hueValue); if (!rgbValue) {throw new Error( "Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected." .replace('%1', hueValue) .replace('%2', palette.name) .replace('%3', hueName), );}palette[hueName] = {hex: palette[hueName], value: rgbValue, contrast: getContrastColor(), }; function getContrastColor() {if (defaultContrast === 'light') {if (darkColors.indexOf(hueName) > -1) {return DARK_CONTRAST_COLOR;}else {return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;}}else {if (lightColors.indexOf(hueName) > -1) {return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;}else {return DARK_CONTRAST_COLOR;}}}});}}function generateTheme(theme, name, nonce) {var head = document.head; var firstChild = head ? head.firstElementChild : null; if (!GENERATED[name]) {THEME_COLOR_TYPES.forEach(function (colorType) {var styleStrings = parseRules(theme, colorType, rulesByType[colorType]); while (styleStrings.length) {var styleContent = styleStrings.shift(); if (styleContent) {var style = document.createElement('style'); style.setAttribute('md-theme-style', ''); if (nonce) {style.setAttribute('nonce', nonce);}style.appendChild(document.createTextNode(styleContent)); head.insertBefore(style, firstChild);}}}); GENERATED[theme.name] = true;}}function checkValidPalette(theme, colorType) {if (!PALETTES[(theme.colors[colorType] || {}).name]) {throw new Error( "You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3" .replace('%1', theme.name) .replace('%2', colorType) .replace('%3', Object.keys(PALETTES).join(', ')), );}}function colorToRgbaArray(clr) {if (angular.isArray(clr) && clr.length == 3) return clr; if (/^rgb/.test(clr)) {return clr .replace(/(^\s*rgba?\(|\)\s*$)/g, '') .split(',') .map(function (value, i) {return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);});}if (clr.charAt(0) == '#') clr = clr.substring(1); if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return; var dig = clr.length / 3; var red = clr.substr(0, dig); var grn = clr.substr(dig, dig); var blu = clr.substr(dig * 2); if (dig === 1) {red += red; grn += grn; blu += blu;}return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];}function rgba(rgbArray, opacity) {if (!rgbArray) return "rgb('0,0,0')"; if (rgbArray.length == 4) {rgbArray = angular.copy(rgbArray); opacity ? rgbArray.pop() : (opacity = rgbArray.pop());}return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ? 'rgba(' + rgbArray.join(',') + ',' + opacity + ')' : 'rgb(' + rgbArray.join(',') + ')';}})(window.angular);})(); (function () {'use strict'; angular.module('material.core').factory('$$mdAnimate', [ '$q', '$timeout', '$mdConstant', '$animateCss', function ($q, $timeout, $mdConstant, $animateCss) {return function ($mdUtil) {return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);};}, ]); function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {var self; return (self = {translate3d: function (target, from, to, options) {return $animateCss(target, {from: from, to: to, addClass: options.transitionInClass, removeClass: options.transitionOutClass, duration: options.duration, }) .start() .then(function () {return reverseTranslate;}); function reverseTranslate(newFrom) {return $animateCss(target, {to: newFrom || from, addClass: options.transitionOutClass, removeClass: options.transitionInClass, duration: options.duration, }).start();}}, waitTransitionEnd: function (element, opts) {var TIMEOUT = 3000; return $q(function (resolve, reject) {opts = opts || {}; if (noTransitionFound(opts.cachedTransitionStyles)) {TIMEOUT = 0;}var timer = $timeout(finished, opts.timeout || TIMEOUT); element.on($mdConstant.CSS.TRANSITIONEND, finished); function finished(ev) {if (ev && ev.target !== element[0]) return; if (ev) $timeout.cancel(timer); element.off($mdConstant.CSS.TRANSITIONEND, finished); resolve();}function noTransitionFound(styles) {styles = styles || window.getComputedStyle(element[0]); return styles.transitionDuration == '0s' || (!styles.transition && !styles.transitionProperty);}});}, calculateTransformValues: function (element, originator) {var origin = originator.element; var bounds = originator.bounds; if (origin || bounds) {var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds); var dialogRect = self.copyRect(element[0].getBoundingClientRect()); var dialogCenterPt = self.centerPointFor(dialogRect); var originCenterPt = self.centerPointFor(originBnds); return {centerX: originCenterPt.x - dialogCenterPt.x, centerY: originCenterPt.y - dialogCenterPt.y, scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100, scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100, };}return {centerX: 0, centerY: 0, scaleX: 0.5, scaleY: 0.5 }; function currentBounds() {var cntr = element ? element.parent() : null; var parent = cntr ? cntr.parent() : null; return parent ? self.clientRect(parent) : null;}}, calculateZoomToOrigin: function (element, originator) {var zoomTemplate = 'translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY})'; var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate); return buildZoom(self.calculateTransformValues(element, originator));}, calculateSlideToOrigin: function (element, originator) {var slideTemplate = 'translate3d( {centerX}px, {centerY}px, 0 )'; var buildSlide = angular.bind(null, $mdUtil.supplant, slideTemplate); return buildSlide(self.calculateTransformValues(element, originator));}, toCss: function (raw) {var css = {}; var lookups = 'left top right bottom width height x y min-width min-height max-width max-height'; angular.forEach(raw, function (value, key) {if (angular.isUndefined(value)) return; if (lookups.indexOf(key) >= 0) {css[key] = value + 'px';}else {switch (key) {case 'transition': convertToVendor(key, $mdConstant.CSS.TRANSITION, value); break; case 'transform': convertToVendor(key, $mdConstant.CSS.TRANSFORM, value); break; case 'transformOrigin': convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value); break; case 'font-size': css['font-size'] = value; break;}}}); return css; function convertToVendor(key, vendor, value) {angular.forEach(vendor.split(' '), function (key) {css[key] = value;});}}, toTransformCss: function (transform, addTransition, transition) {var css = {}; angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function (key) {css[key] = transform;}); if (addTransition) {transition = transition || 'all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important'; css.transition = transition;}return css;}, copyRect: function (source, destination) {if (!source) return null; destination = destination || {}; angular.forEach('left top right bottom width height'.split(' '), function (key) {destination[key] = Math.round(source[key]);}); destination.width = destination.width || destination.right - destination.left; destination.height = destination.height || destination.bottom - destination.top; return destination;}, clientRect: function (element) {var bounds = angular.element(element)[0].getBoundingClientRect(); var isPositiveSizeClientRect = function (rect) {return rect && rect.width > 0 && rect.height > 0;}; return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;}, centerPointFor: function (targetRect) {return targetRect ? {x: Math.round(targetRect.left + targetRect.width / 2), y: Math.round(targetRect.top + targetRect.height / 2), }: {x: 0, y: 0 };}, });}})(); (function () {'use strict'; if (angular.version.minor >= 4) {angular.module('material.core.animate', []);}else {(function () {'use strict'; var forEach = angular.forEach; var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance); var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition'; var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation'; var PREFIX = WEBKIT ? '-webkit-' : ''; var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend'; var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend'; var $$ForceReflowFactory = [ '$document', function ($document) {return function () {return $document[0].body.clientWidth + 1;};}, ]; var $$rAFMutexFactory = [ '$$rAF', function ($$rAF) {return function () {var passed = false; $$rAF(function () {passed = true;}); return function (fn) {passed ? fn() : $$rAF(fn);};};}, ]; var $$AnimateRunnerFactory = [ '$q', '$$rAFMutex', function ($q, $$rAFMutex) {var INITIAL_STATE = 0; var DONE_PENDING_STATE = 1; var DONE_COMPLETE_STATE = 2; function AnimateRunner(host) {this.setHost(host); this._doneCallbacks = []; this._runInAnimationFrame = $$rAFMutex(); this._state = 0;}AnimateRunner.prototype = {setHost: function (host) {this.host = host || {};}, done: function (fn) {if (this._state === DONE_COMPLETE_STATE) {fn();}else {this._doneCallbacks.push(fn);}}, progress: angular.noop, getPromise: function () {if (!this.promise) {var self = this; this.promise = $q(function (resolve, reject) {self.done(function (status) {status === false ? reject() : resolve();});});}return this.promise;}, then: function (resolveHandler, rejectHandler) {return this.getPromise().then(resolveHandler, rejectHandler);}, catch: function (handler) {return this.getPromise()['catch'](handler);}, finally: function (handler) {return this.getPromise()['finally'](handler);}, pause: function () {if (this.host.pause) {this.host.pause();}}, resume: function () {if (this.host.resume) {this.host.resume();}}, end: function () {if (this.host.end) {this.host.end();}this._resolve(true);}, cancel: function () {if (this.host.cancel) {this.host.cancel();}this._resolve(false);}, complete: function (response) {var self = this; if (self._state === INITIAL_STATE) {self._state = DONE_PENDING_STATE; self._runInAnimationFrame(function () {self._resolve(response);});}}, _resolve: function (response) {if (this._state !== DONE_COMPLETE_STATE) {forEach(this._doneCallbacks, function (fn) {fn(response);}); this._doneCallbacks.length = 0; this._state = DONE_COMPLETE_STATE;}}, }; AnimateRunner.all = function (runners, callback) {var count = 0; var status = true; forEach(runners, function (runner) {runner.done(onProgress);}); function onProgress(response) {status = status && response; if (++count === runners.length) {callback(status);}}}; return AnimateRunner;}, ]; angular .module('material.core.animate', []) .factory('$$forceReflow', $$ForceReflowFactory) .factory('$$AnimateRunner', $$AnimateRunnerFactory) .factory('$$rAFMutex', $$rAFMutexFactory) .factory('$animateCss', [ '$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', '$animate', function ($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout, $animate) {function init(element, options) {var temporaryStyles = []; var node = getDomNode(element); var areAnimationsAllowed = node && $animate.enabled(); var hasCompleteStyles = false; var hasCompleteClasses = false; if (areAnimationsAllowed) {if (options.transitionStyle) {temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);}if (options.keyframeStyle) {temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);}if (options.delay) {temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);}if (options.duration) {temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);}hasCompleteStyles = options.keyframeStyle || (options.to && (options.duration > 0 || options.transitionStyle)); hasCompleteClasses = !!options.addClass || !!options.removeClass; blockTransition(element, true);}var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses); applyAnimationFromStyles(element, options); var animationClosed = false; var events, eventFn; return {close: $window.close, start: function () {var runner = new $$AnimateRunner(); waitUntilQuiet(function () {blockTransition(element, false); if (!hasCompleteAnimation) {return close();}forEach(temporaryStyles, function (entry) {var key = entry[0]; var value = entry[1]; node.style[camelCase(key)] = value;}); applyClasses(element, options); var timings = computeTimings(element); if (timings.duration === 0) {return close();}var moreStyles = []; if (options.easing) {if (timings.transitionDuration) {moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);}if (timings.animationDuration) {moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);}}if (options.delay && timings.animationDelay) {moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);}if (options.duration && timings.animationDuration) {moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);}forEach(moreStyles, function (entry) {var key = entry[0]; var value = entry[1]; node.style[camelCase(key)] = value; temporaryStyles.push(entry);}); var maxDelay = timings.delay; var maxDelayTime = maxDelay * 1000; var maxDuration = timings.duration; var maxDurationTime = maxDuration * 1000; var startTime = Date.now(); events = []; if (timings.transitionDuration) {events.push(TRANSITION_EVENTS);}if (timings.animationDuration) {events.push(ANIMATION_EVENTS);}events = events.join(' '); eventFn = function (event) {event.stopPropagation(); var ev = event.originalEvent || event; var timeStamp = ev.timeStamp || Date.now(); var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3)); if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {close();}}; element.on(events, eventFn); applyAnimationToStyles(element, options); $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);}); return runner; function close() {if (animationClosed) return; animationClosed = true; if (events && eventFn) {element.off(events, eventFn);}applyClasses(element, options); applyAnimationStyles(element, options); forEach(temporaryStyles, function (entry) {node.style[camelCase(entry[0])] = '';}); runner.complete(true); return runner;}}, };}function applyClasses(element, options) {if (options.addClass) {$$jqLite.addClass(element, options.addClass); options.addClass = null;}if (options.removeClass) {$$jqLite.removeClass(element, options.removeClass); options.removeClass = null;}}function computeTimings(element) {var node = getDomNode(element); var cs = $window.getComputedStyle(node); var tdr = parseMaxTime(cs[prop('transitionDuration')]); var adr = parseMaxTime(cs[prop('animationDuration')]); var tdy = parseMaxTime(cs[prop('transitionDelay')]); var ady = parseMaxTime(cs[prop('animationDelay')]); adr *= parseInt(cs[prop('animationIterationCount')], 10) || 1; var duration = Math.max(adr, tdr); var delay = Math.max(ady, tdy); return {duration: duration, delay: delay, animationDuration: adr, transitionDuration: tdr, animationDelay: ady, transitionDelay: tdy, }; function prop(key) {return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1) : key;}}function parseMaxTime(str) {var maxValue = 0; var values = (str || '').split(/\s*,\s*/); forEach(values, function (value) {if (value.charAt(value.length - 1) == 's') {value = value.substring(0, value.length - 1);}value = parseFloat(value) || 0; maxValue = maxValue ? Math.max(value, maxValue) : value;}); return maxValue;}var cancelLastRAFRequest; var rafWaitQueue = []; function waitUntilQuiet(callback) {if (cancelLastRAFRequest) {cancelLastRAFRequest();}rafWaitQueue.push(callback); cancelLastRAFRequest = $$rAF(function () {cancelLastRAFRequest = null; var pageWidth = $$forceReflow(); for (var i = 0; i < rafWaitQueue.length; i++) {rafWaitQueue[i](pageWidth);}rafWaitQueue.length = 0;});}function applyAnimationStyles(element, options) {applyAnimationFromStyles(element, options); applyAnimationToStyles(element, options);}function applyAnimationFromStyles(element, options) {if (options.from) {element.css(options.from); options.from = null;}}function applyAnimationToStyles(element, options) {if (options.to) {element.css(options.to); options.to = null;}}function getDomNode(element) {for (var i = 0; i < element.length; i++) {if (element[i].nodeType === 1) return element[i];}}function blockTransition(element, bool) {var node = getDomNode(element); var key = camelCase(PREFIX + 'transition-delay'); node.style[key] = bool ? '-9999s' : '';}return init;}, ]); function camelCase(str) {return str.replace(/-[a-z]/g, function (str) {return str.charAt(1).toUpperCase();});}})();}})(); (function () {'use strict'; angular.module('material.components.autocomplete', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);})(); (function () {'use strict'; angular.module('material.components.backdrop', ['material.core']).directive('mdBackdrop', [ '$mdTheming', '$mdUtil', '$animate', '$rootElement', '$window', '$log', '$$rAF', '$document', function BackdropDirective($mdTheming, $mdUtil, $animate, $rootElement, $window, $log, $$rAF, $document) {var ERROR_CSS_POSITION = '<md-backdrop> may not work properly in a scrolled, static-positioned parent container.'; return {restrict: 'E', link: postLink, }; function postLink(scope, element, attrs) {if ($animate.pin) $animate.pin(element, $rootElement); var bodyStyles; $$rAF(function () {bodyStyles = $window.getComputedStyle($document[0].body); if (bodyStyles.position === 'fixed') {var resizeHandler = $mdUtil.debounce( function () {bodyStyles = $window.getComputedStyle($document[0].body); resize();}, 60, null, false, ); resize(); angular.element($window).on('resize', resizeHandler); scope.$on('$destroy', function () {angular.element($window).off('resize', resizeHandler);});}var parent = element.parent(); if (parent.length) {if (parent[0].nodeName === 'BODY') {element.css('position', 'fixed');}var styles = $window.getComputedStyle(parent[0]); if (styles.position === 'static') {$log.warn(ERROR_CSS_POSITION);}$mdTheming.inherit(element, parent);}}); function resize() {var viewportHeight = parseInt(bodyStyles.height, 10) + Math.abs(parseInt(bodyStyles.top, 10)); element.css('height', viewportHeight + 'px');}}}, ]);})(); (function () {'use strict'; MdBottomSheetDirective.$inject = ['$mdBottomSheet']; MdBottomSheetProvider.$inject = ['$$interimElementProvider']; angular .module('material.components.bottomSheet', ['material.core', 'material.components.backdrop']) .directive('mdBottomSheet', MdBottomSheetDirective) .provider('$mdBottomSheet', MdBottomSheetProvider); function MdBottomSheetDirective($mdBottomSheet) {return {restrict: 'E', link: function postLink(scope, element) {element.addClass('_md'); scope.$on('$destroy', function () {$mdBottomSheet.destroy();});}, };}function MdBottomSheetProvider($$interimElementProvider) {bottomSheetDefaults.$inject = ['$animate', '$mdConstant', '$mdUtil', '$mdTheming', '$mdBottomSheet', '$rootElement', '$mdGesture', '$log']; var CLOSING_VELOCITY = 0.5; var PADDING = 80; return $$interimElementProvider('$mdBottomSheet').setDefaults({methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'], options: bottomSheetDefaults, }); function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture, $log) {var backdrop; return {themable: true, onShow: onShow, onRemove: onRemove, disableBackdrop: false, escapeToClose: true, clickOutsideToClose: true, disableParentScroll: true, }; function onShow(scope, element, options, controller) {element = $mdUtil.extractElementByName(element, 'md-bottom-sheet'); element.attr('tabindex', '-1'); if (element.hasClass('ng-cloak')) {var message = '$mdBottomSheet: using `<md-bottom-sheet ng-cloak >` will affect the bottom-sheet opening animations.'; $log.warn(message, element[0]);}if (!options.disableBackdrop) {backdrop = $mdUtil.createBackdrop(scope, 'md-bottom-sheet-backdrop md-opaque'); backdrop[0].tabIndex = -1; if (options.clickOutsideToClose) {backdrop.on('click', function () {$mdUtil.nextTick($mdBottomSheet.cancel, true);});}$mdTheming.inherit(backdrop, options.parent); $animate.enter(backdrop, options.parent, null);}var bottomSheet = new BottomSheet(element, options.parent); options.bottomSheet = bottomSheet; $mdTheming.inherit(bottomSheet.element, options.parent); if (options.disableParentScroll) {options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent);}return $animate.enter(bottomSheet.element, options.parent, backdrop).then(function () {var focusable = $mdUtil.findFocusTarget(element) || angular.element( element[0].querySelector('button') || element[0].querySelector('a') || element[0].querySelector($mdUtil.prefixer('ng-click', true)), ) || backdrop; if (options.escapeToClose) {options.rootElementKeyupCallback = function (e) {if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {$mdUtil.nextTick($mdBottomSheet.cancel, true);}}; $rootElement.on('keyup', options.rootElementKeyupCallback); focusable && focusable.focus();}});}function onRemove(scope, element, options) {var bottomSheet = options.bottomSheet; if (!options.disableBackdrop) $animate.leave(backdrop); return $animate.leave(bottomSheet.element).then(function () {if (options.disableParentScroll) {options.restoreScroll(); delete options.restoreScroll;}bottomSheet.cleanup();});}function BottomSheet(element, parent) {var deregister = $mdGesture.register(parent, 'drag', {horizontal: false }); parent.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd); return {element: element, cleanup: function cleanup() {deregister(); parent.off('$md.dragstart', onDragStart); parent.off('$md.drag', onDrag); parent.off('$md.dragend', onDragEnd);}, }; function onDragStart(ev) {element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');}function onDrag(ev) {var transform = ev.pointer.distanceY; if (transform < 5) {transform = Math.max(-PADDING, transform / 2);}element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');}function onDragEnd(ev) {if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY; var transitionDuration = Math.min((distanceRemaining / ev.pointer.velocityY) * 0.75, 500); element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms'); $mdUtil.nextTick($mdBottomSheet.cancel, true);}else {element.css($mdConstant.CSS.TRANSITION_DURATION, ''); element.css($mdConstant.CSS.TRANSFORM, '');}}}}}})(); (function () {'use strict'; MdButtonDirective.$inject = ['$mdButtonInkRipple', '$mdTheming', '$mdAria', '$mdInteraction']; MdAnchorDirective.$inject = ['$mdTheming']; angular.module('material.components.button', ['material.core']).directive('mdButton', MdButtonDirective).directive('a', MdAnchorDirective); function MdAnchorDirective($mdTheming) {return {restrict: 'E', link: function postLink(scope, element) {$mdTheming(element);}, };}function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $mdInteraction) {return {restrict: 'EA', replace: true, transclude: true, template: getTemplate, link: postLink, }; function isAnchor(attr) {return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);}function getTemplate(element, attr) {if (isAnchor(attr)) {return '<a class="md-button" ng-transclude></a>';}else {var btnType = typeof attr.type === 'undefined' ? 'button' : attr.type; return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';}}function postLink(scope, element, attr) {$mdTheming(element); $mdButtonInkRipple.attach(scope, element); $mdAria.expectWithoutText(element, 'aria-label'); if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {scope.$watch(attr.ngDisabled, function (isDisabled) {element.attr('tabindex', isDisabled ? -1 : 0);});}element.on('click', function (e) {if (attr.disabled === true) {e.preventDefault(); e.stopImmediatePropagation();}}); if (!element.hasClass('md-no-focus')) {element.on('focus', function () {if (!$mdInteraction.isUserInvoked() || $mdInteraction.getLastInteractionType() === 'keyboard') {element.addClass('md-focused');}}); element.on('blur', function () {element.removeClass('md-focused');});}}}})(); (function () {'use strict'; mdCardDirective.$inject = ['$mdTheming']; angular.module('material.components.card', ['material.core']).directive('mdCard', mdCardDirective); function mdCardDirective($mdTheming) {return {restrict: 'E', link: function ($scope, $element, attr) {$element.addClass('_md'); $mdTheming($element);}, };}})(); (function () {'use strict'; angular.module('material.components.chips', ['material.core', 'material.components.autocomplete']);})(); (function () {'use strict'; MdCheckboxDirective.$inject = ['inputDirective', '$mdAria', '$mdConstant', '$mdTheming', '$mdUtil', '$mdInteraction']; angular.module('material.components.checkbox', ['material.core']).directive('mdCheckbox', MdCheckboxDirective); function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $mdInteraction) {inputDirective = inputDirective[0]; return {restrict: 'E', transclude: true, require: ['^?mdInputContainer', '?ngModel', '?^form'], priority: $mdConstant.BEFORE_NG_ARIA, template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>', compile: compile, }; function compile(tElement, tAttrs) {tAttrs.$set('tabindex', tAttrs.tabindex || '0'); tAttrs.$set('type', 'checkbox'); tAttrs.$set('role', tAttrs.type); return {pre: function (scope, element) {element.on('click', function (e) {if (this.hasAttribute('disabled')) {e.stopImmediatePropagation();}});}, post: postLink, }; function postLink(scope, element, attr, ctrls) {var isIndeterminate; var containerCtrl = ctrls[0]; var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(); var formCtrl = ctrls[2]; if (containerCtrl) {var isErrorGetter = containerCtrl.isErrorGetter || function () {return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (formCtrl && formCtrl.$submitted));}; containerCtrl.input = element; scope.$watch(isErrorGetter, containerCtrl.setInvalid);}$mdTheming(element); element.children().on('focus', function () {element.focus();}); if ($mdUtil.parseAttributeBoolean(attr.mdIndeterminate)) {setIndeterminateState(); scope.$watch(attr.mdIndeterminate, setIndeterminateState);}if (attr.ngChecked) {scope.$watch(scope.$eval.bind(scope, attr.ngChecked), function (value) {ngModelCtrl.$setViewValue(value); ngModelCtrl.$render();});}$$watchExpr('ngDisabled', 'tabindex', {true: '-1', false: attr.tabindex, }); $mdAria.expectWithText(element, 'aria-label'); inputDirective.link.pre( scope, {on: angular.noop, 0: {}, }, attr, [ngModelCtrl], ); element .on('click', listener) .on('keypress', keypressHandler) .on('focus', function () {if ($mdInteraction.getLastInteractionType() === 'keyboard') {element.addClass('md-focused');}}) .on('blur', function () {element.removeClass('md-focused');}); ngModelCtrl.$render = render; function $$watchExpr(expr, htmlAttr, valueOpts) {if (attr[expr]) {scope.$watch(attr[expr], function (val) {if (valueOpts[val]) {element.attr(htmlAttr, valueOpts[val]);}});}}function keypressHandler(ev) {var keyCode = ev.which || ev.keyCode; if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {ev.preventDefault(); element.addClass('md-focused'); listener(ev);}}function listener(ev) {if (element[0].hasAttribute('disabled') || scope.skipToggle) {return;}scope.$apply(function () {var viewValue = attr.ngChecked && attr.ngClick ? attr.checked : !ngModelCtrl.$viewValue; ngModelCtrl.$setViewValue(viewValue, ev && ev.type); ngModelCtrl.$render();});}function render() {element.toggleClass('md-checked', !!ngModelCtrl.$viewValue && !isIndeterminate);}function setIndeterminateState(newValue) {isIndeterminate = newValue !== false; if (isIndeterminate) {element.attr('aria-checked', 'mixed');}element.toggleClass('md-indeterminate', isIndeterminate);}}}}})(); (function () {'use strict'; (function () {'use strict'; MdColorsDirective.$inject = ['$mdColors', '$mdUtil', '$log', '$parse']; MdColorsService.$inject = ['$mdTheming', '$mdUtil', '$log']; var STATIC_COLOR_EXPRESSION = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/; var colorPalettes = null; angular.module('material.components.colors', ['material.core']).directive('mdColors', MdColorsDirective).service('$mdColors', MdColorsService); function MdColorsService($mdTheming, $mdUtil, $log) {colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES); return {applyThemeColors: applyThemeColors, getThemeColor: getThemeColor, hasTheme: hasTheme, }; function applyThemeColors(element, colorExpression) {try {if (colorExpression) {element.css(interpolateColors(colorExpression));}}catch (e) {$log.error(e.message);}}function getThemeColor(expression) {var color = extractColorOptions(expression); return parseColor(color);}function parseColor(color, contrast) {contrast = contrast || false; var rgbValues = $mdTheming.PALETTES[color.palette][color.hue]; rgbValues = contrast ? rgbValues.contrast : rgbValues.value; return $mdUtil.supplant('rgba({0}, {1}, {2}, {3})', [rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity]);}function interpolateColors(themeColors) {var rgbColors = {}; var hasColorProperty = themeColors.hasOwnProperty('color'); angular.forEach(themeColors, function (value, key) {var color = extractColorOptions(value); var hasBackground = key.indexOf('background') > -1; rgbColors[key] = parseColor(color); if (hasBackground && !hasColorProperty) {rgbColors.color = parseColor(color, true);}}); return rgbColors;}function hasTheme(expression) {return angular.isDefined($mdTheming.THEMES[expression.split('-')[0]]);}function extractColorOptions(expression) {var parts = expression.split('-'); var hasTheme = angular.isDefined($mdTheming.THEMES[parts[0]]); var theme = hasTheme ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme(); return {theme: theme, palette: extractPalette(parts, theme), hue: extractHue(parts, theme), opacity: parts[2] || 1, };}function extractPalette(parts, theme) {var isTwoWord = parts.length > 1 && colorPalettes.indexOf(parts[1]) !== -1; var palette = parts[0].replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(); if (isTwoWord) palette = parts[0] + '-' + parts.splice(1, 1); if (colorPalettes.indexOf(palette) === -1) {var scheme = $mdTheming.THEMES[theme].colors[palette]; if (!scheme) {throw new Error($mdUtil.supplant("mdColors: couldn't find '{palette}' in the palettes.", {palette: palette }));}palette = scheme.name;}return palette;}function extractHue(parts, theme) {var themeColors = $mdTheming.THEMES[theme].colors; if (parts[1] === 'hue') {var hueNumber = parseInt(parts.splice(2, 1)[0], 10); if (hueNumber < 1 || hueNumber > 3) {throw new Error( $mdUtil.supplant("mdColors: 'hue-{hueNumber}' is not a valid hue, can be only 'hue-1', 'hue-2' and 'hue-3'", {hueNumber: hueNumber }), );}parts[1] = 'hue-' + hueNumber; if (!(parts[0] in themeColors)) {throw new Error( $mdUtil.supplant("mdColors: 'hue-x' can only be used with [{availableThemes}], but was used with '{usedTheme}'", {availableThemes: Object.keys(themeColors).join(', '), usedTheme: parts[0], }), );}return themeColors[parts[0]].hues[parts[1]];}return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : 'primary'].hues['default'];}}function MdColorsDirective($mdColors, $mdUtil, $log, $parse) {return {restrict: 'A', require: ['^?mdTheme'], compile: function (tElem, tAttrs) {var shouldWatch = shouldColorsWatch(); return function (scope, element, attrs, ctrl) {var mdThemeController = ctrl[0]; var lastColors = {}; var parseColors = function (theme) {if (typeof theme !== 'string') {theme = '';}if (!attrs.mdColors) {attrs.mdColors = '{}';}var colors = $parse(attrs.mdColors)(scope); if (mdThemeController) {Object.keys(colors).forEach(function (prop) {var color = colors[prop]; if (!$mdColors.hasTheme(color)) {colors[prop] = (theme || mdThemeController.$mdTheme) + '-' + color;}});}cleanElement(colors); return colors;}; var cleanElement = function (colors) {if (!angular.equals(colors, lastColors)) {var keys = Object.keys(lastColors); if (lastColors.background && !keys.color) {keys.push('color');}keys.forEach(function (key) {element.css(key, '');});}lastColors = colors;}; var unregisterChanges = angular.noop; if (mdThemeController) {unregisterChanges = mdThemeController.registerChanges(function (theme) {$mdColors.applyThemeColors(element, parseColors(theme));});}scope.$on('$destroy', function () {unregisterChanges();}); try {if (shouldWatch) {scope.$watch(parseColors, angular.bind(this, $mdColors.applyThemeColors, element), true);}else {$mdColors.applyThemeColors(element, parseColors());}}catch (e) {$log.error(e.message);}}; function shouldColorsWatch() {var rawColorExpression = tAttrs.mdColors; var bindOnce = rawColorExpression.indexOf('::') > -1; var isStatic = bindOnce ? true : STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors); tAttrs.mdColors = rawColorExpression.replace('::', ''); var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch); return bindOnce || isStatic ? false : hasWatchAttr ? $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch) : true;}}, };}})();})(); (function () {'use strict'; mdContentDirective.$inject = ['$mdTheming']; angular.module('material.components.content', ['material.core']).directive('mdContent', mdContentDirective); function mdContentDirective($mdTheming) {return {restrict: 'E', controller: ['$scope', '$element', ContentController], link: function (scope, element) {element.addClass('_md'); $mdTheming(element); scope.$broadcast('$mdContentLoaded', element); iosScrollFix(element[0]);}, }; function ContentController($scope, $element) {this.$scope = $scope; this.$element = $element;}}function iosScrollFix(node) {angular.element(node).on('$md.pressdown', function (ev) {if (ev.pointer.type !== 't') return; if (ev.$materialScrollFixed) return; ev.$materialScrollFixed = true; if (node.scrollTop === 0) {node.scrollTop = 1;}else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {node.scrollTop -= 1;}});}})(); (function () {'use strict'; angular.module('material.components.datepicker', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);})(); (function () {'use strict'; MdDialogDirective.$inject = ['$$rAF', '$mdTheming', '$mdDialog']; MdDialogProvider.$inject = ['$$interimElementProvider']; angular .module('material.components.dialog', ['material.core', 'material.components.backdrop']) .directive('mdDialog', MdDialogDirective) .provider('$mdDialog', MdDialogProvider); function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {return {restrict: 'E', link: function (scope, element) {element.addClass('_md'); $mdTheming(element); $$rAF(function () {var images; var content = element[0].querySelector('md-dialog-content'); if (content) {images = content.getElementsByTagName('img'); addOverflowClass(); angular.element(images).on('load', addOverflowClass);}scope.$on('$destroy', function () {$mdDialog.destroy(element);}); function addOverflowClass() {element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);}});}, };}function MdDialogProvider($$interimElementProvider) {MdDialogController.$inject = ['$mdDialog', '$mdConstant']; dialogDefaultOptions.$inject = [ '$mdDialog', '$mdAria', '$mdUtil', '$mdConstant', '$animate', '$document', '$window', '$rootElement', '$log', '$injector', '$mdTheming', '$interpolate', '$mdInteraction', ]; var topFocusTrap, bottomFocusTrap; return $$interimElementProvider('$mdDialog') .setDefaults({methods: [ 'disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen', 'multiple', ], options: dialogDefaultOptions, }) .addPreset('alert', {methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme', 'css'], options: advancedDialogOptions, }) .addPreset('confirm', {methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'], options: advancedDialogOptions, }) .addPreset('prompt', {methods: ['title', 'htmlContent', 'textContent', 'initialValue', 'content', 'placeholder', 'ariaLabel', 'ok', 'cancel', 'theme', 'css', 'required'], options: advancedDialogOptions, }); function advancedDialogOptions() {return {template: [ '<md-dialog md-theme="{{dialog.theme || dialog.defaultTheme }}" aria-label="{{dialog.ariaLabel }}" ng-class="dialog.css">', ' <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', ' <h2 class="md-title">{{dialog.title }}</h2>', ' <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', ' ng-bind-html="::dialog.mdHtmlContent"></div>', ' <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', ' <p>{{::dialog.mdTextContent}}</p>', ' </div>', ' <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', ' <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" ' + ' placeholder="{{::dialog.placeholder}}" ng-required="dialog.required">', ' </md-input-container>', ' </md-dialog-content>', ' <md-dialog-actions>', " <md-button ng-if=\"dialog.$type === 'confirm' || dialog.$type === 'prompt'\"" + ' ng-click="dialog.abort()" class="md-primary md-cancel-button">', ' {{dialog.cancel }}', ' </md-button>', ' <md-button ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"' + ' ng-disabled="dialog.required && !dialog.result">', ' {{dialog.ok }}', ' </md-button>', ' </md-dialog-actions>', '</md-dialog>', ] .join('') .replace(/\s\s+/g, ''), controller: MdDialogController, controllerAs: 'dialog', bindToController: true, };}function MdDialogController($mdDialog, $mdConstant) {this.$onInit = function () {var isPrompt = this.$type == 'prompt'; if (isPrompt && this.initialValue) {this.result = this.initialValue;}this.hide = function () {$mdDialog.hide(isPrompt ? this.result : true);}; this.abort = function () {$mdDialog.cancel();}; this.keypress = function ($event) {if ($event.keyCode === $mdConstant.KEY_CODE.ENTER) {$mdDialog.hide(this.result);}};};}function dialogDefaultOptions( $mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector, $mdTheming, $interpolate, $mdInteraction, ) {return {hasBackdrop: true, isolateScope: true, onCompiling: beforeCompile, onShow: onShow, onShowing: beforeShow, onRemove: onRemove, clickOutsideToClose: false, escapeToClose: true, targetEvent: null, closeTo: null, openFrom: null, focusOnOpen: true, disableParentScroll: true, autoWrap: true, fullscreen: false, transformTemplate: function (template, options) {var startSymbol = $interpolate.startSymbol(); var endSymbol = $interpolate.endSymbol(); var theme = startSymbol + (options.themeWatch ? '' : '::') + 'theme' + endSymbol; return '<div class="md-dialog-container" tabindex="-1" md-theme="' + theme + '">' + validatedTemplate(template) + '</div>'; function validatedTemplate(template) {if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {return '<md-dialog>' + (template || '') + '</md-dialog>';}else {return template || '';}}}, }; function beforeCompile(options) {options.defaultTheme = $mdTheming.defaultTheme(); detectTheming(options);}function beforeShow(scope, element, options, controller) {if (controller) {var mdHtmlContent = controller.htmlContent || options.htmlContent || ''; var mdTextContent = controller.textContent || options.textContent || controller.content || options.content || ''; if (mdHtmlContent && !$injector.has('$sanitize')) {throw Error('The ngSanitize module must be loaded in order to use htmlContent.');}if (mdHtmlContent && mdTextContent) {throw Error('md-dialog cannot have both `htmlContent` and `textContent`');}controller.mdHtmlContent = mdHtmlContent; controller.mdTextContent = mdTextContent;}}function onShow(scope, element, options, controller) {angular.element($document[0].body).addClass('md-dialog-is-showing'); var dialogElement = element.find('md-dialog'); if (dialogElement.hasClass('ng-cloak')) {var message = '$mdDialog: using `<md-dialog ng-cloak>` will affect the dialog opening animations.'; $log.warn(message, element[0]);}captureParentAndFromToElements(options); configureAria(dialogElement, options); showBackdrop(scope, element, options); activateListeners(element, options); return dialogPopIn(element, options).then(function () {lockScreenReader(element, options); warnDeprecatedActions(); focusOnOpen();}); function warnDeprecatedActions() {if (element[0].querySelector('.md-actions')) {$log.warn('Using a class of md-actions is deprecated, please use <md-dialog-actions>.');}}function focusOnOpen() {if (options.focusOnOpen) {var target = $mdUtil.findFocusTarget(element) || findCloseButton() || dialogElement; target.focus();}function findCloseButton() {return element[0].querySelector('.dialog-close, md-dialog-actions button:last-child');}}}function onRemove(scope, element, options) {options.deactivateListeners(); options.unlockScreenReader(); options.hideBackdrop(options.$destroy); if (topFocusTrap && topFocusTrap.parentNode) {topFocusTrap.parentNode.removeChild(topFocusTrap);}if (bottomFocusTrap && bottomFocusTrap.parentNode) {bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);}return !!options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean); function animateRemoval() {return dialogPopOut(element, options);}function detachAndClean() {angular.element($document[0].body).removeClass('md-dialog-is-showing'); if (options.contentElement) {options.reverseContainerStretch();}options.cleanupElement(); if (!options.$destroy && options.originInteraction === 'keyboard') {options.origin.focus();}}}function detectTheming(options) {var targetEl; if (options.targetEvent && options.targetEvent.target) {targetEl = angular.element(options.targetEvent.target);}var themeCtrl = targetEl && targetEl.controller('mdTheme'); if (!themeCtrl) {return;}options.themeWatch = themeCtrl.$shouldWatch; var theme = options.theme || themeCtrl.$mdTheme; if (theme) {options.scope.theme = theme;}var unwatch = themeCtrl.registerChanges(function (newTheme) {options.scope.theme = newTheme; if (!options.themeWatch) {unwatch();}});}function captureParentAndFromToElements(options) {options.origin = angular.extend( {element: null, bounds: null, focus: angular.noop, }, options.origin || {}, ); options.parent = getDomElement(options.parent, $rootElement); options.closeTo = getBoundingClientRect(getDomElement(options.closeTo)); options.openFrom = getBoundingClientRect(getDomElement(options.openFrom)); if (options.targetEvent) {options.origin = getBoundingClientRect(options.targetEvent.target, options.origin); options.originInteraction = $mdInteraction.getLastInteractionType();}function getBoundingClientRect(element, orig) {var source = angular.element(element || {}); if (source && source.length) {var bounds = {top: 0, left: 0, height: 0, width: 0 }; var hasFn = angular.isFunction(source[0].getBoundingClientRect); return angular.extend(orig || {}, {element: hasFn ? source : undefined, bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]), focus: angular.bind(source, source.focus), });}}function getDomElement(element, defaultElement) {if (angular.isString(element)) {element = $document[0].querySelector(element);}return angular.element(element || defaultElement);}}function activateListeners(element, options) {var window = angular.element($window); var onWindowResize = $mdUtil.debounce(function () {stretchDialogContainerToViewport(element, options);}, 60); var removeListeners = []; var smartClose = function () {var closeFn = options.$type == 'alert' ? $mdDialog.hide : $mdDialog.cancel; $mdUtil.nextTick(closeFn, true);}; if (options.escapeToClose) {var parentTarget = options.parent; var keyHandlerFn = function (ev) {if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {ev.stopPropagation(); ev.preventDefault(); smartClose();}}; element.on('keydown', keyHandlerFn); parentTarget.on('keydown', keyHandlerFn); removeListeners.push(function () {element.off('keydown', keyHandlerFn); parentTarget.off('keydown', keyHandlerFn);});}window.on('resize', onWindowResize); removeListeners.push(function () {window.off('resize', onWindowResize);}); if (options.clickOutsideToClose) {var target = element; var sourceElem; var mousedownHandler = function (ev) {sourceElem = ev.target;}; var mouseupHandler = function (ev) {if (sourceElem === target[0] && ev.target === target[0]) {ev.stopPropagation(); ev.preventDefault(); smartClose();}}; target.on('mousedown', mousedownHandler); target.on('mouseup', mouseupHandler); removeListeners.push(function () {target.off('mousedown', mousedownHandler); target.off('mouseup', mouseupHandler);});}options.deactivateListeners = function () {removeListeners.forEach(function (removeFn) {removeFn();}); options.deactivateListeners = null;};}function showBackdrop(scope, element, options) {if (options.disableParentScroll) {options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);}if (options.hasBackdrop) {options.backdrop = $mdUtil.createBackdrop(scope, 'md-dialog-backdrop md-opaque'); $animate.enter(options.backdrop, options.parent);}options.hideBackdrop = function hideBackdrop($destroy) {if (options.backdrop) {if (!!$destroy) options.backdrop.remove(); else $animate.leave(options.backdrop);}if (options.disableParentScroll) {options.restoreScroll && options.restoreScroll(); delete options.restoreScroll;}options.hideBackdrop = null;};}function configureAria(element, options) {var role = options.$type === 'alert' ? 'alertdialog' : 'dialog'; var dialogContent = element.find('md-dialog-content'); var existingDialogId = element.attr('id'); var dialogContentId = 'dialogContent_' + (existingDialogId || $mdUtil.nextUid()); element.attr({role: role, tabIndex: '-1', }); if (dialogContent.length === 0) {dialogContent = element; if (existingDialogId) {dialogContentId = existingDialogId;}}dialogContent.attr('id', dialogContentId); element.attr('aria-describedby', dialogContentId); if (options.ariaLabel) {$mdAria.expect(element, 'aria-label', options.ariaLabel);}else {$mdAria.expectAsync(element, 'aria-label', function () {if (options.title) {return options.title;}else {var words = dialogContent.text().split(/\s+/); if (words.length > 3) words = words.slice(0, 3).concat('...'); return words.join(' ');}});}topFocusTrap = document.createElement('div'); topFocusTrap.classList.add('md-dialog-focus-trap'); topFocusTrap.tabIndex = 0; bottomFocusTrap = topFocusTrap.cloneNode(false); var focusHandler = function () {element.focus();}; topFocusTrap.addEventListener('focus', focusHandler); bottomFocusTrap.addEventListener('focus', focusHandler); element[0].parentNode.insertBefore(topFocusTrap, element[0]); element.after(bottomFocusTrap);}function lockScreenReader(element, options) {var isHidden = true; walkDOM(element[0]); options.unlockScreenReader = function () {isHidden = false; walkDOM(element[0]); options.unlockScreenReader = null;}; function walkDOM(element) {while (element.parentNode) {if (element === document.body) {return;}var children = element.parentNode.children; for (var i = 0; i < children.length; i++) {if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE']) && !children[i].hasAttribute('aria-live')) {children[i].setAttribute('aria-hidden', isHidden);}}walkDOM((element = element.parentNode));}}}function stretchDialogContainerToViewport(container, options) {var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed'; var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null; var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0; var previousStyles = {top: container.css('top'), height: container.css('height'), }; var parentTop = Math.abs(options.parent[0].getBoundingClientRect().top); container.css({top: (isFixed ? parentTop : 0) + 'px', height: height ? height + 'px' : '100%', }); return function () {container.css(previousStyles);};}function dialogPopIn(container, options) {options.parent.append(container); options.reverseContainerStretch = stretchDialogContainerToViewport(container, options); var dialogEl = container.find('md-dialog'); var animator = $mdUtil.dom.animator; var buildTranslateToOrigin = animator.calculateZoomToOrigin; var translateOptions = {transitionInClass: 'md-transition-in', transitionOutClass: 'md-transition-out' }; var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin)); var to = animator.toTransformCss(''); dialogEl.toggleClass('md-dialog-fullscreen', !!options.fullscreen); return animator.translate3d(dialogEl, from, to, translateOptions).then(function (animateReversal) {options.reverseAnimate = function () {delete options.reverseAnimate; if (options.closeTo) {translateOptions = {transitionInClass: 'md-transition-out', transitionOutClass: 'md-transition-in' }; from = to; to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo)); return animator.translate3d(dialogEl, from, to, translateOptions);}return animateReversal( (to = animator.toTransformCss( buildTranslateToOrigin(dialogEl, options.origin), )), );}; options.clearAnimate = function () {delete options.clearAnimate; dialogEl.removeClass([translateOptions.transitionOutClass, translateOptions.transitionInClass].join(' ')); return animator.translate3d(dialogEl, to, animator.toTransformCss(''), {});}; return true;});}function dialogPopOut(container, options) {return options.reverseAnimate().then(function () {if (options.contentElement) {options.clearAnimate();}});}function isNodeOneOf(elem, nodeTypeArray) {if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {return true;}}}}})(); (function () {'use strict'; MdDividerDirective.$inject = ['$mdTheming']; angular.module('material.components.divider', ['material.core']).directive('mdDivider', MdDividerDirective); function MdDividerDirective($mdTheming) {return {restrict: 'E', link: $mdTheming, };}})(); (function () {'use strict'; (function () {'use strict'; MdFabActionsDirective.$inject = ['$mdUtil']; angular.module('material.components.fabActions', ['material.core']).directive('mdFabActions', MdFabActionsDirective); function MdFabActionsDirective($mdUtil) {return {restrict: 'E', require: ['^?mdFabSpeedDial', '^?mdFabToolbar'], compile: function (element, attributes) {var children = element.children(); var hasNgRepeat = $mdUtil.prefixer().hasAttribute(children, 'ng-repeat'); if (hasNgRepeat) {children.addClass('md-fab-action-item');}else {children.wrap('<div class="md-fab-action-item">');}}, };}})();})(); (function () {'use strict'; (function () {'use strict'; MdFabController.$inject = ['$scope', '$element', '$animate', '$mdUtil', '$mdConstant', '$timeout']; angular.module('material.components.fabShared', ['material.core']).controller('MdFabController', MdFabController); function MdFabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {var vm = this; var initialAnimationAttempts = 0; vm.open = function () {$scope.$evalAsync('vm.isOpen = true');}; vm.close = function () {$scope.$evalAsync('vm.isOpen = false'); $element.find('md-fab-trigger')[0].focus();}; vm.toggle = function () {$scope.$evalAsync('vm.isOpen = !vm.isOpen');}; vm.$onInit = function () {setupDefaults(); setupListeners(); setupWatchers(); fireInitialAnimations();}; if (angular.version.major === 1 && angular.version.minor <= 4) {this.$onInit();}function setupDefaults() {vm.direction = vm.direction || 'down'; vm.isOpen = vm.isOpen || false; resetActionIndex(); $element.addClass('md-animations-waiting');}function setupListeners() {var eventTypes = ['click', 'focusin', 'focusout']; angular.forEach(eventTypes, function (eventType) {$element.on(eventType, parseEvents);}); $scope.$on('$destroy', function () {angular.forEach(eventTypes, function (eventType) {$element.off(eventType, parseEvents);}); disableKeyboard();});}var closeTimeout; function parseEvents(event) {if (event.type == 'click') {handleItemClick(event);}if (event.type == 'focusout' && !closeTimeout) {closeTimeout = $timeout( function () {vm.close();}, 100, false, );}if (event.type == 'focusin' && closeTimeout) {$timeout.cancel(closeTimeout); closeTimeout = null;}}function resetActionIndex() {vm.currentActionIndex = -1;}function setupWatchers() {$scope.$watch('vm.direction', function (newDir, oldDir) {$animate.removeClass($element, 'md-' + oldDir); $animate.addClass($element, 'md-' + newDir); resetActionIndex();}); var trigger, actions; $scope.$watch('vm.isOpen', function (isOpen) {resetActionIndex(); if (!trigger || !actions) {trigger = getTriggerElement(); actions = getActionsElement();}if (isOpen) {enableKeyboard();}else {disableKeyboard();}var toAdd = isOpen ? 'md-is-open' : ''; var toRemove = isOpen ? '' : 'md-is-open'; trigger.attr('aria-haspopup', true); trigger.attr('aria-expanded', isOpen); actions.attr('aria-hidden', !isOpen); $animate.setClass($element, toAdd, toRemove);});}function fireInitialAnimations() {if ($element[0].scrollHeight > 0) {$animate.addClass($element, '_md-animations-ready').then(function () {$element.removeClass('md-animations-waiting');});}else if (initialAnimationAttempts < 10) {$timeout(fireInitialAnimations, 100); initialAnimationAttempts = initialAnimationAttempts + 1;}}function enableKeyboard() {$element.on('keydown', keyPressed); $mdUtil.nextTick(function () {angular.element(document).on('click touchend', checkForOutsideClick);});}function disableKeyboard() {$element.off('keydown', keyPressed); angular.element(document).off('click touchend', checkForOutsideClick);}function checkForOutsideClick(event) {if (event.target) {var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger'); var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions'); if (!closestTrigger && !closestActions) {vm.close();}}}function keyPressed(event) {switch (event.which) {case $mdConstant.KEY_CODE.ESCAPE: vm.close(); event.preventDefault(); return false; case $mdConstant.KEY_CODE.LEFT_ARROW: doKeyLeft(event); return false; case $mdConstant.KEY_CODE.UP_ARROW: doKeyUp(event); return false; case $mdConstant.KEY_CODE.RIGHT_ARROW: doKeyRight(event); return false; case $mdConstant.KEY_CODE.DOWN_ARROW: doKeyDown(event); return false;}}function doActionPrev(event) {focusAction(event, -1);}function doActionNext(event) {focusAction(event, 1);}function focusAction(event, direction) {var actions = resetActionTabIndexes(); vm.currentActionIndex = vm.currentActionIndex + direction; vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex); vm.currentActionIndex = Math.max(0, vm.currentActionIndex); var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0]; angular.element(focusElement).attr('tabindex', 0); focusElement.focus(); event.preventDefault(); event.stopImmediatePropagation();}function resetActionTabIndexes() {var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item'); angular.forEach(actions, function (action) {angular.element(angular.element(action).children()[0]).attr('tabindex', -1);}); return actions;}function doKeyLeft(event) {if (vm.direction === 'left') {doActionNext(event);}else {doActionPrev(event);}}function doKeyUp(event) {if (vm.direction === 'down') {doActionPrev(event);}else {doActionNext(event);}}function doKeyRight(event) {if (vm.direction === 'left') {doActionPrev(event);}else {doActionNext(event);}}function doKeyDown(event) {if (vm.direction === 'up') {doActionPrev(event);}else {doActionNext(event);}}function isTrigger(element) {return $mdUtil.getClosest(element, 'md-fab-trigger');}function isAction(element) {return $mdUtil.getClosest(element, 'md-fab-actions');}function handleItemClick(event) {if (isTrigger(event.target)) {vm.toggle();}if (isAction(event.target)) {vm.close();}}function getTriggerElement() {return $element.find('md-fab-trigger');}function getActionsElement() {return $element.find('md-fab-actions');}}})();})(); (function () {'use strict'; (function () {'use strict'; MdFabSpeedDialFlingAnimation.$inject = ['$timeout']; MdFabSpeedDialScaleAnimation.$inject = ['$timeout']; var cssAnimationDuration = 300; angular .module('material.components.fabSpeedDial', ['material.core', 'material.components.fabShared', 'material.components.fabActions']) .directive('mdFabSpeedDial', MdFabSpeedDialDirective) .animation('.md-fling', MdFabSpeedDialFlingAnimation) .animation('.md-scale', MdFabSpeedDialScaleAnimation) .service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation) .service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation); function MdFabSpeedDialDirective() {return {restrict: 'E', scope: {direction: '@?mdDirection', isOpen: '=?mdOpen', }, bindToController: true, controller: 'MdFabController', controllerAs: 'vm', link: FabSpeedDialLink, }; function FabSpeedDialLink(scope, element) {element.prepend('<div class="_md-css-variables"></div>');}}function MdFabSpeedDialFlingAnimation($timeout) {function delayDone(done) {$timeout(done, cssAnimationDuration, false);}function runAnimation(element) {if (element.hasClass('md-animations-waiting') && !element.hasClass('_md-animations-ready')) {return;}var el = element[0]; var ctrl = element.controller('mdFabSpeedDial'); var items = el.querySelectorAll('.md-fab-action-item'); var triggerElement = el.querySelector('md-fab-trigger'); var variablesElement = el.querySelector('._md-css-variables'); var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex); angular.forEach(items, function (item, index) {var styles = item.style; styles.transform = styles.webkitTransform = ''; styles.transitionDelay = ''; styles.opacity = 1; styles.zIndex = items.length - index + startZIndex;}); triggerElement.style.zIndex = startZIndex + items.length + 1; if (!ctrl.isOpen) {angular.forEach(items, function (item, index) {var newPosition, axis; var styles = item.style; var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2; var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2; switch (ctrl.direction) {case 'up': newPosition = item.scrollHeight * (index + 1) + triggerItemHeightOffset; axis = 'Y'; break; case 'down': newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset); axis = 'Y'; break; case 'left': newPosition = item.scrollWidth * (index + 1) + triggerItemWidthOffset; axis = 'X'; break; case 'right': newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset); axis = 'X'; break;}var newTranslate = 'translate' + axis + '(' + newPosition + 'px)'; styles.transform = styles.webkitTransform = newTranslate;});}}return {addClass: function (element, className, done) {if (element.hasClass('md-fling')) {runAnimation(element); delayDone(done);}else {done();}}, removeClass: function (element, className, done) {runAnimation(element); delayDone(done);}, };}function MdFabSpeedDialScaleAnimation($timeout) {function delayDone(done) {$timeout(done, cssAnimationDuration, false);}var delay = 65; function runAnimation(element) {var el = element[0]; var ctrl = element.controller('mdFabSpeedDial'); var items = el.querySelectorAll('.md-fab-action-item'); var variablesElement = el.querySelector('._md-css-variables'); var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex); angular.forEach(items, function (item, index) {var styles = item.style, offsetDelay = index * delay; styles.opacity = ctrl.isOpen ? 1 : 0; styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0)'; styles.transitionDelay = (ctrl.isOpen ? offsetDelay : items.length - offsetDelay) + 'ms'; styles.zIndex = items.length - index + startZIndex;});}return {addClass: function (element, className, done) {runAnimation(element); delayDone(done);}, removeClass: function (element, className, done) {runAnimation(element); delayDone(done);}, };}})();})(); (function () {'use strict'; (function () {'use strict'; angular .module('material.components.fabToolbar', ['material.core', 'material.components.fabShared', 'material.components.fabActions']) .directive('mdFabToolbar', MdFabToolbarDirective) .animation('.md-fab-toolbar', MdFabToolbarAnimation) .service('mdFabToolbarAnimation', MdFabToolbarAnimation); function MdFabToolbarDirective() {return {restrict: 'E', transclude: true, template: '<div class="md-fab-toolbar-wrapper">' + ' <div class="md-fab-toolbar-content" ng-transclude></div>' + '</div>', scope: {direction: '@?mdDirection', isOpen: '=?mdOpen', }, bindToController: true, controller: 'MdFabController', controllerAs: 'vm', link: link, }; function link(scope, element, attributes) {element.addClass('md-fab-toolbar'); element.find('md-fab-trigger').find('button').prepend('<div class="md-fab-toolbar-background"></div>');}}function MdFabToolbarAnimation() {function runAnimation(element, className, done) {if (!className) {return;}var el = element[0]; var ctrl = element.controller('mdFabToolbar'); var backgroundElement = el.querySelector('.md-fab-toolbar-background'); var triggerElement = el.querySelector('md-fab-trigger button'); var toolbarElement = el.querySelector('md-toolbar'); var iconElement = el.querySelector('md-fab-trigger button md-icon'); var actions = element.find('md-fab-actions').children(); if (triggerElement && backgroundElement) {var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color'); var width = el.offsetWidth; var height = el.offsetHeight; var scale = 2 * (width / triggerElement.offsetWidth); backgroundElement.style.backgroundColor = color; backgroundElement.style.borderRadius = width + 'px'; if (ctrl.isOpen) {toolbarElement.style.pointerEvents = 'inherit'; backgroundElement.style.width = triggerElement.offsetWidth + 'px'; backgroundElement.style.height = triggerElement.offsetHeight + 'px'; backgroundElement.style.transform = 'scale(' + scale + ')'; backgroundElement.style.transitionDelay = '0ms'; iconElement && (iconElement.style.transitionDelay = '.3s'); angular.forEach(actions, function (action, index) {action.style.transitionDelay = (actions.length - index) * 25 + 'ms';});}else {toolbarElement.style.pointerEvents = 'none'; backgroundElement.style.transform = 'scale(1)'; backgroundElement.style.top = '0'; if (element.hasClass('md-right')) {backgroundElement.style.left = '0'; backgroundElement.style.right = null;}if (element.hasClass('md-left')) {backgroundElement.style.right = '0'; backgroundElement.style.left = null;}backgroundElement.style.transitionDelay = '200ms'; iconElement && (iconElement.style.transitionDelay = '0ms'); angular.forEach(actions, function (action, index) {action.style.transitionDelay = 200 + index * 25 + 'ms';});}}}return {addClass: function (element, className, done) {runAnimation(element, className, done); done();}, removeClass: function (element, className, done) {runAnimation(element, className, done); done();}, };}})();})(); (function () {'use strict'; angular.module('material.components.icon', ['material.core']);})(); (function () {'use strict'; GridListController.$inject = ['$mdUtil']; GridLayoutFactory.$inject = ['$mdUtil']; GridListDirective.$inject = ['$interpolate', '$mdConstant', '$mdGridLayout', '$mdMedia']; GridTileDirective.$inject = ['$mdMedia']; angular .module('material.components.gridList', ['material.core']) .directive('mdGridList', GridListDirective) .directive('mdGridTile', GridTileDirective) .directive('mdGridTileFooter', GridTileCaptionDirective) .directive('mdGridTileHeader', GridTileCaptionDirective) .factory('$mdGridLayout', GridLayoutFactory); function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {return {restrict: 'E', controller: GridListController, scope: {mdOnLayout: '&', }, link: postLink, }; function postLink(scope, element, attrs, ctrl) {element.addClass('_md'); element.attr('role', 'list'); ctrl.layoutDelegate = layoutDelegate; var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout), unwatchAttrs = watchMedia(); scope.$on('$destroy', unwatchMedia); function watchMedia() {for (var mediaName in $mdConstant.MEDIA) {$mdMedia(mediaName); $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);}return $mdMedia.watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);}function unwatchMedia() {ctrl.layoutDelegate = angular.noop; unwatchAttrs(); for (var mediaName in $mdConstant.MEDIA) {$mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);}}function layoutIfMediaMatch(mediaName) {if (mediaName == null) {ctrl.invalidateLayout();}else if ($mdMedia(mediaName)) {ctrl.invalidateLayout();}}var lastLayoutProps; function layoutDelegate(tilesInvalidated) {var tiles = getTileElements(); var props = {tileSpans: getTileSpans(tiles), colCount: getColumnCount(), rowMode: getRowMode(), rowHeight: getRowHeight(), gutter: getGutter(), }; if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {return;}var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles) .map(function (tilePositions, rowCount) {return {grid: {element: element, style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight), }, tiles: tilePositions.map(function (ps, i) {return {element: angular.element(tiles[i]), style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight), };}), };}) .reflow() .performance(); scope.mdOnLayout({$event: {performance: performance, }, }); lastLayoutProps = props;}var startSymbol = $interpolate.startSymbol(); var endSymbol = $interpolate.endSymbol(); function expr(exprStr) {return startSymbol + exprStr + endSymbol;}var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')'); var POSITION = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')'); var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')'); function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {var hShare = (1 / colCount) * 100; var hGutterShare = (colCount - 1) / colCount; var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter }); var ltr = document.dir != 'rtl' && document.body.dir != 'rtl'; var style = ltr ? {left: POSITION({unit: hUnit, offset: position.col, gutter: gutter }), width: DIMENSION({unit: hUnit, span: spans.col, gutter: gutter }), paddingTop: '', marginTop: '', top: '', height: '', }: {right: POSITION({unit: hUnit, offset: position.col, gutter: gutter }), width: DIMENSION({unit: hUnit, span: spans.col, gutter: gutter }), paddingTop: '', marginTop: '', top: '', height: '', }; switch (rowMode) {case 'fixed': style.top = POSITION({unit: rowHeight, offset: position.row, gutter: gutter }); style.height = DIMENSION({unit: rowHeight, span: spans.row, gutter: gutter }); break; case 'ratio': var vShare = hShare / rowHeight; var vUnit = UNIT({share: vShare, gutterShare: hGutterShare, gutter: gutter }); style.paddingTop = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter }); style.marginTop = POSITION({unit: vUnit, offset: position.row, gutter: gutter }); break; case 'fit': var vGutterShare = (rowCount - 1) / rowCount; var vShare = (1 / rowCount) * 100; var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter }); style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter }); style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter }); break;}return style;}function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {var style = {}; switch (rowMode) {case 'fixed': style.height = DIMENSION({unit: rowHeight, span: rowCount, gutter: gutter }); style.paddingBottom = ''; break; case 'ratio': var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount, hShare = (1 / colCount) * 100, vShare = hShare * (1 / rowHeight), vUnit = UNIT({share: vShare, gutterShare: hGutterShare, gutter: gutter }); style.height = ''; style.paddingBottom = DIMENSION({unit: vUnit, span: rowCount, gutter: gutter }); break; case 'fit': break;}return style;}function getTileElements() {return [].filter.call(element.children(), function (ele) {return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;});}function getTileSpans(tileElements) {return [].map.call(tileElements, function (ele) {var ctrl = angular.element(ele).controller('mdGridTile'); return {row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1, col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1, };});}function getColumnCount() {var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10); if (isNaN(colCount)) {throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';}return colCount;}function getGutter() {return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);}function getRowHeight() {var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height'); if (!rowHeight) {throw 'md-grid-list: md-row-height attribute was not found';}switch (getRowMode()) {case 'fixed': return applyDefaultUnit(rowHeight); case 'ratio': var whRatio = rowHeight.split(':'); return parseFloat(whRatio[0]) / parseFloat(whRatio[1]); case 'fit': return 0;}}function getRowMode() {var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height'); if (!rowHeight) {throw 'md-grid-list: md-row-height attribute was not found';}if (rowHeight == 'fit') {return 'fit';}else if (rowHeight.indexOf(':') !== -1) {return 'ratio';}else {return 'fixed';}}function applyDefaultUnit(val) {return /\D$/.test(val) ? val : val + 'px';}}}function GridListController($mdUtil) {this.layoutInvalidated = false; this.tilesInvalidated = false; this.$timeout_ = $mdUtil.nextTick; this.layoutDelegate = angular.noop;}GridListController.prototype = {invalidateTiles: function () {this.tilesInvalidated = true; this.invalidateLayout();}, invalidateLayout: function () {if (this.layoutInvalidated) {return;}this.layoutInvalidated = true; this.$timeout_(angular.bind(this, this.layout));}, layout: function () {try {this.layoutDelegate(this.tilesInvalidated);}finally {this.layoutInvalidated = false; this.tilesInvalidated = false;}}, }; function GridLayoutFactory($mdUtil) {var defaultAnimator = GridTileAnimator; GridLayout.animateWith = function (customAnimator) {defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;}; return GridLayout; function GridLayout(colCount, tileSpans) {var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime; layoutTime = $mdUtil.time(function () {layoutInfo = calculateGridFor(colCount, tileSpans);}); return (self = {layoutInfo: function () {return layoutInfo;}, map: function (updateFn) {mapTime = $mdUtil.time(function () {var info = self.layoutInfo(); gridStyles = updateFn(info.positioning, info.rowCount);}); return self;}, reflow: function (animatorFn) {reflowTime = $mdUtil.time(function () {var animator = animatorFn || defaultAnimator; animator(gridStyles.grid, gridStyles.tiles);}); return self;}, performance: function () {return {tileCount: tileSpans.length, layoutTime: layoutTime, mapTime: mapTime, reflowTime: reflowTime, totalTime: layoutTime + mapTime + reflowTime, };}, });}function GridTileAnimator(grid, tiles) {grid.element.css(grid.style); tiles.forEach(function (t) {t.element.css(t.style);});}function calculateGridFor(colCount, tileSpans) {var curCol = 0, curRow = 0, spaceTracker = newSpaceTracker(); return {positioning: tileSpans.map(function (spans, i) {return {spans: spans, position: reserveSpace(spans, i), };}), rowCount: curRow + Math.max.apply(Math, spaceTracker), }; function reserveSpace(spans, i) {if (spans.col > colCount) {throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' + '(' + spans.col + ') that exceeds the column count ' + '(' + colCount + ')';}var start = 0, end = 0; while (end - start < spans.col) {if (curCol >= colCount) {nextRow(); continue;}start = spaceTracker.indexOf(0, curCol); if (start === -1 || (end = findEnd(start + 1)) === -1) {start = end = 0; nextRow(); continue;}curCol = end + 1;}adjustRow(start, spans.col, spans.row); curCol = start + spans.col; return {col: start, row: curRow, };}function nextRow() {curCol = 0; curRow++; adjustRow(0, colCount, -1);}function adjustRow(from, cols, by) {for (var i = from; i < from + cols; i++) {spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);}}function findEnd(start) {var i; for (i = start; i < spaceTracker.length; i++) {if (spaceTracker[i] !== 0) {return i;}}if (i === spaceTracker.length) {return i;}}function newSpaceTracker() {var tracker = []; for (var i = 0; i < colCount; i++) {tracker.push(0);}return tracker;}}}function GridTileDirective($mdMedia) {return {restrict: 'E', require: '^mdGridList', template: '<figure ng-transclude></figure>', transclude: true, scope: {}, controller: [ '$attrs', function ($attrs) {this.$attrs = $attrs;}, ], link: postLink, }; function postLink(scope, element, attrs, gridCtrl) {element.attr('role', 'listitem'); var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout)); gridCtrl.invalidateTiles(); scope.$on('$destroy', function () {element[0].$$mdDestroyed = true; unwatchAttrs(); gridCtrl.invalidateLayout();}); if (angular.isDefined(scope.$parent.$index)) {scope.$watch( function () {return scope.$parent.$index;}, function indexChanged(newIdx, oldIdx) {if (newIdx === oldIdx) {return;}gridCtrl.invalidateTiles();}, );}}}function GridTileCaptionDirective() {return {template: '<figcaption ng-transclude></figcaption>', transclude: true, };}})(); (function () {'use strict'; mdInputContainerDirective.$inject = ['$mdTheming', '$parse']; inputTextareaDirective.$inject = ['$mdUtil', '$window', '$mdAria', '$timeout', '$mdGesture']; mdMaxlengthDirective.$inject = ['$animate', '$mdUtil']; placeholderDirective.$inject = ['$compile']; ngMessageDirective.$inject = ['$mdUtil']; mdSelectOnFocusDirective.$inject = ['$timeout']; mdInputInvalidMessagesAnimation.$inject = ['$$AnimateRunner', '$animateCss', '$mdUtil', '$log']; ngMessagesAnimation.$inject = ['$$AnimateRunner', '$animateCss', '$mdUtil', '$log']; ngMessageAnimation.$inject = ['$$AnimateRunner', '$animateCss', '$mdUtil', '$log']; var inputModule = angular .module('material.components.input', ['material.core']) .directive('mdInputContainer', mdInputContainerDirective) .directive('label', labelDirective) .directive('input', inputTextareaDirective) .directive('textarea', inputTextareaDirective) .directive('mdMaxlength', mdMaxlengthDirective) .directive('placeholder', placeholderDirective) .directive('ngMessages', ngMessagesDirective) .directive('ngMessage', ngMessageDirective) .directive('ngMessageExp', ngMessageDirective) .directive('mdSelectOnFocus', mdSelectOnFocusDirective) .animation('.md-input-invalid', mdInputInvalidMessagesAnimation) .animation('.md-input-messages-animation', ngMessagesAnimation) .animation('.md-input-message-animation', ngMessageAnimation); if (window._mdMocksIncluded) {inputModule .service('$$mdInput', function () {return {messages: {show: showInputMessages, hide: hideInputMessages, getElement: getMessagesElement, }, };}) .service('mdInputInvalidAnimation', mdInputInvalidMessagesAnimation) .service('mdInputMessagesAnimation', ngMessagesAnimation) .service('mdInputMessageAnimation', ngMessageAnimation);}function mdInputContainerDirective($mdTheming, $parse) {ContainerCtrl.$inject = ['$scope', '$element', '$attrs', '$animate']; var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT', 'MD-SELECT']; var LEFT_SELECTORS = INPUT_TAGS.reduce(function (selectors, isel) {return selectors.concat(['md-icon ~ ' + isel, '.md-icon ~ ' + isel]);}, []).join(','); var RIGHT_SELECTORS = INPUT_TAGS.reduce(function (selectors, isel) {return selectors.concat([isel + ' ~ md-icon', isel + ' ~ .md-icon']);}, []).join(','); return {restrict: 'E', compile: compile, controller: ContainerCtrl, }; function compile(tElement) {var leftIcon = tElement[0].querySelector(LEFT_SELECTORS); var rightIcon = tElement[0].querySelector(RIGHT_SELECTORS); if (leftIcon) {tElement.addClass('md-icon-left');}if (rightIcon) {tElement.addClass('md-icon-right');}return function postLink(scope, element) {$mdTheming(element);};}function ContainerCtrl($scope, $element, $attrs, $animate) {var self = this; self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError); self.delegateClick = function () {self.input.focus();}; self.element = $element; self.setFocused = function (isFocused) {$element.toggleClass('md-input-focused', !!isFocused);}; self.setHasValue = function (hasValue) {$element.toggleClass('md-input-has-value', !!hasValue);}; self.setHasPlaceholder = function (hasPlaceholder) {$element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);}; self.setInvalid = function (isInvalid) {if (isInvalid) {$animate.addClass($element, 'md-input-invalid');}else {$animate.removeClass($element, 'md-input-invalid');}}; $scope.$watch( function () {return self.label && self.input;}, function (hasLabelAndInput) {if (hasLabelAndInput && !self.label.attr('for')) {self.label.attr('for', self.input.attr('id'));}}, );}}function labelDirective() {return {restrict: 'E', require: '^?mdInputContainer', link: function (scope, element, attr, containerCtrl) {if (!containerCtrl || attr.mdNoFloat || element.hasClass('md-container-ignore')) return; containerCtrl.label = element; scope.$on('$destroy', function () {containerCtrl.label = null;});}, };}function inputTextareaDirective($mdUtil, $window, $mdAria, $timeout, $mdGesture) {return {restrict: 'E', require: ['^?mdInputContainer', '?ngModel', '?^form'], link: postLink, }; function postLink(scope, element, attr, ctrls) {var containerCtrl = ctrls[0]; var hasNgModel = !!ctrls[1]; var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(); var parentForm = ctrls[2]; var isReadonly = angular.isDefined(attr.readonly); var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk); var tagName = element[0].tagName.toLowerCase(); if (!containerCtrl) return; if (attr.type === 'hidden') {element.attr('aria-hidden', 'true'); return;}else if (containerCtrl.input) {if (containerCtrl.input[0].contains(element[0])) {return;}else {throw new Error('<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!');}}containerCtrl.input = element; setupAttributeWatchers(); var errorsSpacer = angular.element('<div class="md-errors-spacer">'); element.after(errorsSpacer); var placeholderText = angular.isString(attr.placeholder) ? attr.placeholder.trim() : ''; if (!containerCtrl.label && !placeholderText.length) {$mdAria.expect(element, 'aria-label');}element.addClass('md-input'); if (!element.attr('id')) {element.attr('id', 'input_' + $mdUtil.nextUid());}if (tagName === 'input' && attr.type === 'number' && attr.min && attr.max && !attr.step) {element.attr('step', 'any');}else if (tagName === 'textarea') {setupTextarea();}if (!hasNgModel) {inputCheckValue();}var isErrorGetter = containerCtrl.isErrorGetter || function () {return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (parentForm && parentForm.$submitted));}; scope.$watch(isErrorGetter, containerCtrl.setInvalid); if (attr.ngValue) {attr.$observe('value', inputCheckValue);}ngModelCtrl.$parsers.push(ngModelPipelineCheckValue); ngModelCtrl.$formatters.push(ngModelPipelineCheckValue); element.on('input', inputCheckValue); if (!isReadonly) {element .on('focus', function (ev) {$mdUtil.nextTick(function () {containerCtrl.setFocused(true);});}) .on('blur', function (ev) {$mdUtil.nextTick(function () {containerCtrl.setFocused(false); inputCheckValue();});});}scope.$on('$destroy', function () {containerCtrl.setFocused(false); containerCtrl.setHasValue(false); containerCtrl.input = null;}); function ngModelPipelineCheckValue(arg) {containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg)); return arg;}function setupAttributeWatchers() {if (containerCtrl.label) {attr.$observe('required', function (value) {containerCtrl.label.toggleClass('md-required', value && !mdNoAsterisk);});}}function inputCheckValue() {containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);}function setupTextarea() {var isAutogrowing = !attr.hasOwnProperty('mdNoAutogrow'); attachResizeHandle(); if (!isAutogrowing) return; var minRows = attr.hasOwnProperty('rows') ? parseInt(attr.rows) : NaN; var maxRows = attr.hasOwnProperty('maxRows') ? parseInt(attr.maxRows) : NaN; var scopeResizeListener = scope.$on('md-resize-textarea', growTextarea); var lineHeight = null; var node = element[0]; $timeout( function () {$mdUtil.nextTick(growTextarea);}, 10, false, ); element.on('input', growTextarea); if (hasNgModel) {ngModelCtrl.$formatters.push(formattersListener);}if (!minRows) {element.attr('rows', 1);}angular.element($window).on('resize', growTextarea); scope.$on('$destroy', disableAutogrow); function growTextarea() {element.attr('rows', 1).css('height', 'auto').addClass('md-no-flex'); var height = getHeight(); if (!lineHeight) {var originalPadding = element[0].style.padding || ''; lineHeight = element.css('padding', 0).prop('offsetHeight'); element[0].style.padding = originalPadding;}if (minRows && lineHeight) {height = Math.max(height, lineHeight * minRows);}if (maxRows && lineHeight) {var maxHeight = lineHeight * maxRows; if (maxHeight < height) {element.attr('md-no-autogrow', ''); height = maxHeight;}else {element.removeAttr('md-no-autogrow');}}if (lineHeight) {element.attr('rows', Math.round(height / lineHeight));}element.css('height', height + 'px').removeClass('md-no-flex');}function getHeight() {var offsetHeight = node.offsetHeight; var line = node.scrollHeight - offsetHeight; return offsetHeight + Math.max(line, 0);}function formattersListener(value) {$mdUtil.nextTick(growTextarea); return value;}function disableAutogrow() {if (!isAutogrowing) return; isAutogrowing = false; angular.element($window).off('resize', growTextarea); scopeResizeListener && scopeResizeListener(); element.attr('md-no-autogrow', '').off('input', growTextarea); if (hasNgModel) {var listenerIndex = ngModelCtrl.$formatters.indexOf(formattersListener); if (listenerIndex > -1) {ngModelCtrl.$formatters.splice(listenerIndex, 1);}}}function attachResizeHandle() {if (attr.hasOwnProperty('mdNoResize')) return; var handle = angular.element('<div class="md-resize-handle"></div>'); var isDragging = false; var dragStart = null; var startHeight = 0; var container = containerCtrl.element; var dragGestureHandler = $mdGesture.register(handle, 'drag', {horizontal: false }); element.wrap('<div class="md-resize-wrapper">').after(handle); handle.on('mousedown', onMouseDown); container.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd); scope.$on('$destroy', function () {handle.off('mousedown', onMouseDown).remove(); container.off('$md.dragstart', onDragStart).off('$md.drag', onDrag).off('$md.dragend', onDragEnd); dragGestureHandler(); handle = null; container = null; dragGestureHandler = null;}); function onMouseDown(ev) {ev.preventDefault(); isDragging = true; dragStart = ev.clientY; startHeight = parseFloat(element.css('height')) || element.prop('offsetHeight');}function onDragStart(ev) {if (!isDragging) return; ev.preventDefault(); disableAutogrow(); container.addClass('md-input-resized');}function onDrag(ev) {if (!isDragging) return; element.css('height', startHeight + ev.pointer.distanceY + 'px');}function onDragEnd(ev) {if (!isDragging) return; isDragging = false; container.removeClass('md-input-resized');}}if (attr.hasOwnProperty('mdDetectHidden')) {var handleHiddenChange = (function () {var wasHidden = false; return function () {var isHidden = node.offsetHeight === 0; if (isHidden === false && wasHidden === true) {growTextarea();}wasHidden = isHidden;};})(); scope.$watch(function () {$mdUtil.nextTick(handleHiddenChange, false); return true;});}}}}function mdMaxlengthDirective($animate, $mdUtil) {return {restrict: 'A', require: ['ngModel', '^mdInputContainer'], link: postLink, }; function postLink(scope, element, attr, ctrls) {var maxlength; var ngModelCtrl = ctrls[0]; var containerCtrl = ctrls[1]; var charCountEl, errorsSpacer; $mdUtil.nextTick(function () {errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer')); charCountEl = angular.element('<div class="md-char-counter">'); errorsSpacer.append(charCountEl); attr.$set('ngTrim', 'false'); scope.$watch(attr.mdMaxlength, function (value) {maxlength = value; if (angular.isNumber(value) && value > 0) {if (!charCountEl.parent().length) {$animate.enter(charCountEl, errorsSpacer);}renderCharCount();}else {$animate.leave(charCountEl);}}); ngModelCtrl.$validators['md-maxlength'] = function (modelValue, viewValue) {if (!angular.isNumber(maxlength) || maxlength < 0) {return true;}renderCharCount(); return (modelValue || element.val() || viewValue || '').length <= maxlength;};}); function renderCharCount(value) {if (!charCountEl.parent) {return value;}charCountEl.text(String(element.val() || value || '').length + ' / ' + maxlength); return value;}}}function placeholderDirective($compile) {return {restrict: 'A', require: '^^?mdInputContainer', priority: 200, link: {pre: preLink, }, }; function preLink(scope, element, attr, inputContainer) {if (!inputContainer) return; var label = inputContainer.element.find('label'); var noFloat = inputContainer.element.attr('md-no-float'); if ((label && label.length) || noFloat === '' || scope.$eval(noFloat)) {inputContainer.setHasPlaceholder(true); return;}if (element[0].nodeName != 'MD-SELECT') {var newLabel = angular.element('<label ng-click="delegateClick()" tabindex="-1">' + attr.placeholder + '</label>'); attr.$set('placeholder', null); inputContainer.element.addClass('md-icon-float').prepend(newLabel); $compile(newLabel)(scope);}}}function mdSelectOnFocusDirective($timeout) {return {restrict: 'A', link: postLink, }; function postLink(scope, element, attr) {if (element[0].nodeName !== 'INPUT' && element[0].nodeName !== 'TEXTAREA') return; var preventMouseUp = false; element.on('focus', onFocus).on('mouseup', onMouseUp); scope.$on('$destroy', function () {element.off('focus', onFocus).off('mouseup', onMouseUp);}); function onFocus() {preventMouseUp = true; $timeout( function () {element[0].select(); preventMouseUp = false;}, 1, false, );}function onMouseUp(event) {if (preventMouseUp) {event.preventDefault();}}}}var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault']; function ngMessagesDirective() {return {restrict: 'EA', link: postLink, require: '^^?mdInputContainer', }; function postLink(scope, element, attrs, inputContainer) {if (!inputContainer) return; element.toggleClass('md-input-messages-animation', true); element.toggleClass('md-auto-hide', true); if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {element.toggleClass('md-auto-hide', false);}}function hasVisibiltyDirective(attrs) {return visibilityDirectives.some(function (attr) {return attrs[attr];});}}function ngMessageDirective($mdUtil) {return {restrict: 'EA', compile: compile, priority: 100, }; function compile(tElement) {if (!isInsideInputContainer(tElement)) {if (isInsideFragment()) {return function (scope, element) {if (isInsideInputContainer(element)) {initMessageElement(tElement);}};}}else {initMessageElement(tElement);}function isInsideFragment() {var nextNode = tElement[0]; while ((nextNode = nextNode.parentNode)) {if (nextNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {return true;}}return false;}function isInsideInputContainer(element) {return !!$mdUtil.getClosest(element, 'md-input-container');}function initMessageElement(element) {element.toggleClass('md-input-message-animation', true);}}}var $$AnimateRunner, $animateCss, $mdUtil, $log; function mdInputInvalidMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil, $log) {saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log); return {addClass: function (element, className, done) {showInputMessages(element, done);}, };}function ngMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil, $log) {saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log); return {enter: function (element, done) {showInputMessages(element, done);}, leave: function (element, done) {hideInputMessages(element, done);}, addClass: function (element, className, done) {if (className == 'ng-hide') {hideInputMessages(element, done);}else {done();}}, removeClass: function (element, className, done) {if (className == 'ng-hide') {showInputMessages(element, done);}else {done();}}, };}function ngMessageAnimation($$AnimateRunner, $animateCss, $mdUtil, $log) {saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log); return {enter: function (element, done) {var animator = showMessage(element); animator.start().done(done);}, leave: function (element, done) {var animator = hideMessage(element); animator.start().done(done);}, };}function showInputMessages(element, done) {var animators = [], animator; var messages = getMessagesElement(element); var children = messages.children(); if (messages.length == 0 || children.length == 0) {$log.warn('mdInput messages show animation called on invalid messages element: ', element); done(); return;}angular.forEach(children, function (child) {animator = showMessage(angular.element(child)); animators.push(animator.start());}); $$AnimateRunner.all(animators, done);}function hideInputMessages(element, done) {var animators = [], animator; var messages = getMessagesElement(element); var children = messages.children(); if (messages.length == 0 || children.length == 0) {$log.warn('mdInput messages hide animation called on invalid messages element: ', element); done(); return;}angular.forEach(children, function (child) {animator = hideMessage(angular.element(child)); animators.push(animator.start());}); $$AnimateRunner.all(animators, done);}function showMessage(element) {var height = parseInt(window.getComputedStyle(element[0]).height); var topMargin = parseInt(window.getComputedStyle(element[0]).marginTop); var messages = getMessagesElement(element); var container = getInputElement(element); var alreadyVisible = topMargin > -height; if (alreadyVisible || (messages.hasClass('md-auto-hide') && !container.hasClass('md-input-invalid'))) {return $animateCss(element, {});}return $animateCss(element, {event: 'enter', structural: true, from: {opacity: 0, 'margin-top': -height + 'px' }, to: {opacity: 1, 'margin-top': '0' }, duration: 0.3, });}function hideMessage(element) {var height = element[0].offsetHeight; var styles = window.getComputedStyle(element[0]); if (parseInt(styles.opacity) === 0) {return $animateCss(element, {});}return $animateCss(element, {event: 'leave', structural: true, from: {opacity: 1, 'margin-top': 0 }, to: {opacity: 0, 'margin-top': -height + 'px' }, duration: 0.3, });}function getInputElement(element) {var inputContainer = element.controller('mdInputContainer'); return inputContainer.element;}function getMessagesElement(element) {if (element.hasClass('md-input-messages-animation')) {return element;}if (element.hasClass('md-input-message-animation')) {return angular.element( $mdUtil.getClosest(element, function (node) {return node.classList.contains('md-input-messages-animation');}), );}return angular.element(element[0].querySelector('.md-input-messages-animation'));}function saveSharedServices(_$$AnimateRunner_, _$animateCss_, _$mdUtil_, _$log_) {$$AnimateRunner = _$$AnimateRunner_; $animateCss = _$animateCss_; $mdUtil = _$mdUtil_; $log = _$log_;}})(); (function () {'use strict'; MdListController.$inject = ['$scope', '$element', '$mdListInkRipple']; mdListDirective.$inject = ['$mdTheming']; mdListItemDirective.$inject = ['$mdAria', '$mdConstant', '$mdUtil', '$timeout']; angular .module('material.components.list', ['material.core']) .controller('MdListController', MdListController) .directive('mdList', mdListDirective) .directive('mdListItem', mdListItemDirective); function mdListDirective($mdTheming) {return {restrict: 'E', compile: function (tEl) {tEl[0].setAttribute('role', 'list'); return $mdTheming;}, };}function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {var proxiedTypes = ['md-checkbox', 'md-switch', 'md-menu']; return {restrict: 'E', controller: 'MdListController', compile: function (tEl, tAttrs) {var secondaryItems = tEl[0].querySelectorAll('.md-secondary'); var hasProxiedElement; var proxyElement; var itemContainer = tEl; tEl[0].setAttribute('role', 'listitem'); if (tAttrs.ngClick || tAttrs.ngDblclick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {wrapIn('button');}else if (!tEl.hasClass('md-no-proxy')) {for (var i = 0, type; (type = proxiedTypes[i]); ++i) {if ((proxyElement = tEl[0].querySelector(type))) {hasProxiedElement = true; break;}}if (hasProxiedElement) {wrapIn('div');}else {tEl.addClass('md-no-proxy');}}wrapSecondaryItems(); setupToggleAria(); if (hasProxiedElement && proxyElement.nodeName === 'MD-MENU') {setupProxiedMenu();}function setupToggleAria() {var toggleTypes = ['md-switch', 'md-checkbox']; var toggle; for (var i = 0, toggleType; (toggleType = toggleTypes[i]); ++i) {if ((toggle = tEl.find(toggleType)[0])) {if (!toggle.hasAttribute('aria-label')) {var p = tEl.find('p')[0]; if (!p) return; toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);}}}}function setupProxiedMenu() {var menuEl = angular.element(proxyElement); var isEndAligned = menuEl.parent().hasClass('md-secondary-container') || proxyElement.parentNode.firstElementChild !== proxyElement; var xAxisPosition = 'left'; if (isEndAligned) {xAxisPosition = 'right';}if (!menuEl.attr('md-position-mode')) {menuEl.attr('md-position-mode', xAxisPosition + ' target');}var menuOpenButton = menuEl.children().eq(0); if (!hasClickEvent(menuOpenButton[0])) {menuOpenButton.attr('ng-click', '$mdMenu.open($event)');}if (!menuOpenButton.attr('aria-label')) {menuOpenButton.attr('aria-label', 'Open List Menu');}}function wrapIn(type) {if (type == 'div') {itemContainer = angular.element('<div class="md-no-style md-list-item-inner">'); itemContainer.append(tEl.contents()); tEl.addClass('md-proxy-focus');}else {itemContainer = angular.element('<div class="md-button md-no-style">' + ' <div class="md-list-item-inner"></div>' + '</div>'); var buttonWrap = angular.element('<md-button class="md-no-style"></md-button>'); copyAttributes(tEl[0], buttonWrap[0]); if (!buttonWrap.attr('aria-label')) {buttonWrap.attr('aria-label', $mdAria.getText(tEl));}if (tEl.hasClass('md-no-focus')) {buttonWrap.addClass('md-no-focus');}itemContainer.prepend(buttonWrap); itemContainer.children().eq(1).append(tEl.contents()); tEl.addClass('_md-button-wrap');}tEl[0].setAttribute('tabindex', '-1'); tEl.append(itemContainer);}function wrapSecondaryItems() {var secondaryItemsWrapper = angular.element('<div class="md-secondary-container">'); angular.forEach(secondaryItems, function (secondaryItem) {wrapSecondaryItem(secondaryItem, secondaryItemsWrapper);}); itemContainer.append(secondaryItemsWrapper);}function wrapSecondaryItem(secondaryItem, container) {if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {$mdAria.expect(secondaryItem, 'aria-label'); var buttonWrapper = angular.element('<md-button class="md-secondary md-icon-button">'); copyAttributes(secondaryItem, buttonWrapper[0], ['ng-if', 'ng-hide', 'ng-show']); secondaryItem.setAttribute('tabindex', '-1'); buttonWrapper.append(secondaryItem); secondaryItem = buttonWrapper[0];}if (secondaryItem && (!hasClickEvent(secondaryItem) || (!tAttrs.ngClick && isProxiedElement(secondaryItem)))) {angular.element(secondaryItem).removeClass('md-secondary');}tEl.addClass('md-with-secondary'); container.append(secondaryItem);}function copyAttributes(source, destination, extraAttrs) {var copiedAttrs = $mdUtil.prefixer([ 'ng-if', 'ng-click', 'ng-dblclick', 'aria-label', 'ng-disabled', 'ui-sref', 'href', 'ng-href', 'rel', 'target', 'ng-attr-ui-sref', 'ui-sref-opts', ]); if (extraAttrs) {copiedAttrs = copiedAttrs.concat($mdUtil.prefixer(extraAttrs));}angular.forEach(copiedAttrs, function (attr) {if (source.hasAttribute(attr)) {destination.setAttribute(attr, source.getAttribute(attr)); source.removeAttribute(attr);}});}function isProxiedElement(el) {return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;}function isButton(el) {var nodeName = el.nodeName.toUpperCase(); return nodeName == 'MD-BUTTON' || nodeName == 'BUTTON';}function hasClickEvent(element) {var attr = element.attributes; for (var i = 0; i < attr.length; i++) {if (tAttrs.$normalize(attr[i].name) === 'ngClick') return true;}return false;}return postLink; function postLink($scope, $element, $attr, ctrl) {$element.addClass('_md'); var proxies = [], firstElement = $element[0].firstElementChild, isButtonWrap = $element.hasClass('_md-button-wrap'), clickChild = isButtonWrap ? firstElement.firstElementChild : firstElement, hasClick = clickChild && hasClickEvent(clickChild), noProxies = $element.hasClass('md-no-proxy'); computeProxies(); computeClickable(); if (proxies.length) {angular.forEach(proxies, function (proxy) {proxy = angular.element(proxy); $scope.mouseActive = false; proxy .on('mousedown', function () {$scope.mouseActive = true; $timeout(function () {$scope.mouseActive = false;}, 100);}) .on('focus', function () {if ($scope.mouseActive === false) {$element.addClass('md-focused');}proxy.on('blur', function proxyOnBlur() {$element.removeClass('md-focused'); proxy.off('blur', proxyOnBlur);});});});}function computeProxies() {if (firstElement && firstElement.children && !hasClick && !noProxies) {angular.forEach(proxiedTypes, function (type) {angular.forEach(firstElement.querySelectorAll(type + ':not(.md-secondary)'), function (child) {proxies.push(child);});});}}function computeClickable() {if (proxies.length == 1 || hasClick) {$element.addClass('md-clickable'); if (!hasClick) {ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));}}}function isEventFromControl(event) {var forbiddenControls = ['md-slider']; if (!event.path) {return forbiddenControls.indexOf(event.target.tagName.toLowerCase()) !== -1;}var maxPath = event.path.indexOf($element.children()[0]); for (var i = 0; i < maxPath; i++) {if (forbiddenControls.indexOf(event.path[i].tagName.toLowerCase()) !== -1) {return true;}}}var clickChildKeypressListener = function (e) {if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA' && !e.target.isContentEditable) {var keyCode = e.which || e.keyCode; if (keyCode == $mdConstant.KEY_CODE.SPACE) {if (clickChild) {clickChild.click(); e.preventDefault(); e.stopPropagation();}}}}; if (!hasClick && !proxies.length) {clickChild && clickChild.addEventListener('keypress', clickChildKeypressListener);}$element.off('click'); $element.off('keypress'); if (proxies.length == 1 && clickChild) {$element .children() .eq(0) .on('click', function (e) {if (isEventFromControl(e)) return; var parentButton = $mdUtil.getClosest(e.target, 'BUTTON'); if (!parentButton && clickChild.contains(e.target)) {angular.forEach(proxies, function (proxy) {if (e.target !== proxy && !proxy.contains(e.target)) {if (proxy.nodeName === 'MD-MENU') {proxy = proxy.children[0];}angular.element(proxy).triggerHandler('click');}});}});}$scope.$on('$destroy', function () {clickChild && clickChild.removeEventListener('keypress', clickChildKeypressListener);});}}, };}function MdListController($scope, $element, $mdListInkRipple) {var ctrl = this; ctrl.attachRipple = attachRipple; function attachRipple(scope, element) {var options = {}; $mdListInkRipple.attach(scope, element, options);}}})(); (function () {'use strict'; angular.module('material.components.menu', ['material.core', 'material.components.backdrop']);})(); (function () {'use strict'; angular.module('material.components.menuBar', ['material.core', 'material.components.icon', 'material.components.menu']);})(); (function () {'use strict'; MdNavBarController.$inject = ['$element', '$scope', '$timeout', '$mdConstant']; MdNavItem.$inject = ['$mdAria', '$$rAF']; MdNavItemController.$inject = ['$element']; MdNavBar.$inject = ['$mdAria', '$mdTheming']; angular .module('material.components.navBar', ['material.core']) .controller('MdNavBarController', MdNavBarController) .directive('mdNavBar', MdNavBar) .controller('MdNavItemController', MdNavItemController) .directive('mdNavItem', MdNavItem); function MdNavBar($mdAria, $mdTheming) {return {restrict: 'E', transclude: true, controller: MdNavBarController, controllerAs: 'ctrl', bindToController: true, scope: {mdSelectedNavItem: '=?', mdNoInkBar: '=?', navBarAriaLabel: '@?', }, template: '<div class="md-nav-bar">' + '<nav role="navigation">' + '<ul class="_md-nav-bar-list" ng-transclude role="listbox"' + 'tabindex="0"' + 'ng-focus="ctrl.onFocus()"' + 'ng-keydown="ctrl.onKeydown($event)"' + 'aria-label="{{ctrl.navBarAriaLabel}}">' + '</ul>' + '</nav>' + '<md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar>' + '</div>', link: function (scope, element, attrs, ctrl) {$mdTheming(element); if (!ctrl.navBarAriaLabel) {$mdAria.expectAsync(element, 'aria-label', angular.noop);}}, };}function MdNavBarController($element, $scope, $timeout, $mdConstant) {this._$timeout = $timeout; this._$scope = $scope; this._$mdConstant = $mdConstant; this.mdSelectedNavItem; this.navBarAriaLabel; this._navBarEl = $element[0]; this._inkbar; var self = this; var deregisterTabWatch = this._$scope.$watch( function () {return self._navBarEl.querySelectorAll('._md-nav-button').length;}, function (newLength) {if (newLength > 0) {self._initTabs(); deregisterTabWatch();}}, );}MdNavBarController.prototype._initTabs = function () {this._inkbar = angular.element(this._navBarEl.querySelector('md-nav-ink-bar')); var self = this; this._$timeout(function () {self._updateTabs(self.mdSelectedNavItem, undefined);}); this._$scope.$watch('ctrl.mdSelectedNavItem', function (newValue, oldValue) {self._$timeout(function () {self._updateTabs(newValue, oldValue);});});}; MdNavBarController.prototype._updateTabs = function (newValue, oldValue) {var self = this; var tabs = this._getTabs(); if (!tabs) return; var oldIndex = -1; var newIndex = -1; var newTab = this._getTabByName(newValue); var oldTab = this._getTabByName(oldValue); if (oldTab) {oldTab.setSelected(false); oldIndex = tabs.indexOf(oldTab);}if (newTab) {newTab.setSelected(true); newIndex = tabs.indexOf(newTab);}this._$timeout(function () {self._updateInkBarStyles(newTab, newIndex, oldIndex);});}; MdNavBarController.prototype._updateInkBarStyles = function (tab, newIndex, oldIndex) {this._inkbar.toggleClass('_md-left', newIndex < oldIndex).toggleClass('_md-right', newIndex > oldIndex); this._inkbar.css({display: newIndex < 0 ? 'none' : '' }); if (tab) {var tabEl = tab.getButtonEl(); var left = tabEl.offsetLeft; this._inkbar.css({left: left + 'px', width: tabEl.offsetWidth + 'px' });}}; MdNavBarController.prototype._getTabs = function () {var controllers = Array.prototype.slice.call(this._navBarEl.querySelectorAll('.md-nav-item')).map(function (el) {return angular.element(el).controller('mdNavItem');}); return controllers.indexOf(undefined) ? controllers : null;}; MdNavBarController.prototype._getTabByName = function (name) {return this._findTab(function (tab) {return tab.getName() == name;});}; MdNavBarController.prototype._getSelectedTab = function () {return this._findTab(function (tab) {return tab.isSelected();});}; MdNavBarController.prototype.getFocusedTab = function () {return this._findTab(function (tab) {return tab.hasFocus();});}; MdNavBarController.prototype._findTab = function (fn) {var tabs = this._getTabs(); for (var i = 0; i < tabs.length; i++) {if (fn(tabs[i])) {return tabs[i];}}return null;}; MdNavBarController.prototype.onFocus = function () {var tab = this._getSelectedTab(); if (tab) {tab.setFocused(true);}}; MdNavBarController.prototype._moveFocus = function (oldTab, newTab) {oldTab.setFocused(false); newTab.setFocused(true);}; MdNavBarController.prototype.onKeydown = function (e) {var keyCodes = this._$mdConstant.KEY_CODE; var tabs = this._getTabs(); var focusedTab = this.getFocusedTab(); if (!focusedTab) return; var focusedTabIndex = tabs.indexOf(focusedTab); switch (e.keyCode) {case keyCodes.UP_ARROW: case keyCodes.LEFT_ARROW: if (focusedTabIndex > 0) {this._moveFocus(focusedTab, tabs[focusedTabIndex - 1]);}break; case keyCodes.DOWN_ARROW: case keyCodes.RIGHT_ARROW: if (focusedTabIndex < tabs.length - 1) {this._moveFocus(focusedTab, tabs[focusedTabIndex + 1]);}break; case keyCodes.SPACE: case keyCodes.ENTER: this._$timeout(function () {focusedTab.getButtonEl().click();}); break;}}; function MdNavItem($mdAria, $$rAF) {return {restrict: 'E', require: ['mdNavItem', '^mdNavBar'], controller: MdNavItemController, bindToController: true, controllerAs: 'ctrl', replace: true, transclude: true, template: function (tElement, tAttrs) {var hasNavClick = tAttrs.mdNavClick; var hasNavHref = tAttrs.mdNavHref; var hasNavSref = tAttrs.mdNavSref; var hasSrefOpts = tAttrs.srefOpts; var navigationAttribute; var navigationOptions; var buttonTemplate; if ((hasNavClick ? 1 : 0) + (hasNavHref ? 1 : 0) + (hasNavSref ? 1 : 0) > 1) {throw Error('Must not specify more than one of the md-nav-click, md-nav-href, ' + 'or md-nav-sref attributes per nav-item directive.');}if (hasNavClick) {navigationAttribute = 'ng-click="ctrl.mdNavClick()"';}else if (hasNavHref) {navigationAttribute = 'ng-href="{{ctrl.mdNavHref}}"';}else if (hasNavSref) {navigationAttribute = 'ui-sref="{{ctrl.mdNavSref}}"';}navigationOptions = hasSrefOpts ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : ''; if (navigationAttribute) {buttonTemplate = '' + '<md-button class="_md-nav-button md-accent" ' + 'ng-class="ctrl.getNgClassMap()" ' + 'ng-blur="ctrl.setFocused(false)" ' + 'tabindex="-1" ' + navigationOptions + navigationAttribute + '>' + '<span ng-transclude class="_md-nav-button-text"></span>' + '</md-button>';}return '' + '<li class="md-nav-item" ' + 'role="option" ' + 'aria-selected="{{ctrl.isSelected()}}">' + (buttonTemplate || '') + '</li>';}, scope: {mdNavClick: '&?', mdNavHref: '@?', mdNavSref: '@?', srefOpts: '=?', name: '@', }, link: function (scope, element, attrs, controllers) {$$rAF(function () {var mdNavItem = controllers[0]; var mdNavBar = controllers[1]; var navButton = angular.element(element[0].querySelector('._md-nav-button')); if (!mdNavItem.name) {mdNavItem.name = angular.element(element[0].querySelector('._md-nav-button-text')).text().trim();}navButton.on('click', function () {mdNavBar.mdSelectedNavItem = mdNavItem.name; scope.$apply();}); $mdAria.expectWithText(element, 'aria-label');});}, };}function MdNavItemController($element) {this._$element = $element; this.mdNavClick; this.mdNavHref; this.mdNavSref; this.srefOpts; this.name; this._selected = false; this._focused = false;}MdNavItemController.prototype.getNgClassMap = function () {return {'md-active': this._selected, 'md-primary': this._selected, 'md-unselected': !this._selected, 'md-focused': this._focused, };}; MdNavItemController.prototype.getName = function () {return this.name;}; MdNavItemController.prototype.getButtonEl = function () {return this._$element[0].querySelector('._md-nav-button');}; MdNavItemController.prototype.setSelected = function (isSelected) {this._selected = isSelected;}; MdNavItemController.prototype.isSelected = function () {return this._selected;}; MdNavItemController.prototype.setFocused = function (isFocused) {this._focused = isFocused; if (isFocused) {this.getButtonEl().focus();}}; MdNavItemController.prototype.hasFocus = function () {return this._focused;};})(); (function () {'use strict'; MdPanelService.$inject = ['presets', '$rootElement', '$rootScope', '$injector', '$window']; angular.module('material.components.panel', ['material.core', 'material.components.backdrop']).provider('$mdPanel', MdPanelProvider); var MD_PANEL_Z_INDEX = 80; var MD_PANEL_HIDDEN = '_md-panel-hidden'; var FOCUS_TRAP_TEMPLATE = angular.element('<div class="_md-panel-focus-trap" tabindex="0"></div>'); var _presets = {}; function MdPanelProvider() {return {definePreset: definePreset, getAllPresets: getAllPresets, clearPresets: clearPresets, $get: $getProvider(), };}function definePreset(name, preset) {if (!name || !preset) {throw new Error('mdPanelProvider: The panel preset definition is ' + 'malformed. The name and preset object are required.');}else if (_presets.hasOwnProperty(name)) {throw new Error('mdPanelProvider: The panel preset you have requested ' + 'has already been defined.');}delete preset.id; delete preset.position; delete preset.animation; _presets[name] = preset;}function getAllPresets() {return angular.copy(_presets);}function clearPresets() {_presets = {};}function $getProvider() {return [ '$rootElement', '$rootScope', '$injector', '$window', function ($rootElement, $rootScope, $injector, $window) {return new MdPanelService(_presets, $rootElement, $rootScope, $injector, $window);}, ];}function MdPanelService(presets, $rootElement, $rootScope, $injector, $window) {this._defaultConfigOptions = {bindToController: true, clickOutsideToClose: false, disableParentScroll: false, escapeToClose: false, focusOnOpen: true, fullscreen: false, hasBackdrop: false, propagateContainerEvents: false, transformTemplate: angular.bind(this, this._wrapTemplate), trapFocus: false, zIndex: MD_PANEL_Z_INDEX, }; this._config = {}; this._presets = presets; this._$rootElement = $rootElement; this._$rootScope = $rootScope; this._$injector = $injector; this._$window = $window; this._$mdUtil = this._$injector.get('$mdUtil'); this._trackedPanels = {}; this._groups = Object.create(null); this.animation = MdPanelAnimation.animation; this.xPosition = MdPanelPosition.xPosition; this.yPosition = MdPanelPosition.yPosition; this.interceptorTypes = MdPanelRef.interceptorTypes; this.closeReasons = MdPanelRef.closeReasons; this.absPosition = MdPanelPosition.absPosition;}MdPanelService.prototype.create = function (preset, config) {if (typeof preset === 'string') {preset = this._getPresetByName(preset);}else if (typeof preset === 'object' && (angular.isUndefined(config) || !config)) {config = preset; preset = {};}preset = preset || {}; config = config || {}; if (angular.isDefined(config.id) && this._trackedPanels[config.id]) {var trackedPanel = this._trackedPanels[config.id]; angular.extend(trackedPanel.config, config); return trackedPanel;}this._config = angular.extend( {id: config.id || 'panel_' + this._$mdUtil.nextUid(), scope: this._$rootScope.$new(true), attachTo: this._$rootElement, }, this._defaultConfigOptions, config, preset, ); var panelRef = new MdPanelRef(this._config, this._$injector); this._trackedPanels[config.id] = panelRef; if (this._config.groupName) {if (angular.isString(this._config.groupName)) {this._config.groupName = [this._config.groupName];}angular.forEach(this._config.groupName, function (group) {panelRef.addToGroup(group);});}this._config.scope.$on('$destroy', angular.bind(panelRef, panelRef.detach)); return panelRef;}; MdPanelService.prototype.open = function (preset, config) {var panelRef = this.create(preset, config); return panelRef.open().then(function () {return panelRef;});}; MdPanelService.prototype._getPresetByName = function (preset) {if (!this._presets[preset]) {throw new Error( 'mdPanel: The panel preset configuration that you ' + 'requested does not exist. Use the $mdPanelProvider to create a ' + 'preset before requesting one.', );}return this._presets[preset];}; MdPanelService.prototype.newPanelPosition = function () {return new MdPanelPosition(this._$injector);}; MdPanelService.prototype.newPanelAnimation = function () {return new MdPanelAnimation(this._$injector);}; MdPanelService.prototype.newPanelGroup = function (groupName, config) {if (!this._groups[groupName]) {config = config || {}; var group = {panels: [], openPanels: [], maxOpen: config.maxOpen > 0 ? config.maxOpen : Infinity, }; this._groups[groupName] = group;}return this._groups[groupName];}; MdPanelService.prototype.setGroupMaxOpen = function (groupName, maxOpen) {if (this._groups[groupName]) {this._groups[groupName].maxOpen = maxOpen;}else {throw new Error('mdPanel: Group does not exist yet. Call newPanelGroup().');}}; MdPanelService.prototype._openCountExceedsMaxOpen = function (groupName) {if (this._groups[groupName]) {var group = this._groups[groupName]; return group.maxOpen > 0 && group.openPanels.length > group.maxOpen;}return false;}; MdPanelService.prototype._closeFirstOpenedPanel = function (groupName) {this._groups[groupName].openPanels[0].close();}; MdPanelService.prototype._wrapTemplate = function (origTemplate) {var template = origTemplate || ''; return '' + '<div class="md-panel-outer-wrapper">' + ' <div class="md-panel _md-panel-offscreen">' + template + '</div>' + '</div>';}; MdPanelService.prototype._wrapContentElement = function (contentElement) {var wrapper = angular.element('<div class="md-panel-outer-wrapper">'); contentElement.addClass('md-panel _md-panel-offscreen'); wrapper.append(contentElement); return wrapper;}; function MdPanelRef(config, $injector) {this._$q = $injector.get('$q'); this._$mdCompiler = $injector.get('$mdCompiler'); this._$mdConstant = $injector.get('$mdConstant'); this._$mdUtil = $injector.get('$mdUtil'); this._$mdTheming = $injector.get('$mdTheming'); this._$rootScope = $injector.get('$rootScope'); this._$animate = $injector.get('$animate'); this._$mdPanel = $injector.get('$mdPanel'); this._$log = $injector.get('$log'); this._$window = $injector.get('$window'); this._$$rAF = $injector.get('$$rAF'); this.id = config.id; this.config = config; this.panelContainer; this.panelEl; this.isAttached = false; this._removeListeners = []; this._topFocusTrap; this._bottomFocusTrap; this._backdropRef; this._restoreScroll = null; this._interceptors = Object.create(null); this._compilerCleanup = null; this._restoreCache = {styles: '', classes: '', };}MdPanelRef.interceptorTypes = {CLOSE: 'onClose', }; MdPanelRef.prototype.open = function () {var self = this; return this._$q(function (resolve, reject) {var done = self._done(resolve, self); var show = self._simpleBind(self.show, self); var checkGroupMaxOpen = function () {if (self.config.groupName) {angular.forEach(self.config.groupName, function (group) {if (self._$mdPanel._openCountExceedsMaxOpen(group)) {self._$mdPanel._closeFirstOpenedPanel(group);}});}}; self.attach().then(show).then(checkGroupMaxOpen).then(done).catch(reject);});}; MdPanelRef.prototype.close = function (closeReason) {var self = this; return this._$q(function (resolve, reject) {self._callInterceptors(MdPanelRef.interceptorTypes.CLOSE).then(function () {var done = self._done(resolve, self); var detach = self._simpleBind(self.detach, self); var onCloseSuccess = self.config['onCloseSuccess'] || angular.noop; onCloseSuccess = angular.bind(self, onCloseSuccess, self, closeReason); self.hide().then(detach).then(done).then(onCloseSuccess).catch(reject);}, reject);});}; MdPanelRef.prototype.attach = function () {if (this.isAttached && this.panelEl) {return this._$q.when(this);}var self = this; return this._$q(function (resolve, reject) {var done = self._done(resolve, self); var onDomAdded = self.config['onDomAdded'] || angular.noop; var addListeners = function (response) {self.isAttached = true; self._addEventListeners(); return response;}; self._$q .all([self._createBackdrop(), self._createPanel().then(addListeners).catch(reject)]) .then(onDomAdded) .then(done) .catch(reject);});}; MdPanelRef.prototype.detach = function () {if (!this.isAttached) {return this._$q.when(this);}var self = this; var onDomRemoved = self.config['onDomRemoved'] || angular.noop; var detachFn = function () {self._removeEventListeners(); if (self._topFocusTrap && self._topFocusTrap.parentNode) {self._topFocusTrap.parentNode.removeChild(self._topFocusTrap);}if (self._bottomFocusTrap && self._bottomFocusTrap.parentNode) {self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap);}if (self._restoreCache.classes) {self.panelEl[0].className = self._restoreCache.classes;}self.panelEl[0].style.cssText = self._restoreCache.styles || ''; self._compilerCleanup(); self.panelContainer.remove(); self.isAttached = false; return self._$q.when(self);}; if (this._restoreScroll) {this._restoreScroll(); this._restoreScroll = null;}return this._$q(function (resolve, reject) {var done = self._done(resolve, self); self._$q .all([detachFn(), self._backdropRef ? self._backdropRef.detach() : true]) .then(onDomRemoved) .then(done) .catch(reject);});}; MdPanelRef.prototype.destroy = function () {var self = this; if (this.config.groupName) {angular.forEach(this.config.groupName, function (group) {self.removeFromGroup(group);});}this.config.scope.$destroy(); this.config.locals = null; this._interceptors = null;}; MdPanelRef.prototype.show = function () {if (!this.panelContainer) {return this._$q(function (resolve, reject) {reject('mdPanel: Panel does not exist yet. Call open() or attach().');});}if (!this.panelContainer.hasClass(MD_PANEL_HIDDEN)) {return this._$q.when(this);}var self = this; var animatePromise = function () {self.panelContainer.removeClass(MD_PANEL_HIDDEN); return self._animateOpen();}; return this._$q(function (resolve, reject) {var done = self._done(resolve, self); var onOpenComplete = self.config['onOpenComplete'] || angular.noop; var addToGroupOpen = function () {if (self.config.groupName) {angular.forEach(self.config.groupName, function (group) {self._$mdPanel._groups[group].openPanels.push(self);});}}; self._$q .all([ self._backdropRef ? self._backdropRef.show() : self, animatePromise().then(function () {self._focusOnOpen();}, reject), ]) .then(onOpenComplete) .then(addToGroupOpen) .then(done) .catch(reject);});}; MdPanelRef.prototype.hide = function () {if (!this.panelContainer) {return this._$q(function (resolve, reject) {reject('mdPanel: Panel does not exist yet. Call open() or attach().');});}if (this.panelContainer.hasClass(MD_PANEL_HIDDEN)) {return this._$q.when(this);}var self = this; return this._$q(function (resolve, reject) {var done = self._done(resolve, self); var onRemoving = self.config['onRemoving'] || angular.noop; var hidePanel = function () {self.panelContainer.addClass(MD_PANEL_HIDDEN);}; var removeFromGroupOpen = function () {if (self.config.groupName) {var group, index; angular.forEach(self.config.groupName, function (group) {group = self._$mdPanel._groups[group]; index = group.openPanels.indexOf(self); if (index > -1) {group.openPanels.splice(index, 1);}});}}; var focusOnOrigin = function () {var origin = self.config['origin']; if (origin) {getElement(origin).focus();}}; self._$q .all([ self._backdropRef ? self._backdropRef.hide() : self, self._animateClose().then(onRemoving).then(hidePanel).then(removeFromGroupOpen).then(focusOnOrigin).catch(reject), ]) .then(done, reject);});}; MdPanelRef.prototype.addClass = function (newClass, toElement) {this._$log.warn( 'mdPanel: The addClass method is in the process of being deprecated. ' + 'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' + 'To achieve the same results, use the panelContainer or panelEl ' + 'JQLite elements that are referenced in MdPanelRef.', ); if (!this.panelContainer) {throw new Error('mdPanel: Panel does not exist yet. Call open() or attach().');}if (!toElement && !this.panelContainer.hasClass(newClass)) {this.panelContainer.addClass(newClass);}else if (toElement && !this.panelEl.hasClass(newClass)) {this.panelEl.addClass(newClass);}}; MdPanelRef.prototype.removeClass = function (oldClass, fromElement) {this._$log.warn( 'mdPanel: The removeClass method is in the process of being deprecated. ' + 'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' + 'To achieve the same results, use the panelContainer or panelEl ' + 'JQLite elements that are referenced in MdPanelRef.', ); if (!this.panelContainer) {throw new Error('mdPanel: Panel does not exist yet. Call open() or attach().');}if (!fromElement && this.panelContainer.hasClass(oldClass)) {this.panelContainer.removeClass(oldClass);}else if (fromElement && this.panelEl.hasClass(oldClass)) {this.panelEl.removeClass(oldClass);}}; MdPanelRef.prototype.toggleClass = function (toggleClass, onElement) {this._$log.warn( 'mdPanel: The toggleClass method is in the process of being deprecated. ' + 'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' + 'To achieve the same results, use the panelContainer or panelEl ' + 'JQLite elements that are referenced in MdPanelRef.', ); if (!this.panelContainer) {throw new Error('mdPanel: Panel does not exist yet. Call open() or attach().');}if (!onElement) {this.panelContainer.toggleClass(toggleClass);}else {this.panelEl.toggleClass(toggleClass);}}; MdPanelRef.prototype._compile = function () {var self = this; return self._$mdCompiler.compile(self.config).then(function (compileData) {var config = self.config; if (config.contentElement) {var panelEl = compileData.element; self._restoreCache.styles = panelEl[0].style.cssText; self._restoreCache.classes = panelEl[0].className; self.panelContainer = self._$mdPanel._wrapContentElement(panelEl); self.panelEl = panelEl;}else {self.panelContainer = compileData.link(config['scope']); self.panelEl = angular.element(self.panelContainer[0].querySelector('.md-panel'));}self._compilerCleanup = compileData.cleanup; getElement(self.config['attachTo']).append(self.panelContainer); return self;});}; MdPanelRef.prototype._createPanel = function () {var self = this; return this._$q(function (resolve, reject) {if (!self.config.locals) {self.config.locals = {};}self.config.locals.mdPanelRef = self; self._compile().then(function () {if (self.config['disableParentScroll']) {self._restoreScroll = self._$mdUtil.disableScrollAround(null, self.panelContainer, {disableScrollMask: true });}if (self.config['panelClass']) {self.panelEl.addClass(self.config['panelClass']);}if (self.config['propagateContainerEvents']) {self.panelContainer.css('pointer-events', 'none'); self.panelEl.css('pointer-events', 'all');}if (self._$animate.pin) {self._$animate.pin(self.panelContainer, getElement(self.config['attachTo']));}self._configureTrapFocus(); self._addStyles().then(function () {resolve(self);}, reject);}, reject);});}; MdPanelRef.prototype._addStyles = function () {var self = this; return this._$q(function (resolve) {self.panelContainer.css('z-index', self.config['zIndex']); self.panelEl.css('z-index', self.config['zIndex'] + 1); var hideAndResolve = function () {self._setTheming(); self.panelEl.removeClass('_md-panel-offscreen'); self.panelContainer.addClass(MD_PANEL_HIDDEN); resolve(self);}; if (self.config['fullscreen']) {self.panelEl.addClass('_md-panel-fullscreen'); hideAndResolve(); return;}var positionConfig = self.config['position']; if (!positionConfig) {hideAndResolve(); return;}self._$rootScope['$$postDigest'](function () {self._updatePosition(true); self._setTheming(); resolve(self);});});}; MdPanelRef.prototype._setTheming = function () {this._$mdTheming(this.panelEl); this._$mdTheming(this.panelContainer);}; MdPanelRef.prototype.updatePosition = function (position) {if (!this.panelContainer) {throw new Error('mdPanel: Panel does not exist yet. Call open() or attach().');}this.config['position'] = position; this._updatePosition();}; MdPanelRef.prototype._updatePosition = function (init) {var positionConfig = this.config['position']; if (positionConfig) {positionConfig._setPanelPosition(this.panelEl); if (init) {this.panelEl.removeClass('_md-panel-offscreen'); this.panelContainer.addClass(MD_PANEL_HIDDEN);}this.panelEl.css(MdPanelPosition.absPosition.TOP, positionConfig.getTop()); this.panelEl.css(MdPanelPosition.absPosition.BOTTOM, positionConfig.getBottom()); this.panelEl.css(MdPanelPosition.absPosition.LEFT, positionConfig.getLeft()); this.panelEl.css(MdPanelPosition.absPosition.RIGHT, positionConfig.getRight());}}; MdPanelRef.prototype._focusOnOpen = function () {if (this.config['focusOnOpen']) {var self = this; this._$rootScope['$$postDigest'](function () {var target = self._$mdUtil.findFocusTarget(self.panelEl) || self.panelEl; target.focus();});}}; MdPanelRef.prototype._createBackdrop = function () {if (this.config.hasBackdrop) {if (!this._backdropRef) {var backdropAnimation = this._$mdPanel.newPanelAnimation().openFrom(this.config.attachTo).withAnimation({open: '_md-opaque-enter', close: '_md-opaque-leave', }); if (this.config.animation) {backdropAnimation.duration(this.config.animation._rawDuration);}var backdropConfig = {animation: backdropAnimation, attachTo: this.config.attachTo, focusOnOpen: false, panelClass: '_md-panel-backdrop', zIndex: this.config.zIndex - 1, }; this._backdropRef = this._$mdPanel.create(backdropConfig);}if (!this._backdropRef.isAttached) {return this._backdropRef.attach();}}}; MdPanelRef.prototype._addEventListeners = function () {this._configureEscapeToClose(); this._configureClickOutsideToClose(); this._configureScrollListener();}; MdPanelRef.prototype._removeEventListeners = function () {this._removeListeners && this._removeListeners.forEach(function (removeFn) {removeFn();}); this._removeListeners = [];}; MdPanelRef.prototype._configureEscapeToClose = function () {if (this.config['escapeToClose']) {var parentTarget = getElement(this.config['attachTo']); var self = this; var keyHandlerFn = function (ev) {if (ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE) {ev.stopPropagation(); ev.preventDefault(); self.close(MdPanelRef.closeReasons.ESCAPE);}}; this.panelContainer.on('keydown', keyHandlerFn); parentTarget.on('keydown', keyHandlerFn); this._removeListeners.push(function () {self.panelContainer.off('keydown', keyHandlerFn); parentTarget.off('keydown', keyHandlerFn);});}}; MdPanelRef.prototype._configureClickOutsideToClose = function () {if (this.config['clickOutsideToClose']) {var target = this.config['propagateContainerEvents'] ? angular.element(document.body) : this.panelContainer; var sourceEl; var mousedownHandler = function (ev) {sourceEl = ev.target;}; var self = this; var mouseupHandler = function (ev) {if (self.config['propagateContainerEvents']) {if (sourceEl !== self.panelEl[0] && !self.panelEl[0].contains(sourceEl)) {self.close();}}else if (sourceEl === target[0] && ev.target === target[0]) {ev.stopPropagation(); ev.preventDefault(); self.close(MdPanelRef.closeReasons.CLICK_OUTSIDE);}}; target.on('mousedown', mousedownHandler); target.on('mouseup', mouseupHandler); this._removeListeners.push(function () {target.off('mousedown', mousedownHandler); target.off('mouseup', mouseupHandler);});}}; MdPanelRef.prototype._configureScrollListener = function () {if (!this.config['disableParentScroll']) {var updatePosition = angular.bind(this, this._updatePosition); var debouncedUpdatePosition = this._$$rAF.throttle(updatePosition); var self = this; var onScroll = function () {debouncedUpdatePosition();}; this._$window.addEventListener('scroll', onScroll, true); this._removeListeners.push(function () {self._$window.removeEventListener('scroll', onScroll, true);});}}; MdPanelRef.prototype._configureTrapFocus = function () {this.panelEl.attr('tabIndex', '-1'); if (this.config['trapFocus']) {var element = this.panelEl; this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0]; this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0]; var focusHandler = function () {element.focus();}; this._topFocusTrap.addEventListener('focus', focusHandler); this._bottomFocusTrap.addEventListener('focus', focusHandler); this._removeListeners.push( this._simpleBind(function () {this._topFocusTrap.removeEventListener('focus', focusHandler); this._bottomFocusTrap.removeEventListener('focus', focusHandler);}, this), ); element[0].parentNode.insertBefore(this._topFocusTrap, element[0]); element.after(this._bottomFocusTrap);}}; MdPanelRef.prototype.updateAnimation = function (animation) {this.config['animation'] = animation; if (this._backdropRef) {this._backdropRef.config.animation.duration(animation._rawDuration);}}; MdPanelRef.prototype._animateOpen = function () {this.panelContainer.addClass('md-panel-is-showing'); var animationConfig = this.config['animation']; if (!animationConfig) {this.panelContainer.addClass('_md-panel-shown'); return this._$q.when(this);}var self = this; return this._$q(function (resolve) {var done = self._done(resolve, self); var warnAndOpen = function () {self._$log.warn('mdPanel: MdPanel Animations failed. ' + 'Showing panel without animating.'); done();}; animationConfig.animateOpen(self.panelEl).then(done, warnAndOpen);});}; MdPanelRef.prototype._animateClose = function () {var animationConfig = this.config['animation']; if (!animationConfig) {this.panelContainer.removeClass('md-panel-is-showing'); this.panelContainer.removeClass('_md-panel-shown'); return this._$q.when(this);}var self = this; return this._$q(function (resolve) {var done = function () {self.panelContainer.removeClass('md-panel-is-showing'); resolve(self);}; var warnAndClose = function () {self._$log.warn('mdPanel: MdPanel Animations failed. ' + 'Hiding panel without animating.'); done();}; animationConfig.animateClose(self.panelEl).then(done, warnAndClose);});}; MdPanelRef.prototype.registerInterceptor = function (type, callback) {var error = null; if (!angular.isString(type)) {error = 'Interceptor type must be a string, instead got ' + typeof type;}else if (!angular.isFunction(callback)) {error = 'Interceptor callback must be a function, instead got ' + typeof callback;}if (error) {throw new Error('MdPanel: ' + error);}var interceptors = (this._interceptors[type] = this._interceptors[type] || []); if (interceptors.indexOf(callback) === -1) {interceptors.push(callback);}return this;}; MdPanelRef.prototype.removeInterceptor = function (type, callback) {var index = this._interceptors[type] ? this._interceptors[type].indexOf(callback) : -1; if (index > -1) {this._interceptors[type].splice(index, 1);}return this;}; MdPanelRef.prototype.removeAllInterceptors = function (type) {if (type) {this._interceptors[type] = [];}else {this._interceptors = Object.create(null);}return this;}; MdPanelRef.prototype._callInterceptors = function (type) {var self = this; var $q = self._$q; var interceptors = (self._interceptors && self._interceptors[type]) || []; return interceptors.reduceRight(function (promise, interceptor) {var isPromiseLike = interceptor && angular.isFunction(interceptor.then); var response = isPromiseLike ? interceptor : null; return promise.then(function () {if (!response) {try {response = interceptor(self);}catch (e) {response = $q.reject(e);}}return response;});}, $q.resolve(self));}; MdPanelRef.prototype._simpleBind = function (callback, self) {return function (value) {return callback.apply(self, value);};}; MdPanelRef.prototype._done = function (callback, self) {return function () {callback(self);};}; MdPanelRef.prototype.addToGroup = function (groupName) {if (!this._$mdPanel._groups[groupName]) {this._$mdPanel.newPanelGroup(groupName);}var group = this._$mdPanel._groups[groupName]; var index = group.panels.indexOf(this); if (index < 0) {group.panels.push(this);}}; MdPanelRef.prototype.removeFromGroup = function (groupName) {if (!this._$mdPanel._groups[groupName]) {throw new Error('mdPanel: The group ' + groupName + ' does not exist.');}var group = this._$mdPanel._groups[groupName]; var index = group.panels.indexOf(this); if (index > -1) {group.panels.splice(index, 1);}}; MdPanelRef.closeReasons = {CLICK_OUTSIDE: 'clickOutsideToClose', ESCAPE: 'escapeToClose', }; function MdPanelPosition($injector) {this._$window = $injector.get('$window'); this._isRTL = $injector.get('$mdUtil').bidi() === 'rtl'; this._$mdConstant = $injector.get('$mdConstant'); this._absolute = false; this._relativeToEl; this._top = ''; this._bottom = ''; this._left = ''; this._right = ''; this._translateX = []; this._translateY = []; this._positions = []; this._actualPosition;}MdPanelPosition.xPosition = {CENTER: 'center', ALIGN_START: 'align-start', ALIGN_END: 'align-end', OFFSET_START: 'offset-start', OFFSET_END: 'offset-end', }; MdPanelPosition.yPosition = {CENTER: 'center', ALIGN_TOPS: 'align-tops', ALIGN_BOTTOMS: 'align-bottoms', ABOVE: 'above', BELOW: 'below', }; MdPanelPosition.absPosition = {TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left', }; MdPanelPosition.viewportMargin = 8; MdPanelPosition.prototype.absolute = function () {this._absolute = true; return this;}; MdPanelPosition.prototype._setPosition = function (position, value) {if (position === MdPanelPosition.absPosition.RIGHT || position === MdPanelPosition.absPosition.LEFT) {this._left = this._right = '';}else if (position === MdPanelPosition.absPosition.BOTTOM || position === MdPanelPosition.absPosition.TOP) {this._top = this._bottom = '';}else {var positions = Object.keys(MdPanelPosition.absPosition).join().toLowerCase(); throw new Error('mdPanel: Position must be one of ' + positions + '.');}this['_' + position] = angular.isString(value) ? value : '0'; return this;}; MdPanelPosition.prototype.top = function (top) {return this._setPosition(MdPanelPosition.absPosition.TOP, top);}; MdPanelPosition.prototype.bottom = function (bottom) {return this._setPosition(MdPanelPosition.absPosition.BOTTOM, bottom);}; MdPanelPosition.prototype.start = function (start) {var position = this._isRTL ? MdPanelPosition.absPosition.RIGHT : MdPanelPosition.absPosition.LEFT; return this._setPosition(position, start);}; MdPanelPosition.prototype.end = function (end) {var position = this._isRTL ? MdPanelPosition.absPosition.LEFT : MdPanelPosition.absPosition.RIGHT; return this._setPosition(position, end);}; MdPanelPosition.prototype.left = function (left) {return this._setPosition(MdPanelPosition.absPosition.LEFT, left);}; MdPanelPosition.prototype.right = function (right) {return this._setPosition(MdPanelPosition.absPosition.RIGHT, right);}; MdPanelPosition.prototype.centerHorizontally = function () {this._left = '50%'; this._right = ''; this._translateX = ['-50%']; return this;}; MdPanelPosition.prototype.centerVertically = function () {this._top = '50%'; this._bottom = ''; this._translateY = ['-50%']; return this;}; MdPanelPosition.prototype.center = function () {return this.centerHorizontally().centerVertically();}; MdPanelPosition.prototype.relativeTo = function (element) {this._absolute = false; this._relativeToEl = getElement(element); return this;}; MdPanelPosition.prototype.addPanelPosition = function (xPosition, yPosition) {if (!this._relativeToEl) {throw new Error('mdPanel: addPanelPosition can only be used with ' + 'relative positioning. Set relativeTo first.');}this._validateXPosition(xPosition); this._validateYPosition(yPosition); this._positions.push({x: xPosition, y: yPosition, }); return this;}; MdPanelPosition.prototype._validateYPosition = function (yPosition) {if (yPosition == null) {return;}var positionKeys = Object.keys(MdPanelPosition.yPosition); var positionValues = []; for (var key, i = 0; (key = positionKeys[i]); i++) {var position = MdPanelPosition.yPosition[key]; positionValues.push(position); if (position === yPosition) {return;}}throw new Error('mdPanel: Panel y position only accepts the following ' + 'values:\n' + positionValues.join(' | '));}; MdPanelPosition.prototype._validateXPosition = function (xPosition) {if (xPosition == null) {return;}var positionKeys = Object.keys(MdPanelPosition.xPosition); var positionValues = []; for (var key, i = 0; (key = positionKeys[i]); i++) {var position = MdPanelPosition.xPosition[key]; positionValues.push(position); if (position === xPosition) {return;}}throw new Error('mdPanel: Panel x Position only accepts the following ' + 'values:\n' + positionValues.join(' | '));}; MdPanelPosition.prototype.withOffsetX = function (offsetX) {this._translateX.push(offsetX); return this;}; MdPanelPosition.prototype.withOffsetY = function (offsetY) {this._translateY.push(offsetY); return this;}; MdPanelPosition.prototype.getTop = function () {return this._top;}; MdPanelPosition.prototype.getBottom = function () {return this._bottom;}; MdPanelPosition.prototype.getLeft = function () {return this._left;}; MdPanelPosition.prototype.getRight = function () {return this._right;}; MdPanelPosition.prototype.getTransform = function () {var translateX = this._reduceTranslateValues('translateX', this._translateX); var translateY = this._reduceTranslateValues('translateY', this._translateY); return (translateX + ' ' + translateY).trim();}; MdPanelPosition.prototype._setTransform = function (panelEl) {return panelEl.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform());}; MdPanelPosition.prototype._isOnscreen = function (panelEl) {var left = parseInt(this.getLeft()); var top = parseInt(this.getTop()); if (this._translateX.length || this._translateY.length) {var prefixedTransform = this._$mdConstant.CSS.TRANSFORM; var offsets = getComputedTranslations(panelEl, prefixedTransform); left += offsets.x; top += offsets.y;}var right = left + panelEl[0].offsetWidth; var bottom = top + panelEl[0].offsetHeight; return left >= 0 && top >= 0 && bottom <= this._$window.innerHeight && right <= this._$window.innerWidth;}; MdPanelPosition.prototype.getActualPosition = function () {return this._actualPosition;}; MdPanelPosition.prototype._reduceTranslateValues = function (translateFn, values) {return values .map(function (translation) {var translationValue = angular.isFunction(translation) ? translation(this) : translation; return translateFn + '(' + translationValue + ')';}, this) .join(' ');}; MdPanelPosition.prototype._setPanelPosition = function (panelEl) {panelEl.removeClass('_md-panel-position-adjusted'); if (this._absolute) {this._setTransform(panelEl); return;}if (this._actualPosition) {this._calculatePanelPosition(panelEl, this._actualPosition); this._setTransform(panelEl); this._constrainToViewport(panelEl); return;}for (var i = 0; i < this._positions.length; i++) {this._actualPosition = this._positions[i]; this._calculatePanelPosition(panelEl, this._actualPosition); this._setTransform(panelEl); if (this._isOnscreen(panelEl)) {return;}}this._constrainToViewport(panelEl);}; MdPanelPosition.prototype._constrainToViewport = function (panelEl) {var margin = MdPanelPosition.viewportMargin; var initialTop = this._top; var initialLeft = this._left; if (this.getTop()) {var top = parseInt(this.getTop()); var bottom = panelEl[0].offsetHeight + top; var viewportHeight = this._$window.innerHeight; if (top < margin) {this._top = margin + 'px';}else if (bottom > viewportHeight) {this._top = top - (bottom - viewportHeight + margin) + 'px';}}if (this.getLeft()) {var left = parseInt(this.getLeft()); var right = panelEl[0].offsetWidth + left; var viewportWidth = this._$window.innerWidth; if (left < margin) {this._left = margin + 'px';}else if (right > viewportWidth) {this._left = left - (right - viewportWidth + margin) + 'px';}}panelEl.toggleClass('_md-panel-position-adjusted', this._top !== initialTop || this._left !== initialLeft);}; MdPanelPosition.prototype._reverseXPosition = function (position) {if (position === MdPanelPosition.xPosition.CENTER) {return position;}var start = 'start'; var end = 'end'; return position.indexOf(start) > -1 ? position.replace(start, end) : position.replace(end, start);}; MdPanelPosition.prototype._bidi = function (position) {return this._isRTL ? this._reverseXPosition(position) : position;}; MdPanelPosition.prototype._calculatePanelPosition = function (panelEl, position) {var panelBounds = panelEl[0].getBoundingClientRect(); var panelWidth = panelBounds.width; var panelHeight = panelBounds.height; var targetBounds = this._relativeToEl[0].getBoundingClientRect(); var targetLeft = targetBounds.left; var targetRight = targetBounds.right; var targetWidth = targetBounds.width; switch (this._bidi(position.x)) {case MdPanelPosition.xPosition.OFFSET_START: this._left = targetLeft - panelWidth + 'px'; break; case MdPanelPosition.xPosition.ALIGN_END: this._left = targetRight - panelWidth + 'px'; break; case MdPanelPosition.xPosition.CENTER: var left = targetLeft + 0.5 * targetWidth - 0.5 * panelWidth; this._left = left + 'px'; break; case MdPanelPosition.xPosition.ALIGN_START: this._left = targetLeft + 'px'; break; case MdPanelPosition.xPosition.OFFSET_END: this._left = targetRight + 'px'; break;}var targetTop = targetBounds.top; var targetBottom = targetBounds.bottom; var targetHeight = targetBounds.height; switch (position.y) {case MdPanelPosition.yPosition.ABOVE: this._top = targetTop - panelHeight + 'px'; break; case MdPanelPosition.yPosition.ALIGN_BOTTOMS: this._top = targetBottom - panelHeight + 'px'; break; case MdPanelPosition.yPosition.CENTER: var top = targetTop + 0.5 * targetHeight - 0.5 * panelHeight; this._top = top + 'px'; break; case MdPanelPosition.yPosition.ALIGN_TOPS: this._top = targetTop + 'px'; break; case MdPanelPosition.yPosition.BELOW: this._top = targetBottom + 'px'; break;}}; function MdPanelAnimation($injector) {this._$mdUtil = $injector.get('$mdUtil'); this._openFrom; this._closeTo; this._animationClass = ''; this._openDuration; this._closeDuration; this._rawDuration;}MdPanelAnimation.animation = {SLIDE: 'md-panel-animate-slide', SCALE: 'md-panel-animate-scale', FADE: 'md-panel-animate-fade', }; MdPanelAnimation.prototype.openFrom = function (openFrom) {openFrom = openFrom.target ? openFrom.target : openFrom; this._openFrom = this._getPanelAnimationTarget(openFrom); if (!this._closeTo) {this._closeTo = this._openFrom;}return this;}; MdPanelAnimation.prototype.closeTo = function (closeTo) {this._closeTo = this._getPanelAnimationTarget(closeTo); return this;}; MdPanelAnimation.prototype.duration = function (duration) {if (duration) {if (angular.isNumber(duration)) {this._openDuration = this._closeDuration = toSeconds(duration);}else if (angular.isObject(duration)) {this._openDuration = toSeconds(duration.open); this._closeDuration = toSeconds(duration.close);}}this._rawDuration = duration; return this; function toSeconds(value) {if (angular.isNumber(value)) return value / 1000;}}; MdPanelAnimation.prototype._getPanelAnimationTarget = function (location) {if (angular.isDefined(location.top) || angular.isDefined(location.left)) {return {element: undefined, bounds: {top: location.top || 0, left: location.left || 0, }, };}else {return this._getBoundingClientRect(getElement(location));}}; MdPanelAnimation.prototype.withAnimation = function (cssClass) {this._animationClass = cssClass; return this;}; MdPanelAnimation.prototype.animateOpen = function (panelEl) {var animator = this._$mdUtil.dom.animator; this._fixBounds(panelEl); var animationOptions = {}; var panelTransform = panelEl[0].style.transform || ''; var openFrom = animator.toTransformCss(panelTransform); var openTo = animator.toTransformCss(panelTransform); switch (this._animationClass) {case MdPanelAnimation.animation.SLIDE: panelEl.css('opacity', '1'); animationOptions = {transitionInClass: '_md-panel-animate-enter', }; var openSlide = animator.calculateSlideToOrigin(panelEl, this._openFrom) || ''; openFrom = animator.toTransformCss(openSlide + ' ' + panelTransform); break; case MdPanelAnimation.animation.SCALE: animationOptions = {transitionInClass: '_md-panel-animate-enter', }; var openScale = animator.calculateZoomToOrigin(panelEl, this._openFrom) || ''; openFrom = animator.toTransformCss(openScale + ' ' + panelTransform); break; case MdPanelAnimation.animation.FADE: animationOptions = {transitionInClass: '_md-panel-animate-enter', }; break; default: if (angular.isString(this._animationClass)) {animationOptions = {transitionInClass: this._animationClass, };}else {animationOptions = {transitionInClass: this._animationClass['open'], transitionOutClass: this._animationClass['close'], };}}animationOptions.duration = this._openDuration; return animator.translate3d(panelEl, openFrom, openTo, animationOptions);}; MdPanelAnimation.prototype.animateClose = function (panelEl) {var animator = this._$mdUtil.dom.animator; var reverseAnimationOptions = {}; var panelTransform = panelEl[0].style.transform || ''; var closeFrom = animator.toTransformCss(panelTransform); var closeTo = animator.toTransformCss(panelTransform); switch (this._animationClass) {case MdPanelAnimation.animation.SLIDE: panelEl.css('opacity', '1'); reverseAnimationOptions = {transitionInClass: '_md-panel-animate-leave', }; var closeSlide = animator.calculateSlideToOrigin(panelEl, this._closeTo) || ''; closeTo = animator.toTransformCss(closeSlide + ' ' + panelTransform); break; case MdPanelAnimation.animation.SCALE: reverseAnimationOptions = {transitionInClass: '_md-panel-animate-scale-out _md-panel-animate-leave', }; var closeScale = animator.calculateZoomToOrigin(panelEl, this._closeTo) || ''; closeTo = animator.toTransformCss(closeScale + ' ' + panelTransform); break; case MdPanelAnimation.animation.FADE: reverseAnimationOptions = {transitionInClass: '_md-panel-animate-fade-out _md-panel-animate-leave', }; break; default: if (angular.isString(this._animationClass)) {reverseAnimationOptions = {transitionOutClass: this._animationClass, };}else {reverseAnimationOptions = {transitionInClass: this._animationClass['close'], transitionOutClass: this._animationClass['open'], };}}reverseAnimationOptions.duration = this._closeDuration; return animator.translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions);}; MdPanelAnimation.prototype._fixBounds = function (panelEl) {var panelWidth = panelEl[0].offsetWidth; var panelHeight = panelEl[0].offsetHeight; if (this._openFrom && this._openFrom.bounds.height == null) {this._openFrom.bounds.height = panelHeight;}if (this._openFrom && this._openFrom.bounds.width == null) {this._openFrom.bounds.width = panelWidth;}if (this._closeTo && this._closeTo.bounds.height == null) {this._closeTo.bounds.height = panelHeight;}if (this._closeTo && this._closeTo.bounds.width == null) {this._closeTo.bounds.width = panelWidth;}}; MdPanelAnimation.prototype._getBoundingClientRect = function (element) {if (element instanceof angular.element) {return {element: element, bounds: element[0].getBoundingClientRect(), };}}; function getElement(el) {var queryResult = angular.isString(el) ? document.querySelector(el) : el; return angular.element(queryResult);}function getComputedTranslations(el, property) {var transform = getComputedStyle(el[0] || el)[property]; var openIndex = transform.indexOf('('); var closeIndex = transform.lastIndexOf(')'); var output = {x: 0, y: 0 }; if (openIndex > -1 && closeIndex > -1) {var parsedValues = transform .substring(openIndex + 1, closeIndex) .split(', ') .slice(-2); output.x = parseInt(parsedValues[0]); output.y = parseInt(parsedValues[1]);}return output;}})(); (function () {'use strict'; angular.module('material.components.progressCircular', ['material.core']);})(); (function () {'use strict'; MdProgressLinearDirective.$inject = ['$mdTheming', '$mdUtil', '$log']; angular.module('material.components.progressLinear', ['material.core']).directive('mdProgressLinear', MdProgressLinearDirective); function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {var MODE_DETERMINATE = 'determinate'; var MODE_INDETERMINATE = 'indeterminate'; var MODE_BUFFER = 'buffer'; var MODE_QUERY = 'query'; var DISABLED_CLASS = '_md-progress-linear-disabled'; return {restrict: 'E', template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + '</div>', compile: compile, }; function compile(tElement, tAttrs, transclude) {tElement.attr('aria-valuemin', 0); tElement.attr('aria-valuemax', 100); tElement.attr('role', 'progressbar'); return postLink;}function postLink(scope, element, attr) {$mdTheming(element); var lastMode; var isDisabled = attr.hasOwnProperty('disabled'); var toVendorCSS = $mdUtil.dom.animator.toCss; var bar1 = angular.element(element[0].querySelector('.md-bar1')); var bar2 = angular.element(element[0].querySelector('.md-bar2')); var container = angular.element(element[0].querySelector('.md-container')); element.attr('md-mode', mode()).toggleClass(DISABLED_CLASS, isDisabled); validateMode(); watchAttributes(); function watchAttributes() {attr.$observe('value', function (value) {var percentValue = clamp(value); element.attr('aria-valuenow', percentValue); if (mode() != MODE_QUERY) animateIndicator(bar2, percentValue);}); attr.$observe('mdBufferValue', function (value) {animateIndicator(bar1, clamp(value));}); attr.$observe('disabled', function (value) {if (value === true || value === false) {isDisabled = !!value;}else {isDisabled = angular.isDefined(value);}element.toggleClass(DISABLED_CLASS, isDisabled); container.toggleClass(lastMode, !isDisabled);}); attr.$observe('mdMode', function (mode) {if (lastMode) container.removeClass(lastMode); switch (mode) {case MODE_QUERY: case MODE_BUFFER: case MODE_DETERMINATE: case MODE_INDETERMINATE: container.addClass((lastMode = 'md-mode-' + mode)); break; default: container.addClass((lastMode = 'md-mode-' + MODE_INDETERMINATE)); break;}});}function validateMode() {if (angular.isUndefined(attr.mdMode)) {var hasValue = angular.isDefined(attr.value); var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE; var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element"; element.attr('md-mode', mode); attr.mdMode = mode;}}function mode() {var value = (attr.mdMode || '').trim(); if (value) {switch (value) {case MODE_DETERMINATE: case MODE_INDETERMINATE: case MODE_BUFFER: case MODE_QUERY: break; default: value = MODE_INDETERMINATE; break;}}return value;}function animateIndicator(target, value) {if (isDisabled || !mode()) return; var to = $mdUtil.supplant('translateX({0}%) scale({1},1)', [(value - 100) / 2, value / 100]); var styles = toVendorCSS({transform: to }); angular.element(target).css(styles);}}function clamp(value) {return Math.max(0, Math.min(value || 0, 100));}}})(); (function () {'use strict'; mdRadioGroupDirective.$inject = ['$mdUtil', '$mdConstant', '$mdTheming', '$timeout']; mdRadioButtonDirective.$inject = ['$mdAria', '$mdUtil', '$mdTheming']; angular .module('material.components.radioButton', ['material.core']) .directive('mdRadioGroup', mdRadioGroupDirective) .directive('mdRadioButton', mdRadioButtonDirective); function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {RadioGroupController.prototype = createRadioGroupControllerProto(); return {restrict: 'E', controller: ['$element', RadioGroupController], require: ['mdRadioGroup', '?ngModel'], link: {pre: linkRadioGroup }, }; function linkRadioGroup(scope, element, attr, ctrls) {element.addClass('_md'); $mdTheming(element); var rgCtrl = ctrls[0]; var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(); rgCtrl.init(ngModelCtrl); scope.mouseActive = false; element .attr({role: 'radiogroup', tabIndex: element.attr('tabindex') || '0', }) .on('keydown', keydownListener) .on('mousedown', function (event) {scope.mouseActive = true; $timeout(function () {scope.mouseActive = false;}, 100);}) .on('focus', function () {if (scope.mouseActive === false) {rgCtrl.$element.addClass('md-focused');}}) .on('blur', function () {rgCtrl.$element.removeClass('md-focused');}); function setFocus() {if (!element.hasClass('md-focused')) {element.addClass('md-focused');}}function keydownListener(ev) {var keyCode = ev.which || ev.keyCode; if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) {return;}switch (keyCode) {case $mdConstant.KEY_CODE.LEFT_ARROW: case $mdConstant.KEY_CODE.UP_ARROW: ev.preventDefault(); rgCtrl.selectPrevious(); setFocus(); break; case $mdConstant.KEY_CODE.RIGHT_ARROW: case $mdConstant.KEY_CODE.DOWN_ARROW: ev.preventDefault(); rgCtrl.selectNext(); setFocus(); break; case $mdConstant.KEY_CODE.ENTER: var form = angular.element($mdUtil.getClosest(element[0], 'form')); if (form.length > 0) {form.triggerHandler('submit');}break;}}}function RadioGroupController($element) {this._radioButtonRenderFns = []; this.$element = $element;}function createRadioGroupControllerProto() {return {init: function (ngModelCtrl) {this._ngModelCtrl = ngModelCtrl; this._ngModelCtrl.$render = angular.bind(this, this.render);}, add: function (rbRender) {this._radioButtonRenderFns.push(rbRender);}, remove: function (rbRender) {var index = this._radioButtonRenderFns.indexOf(rbRender); if (index !== -1) {this._radioButtonRenderFns.splice(index, 1);}}, render: function () {this._radioButtonRenderFns.forEach(function (rbRender) {rbRender();});}, setViewValue: function (value, eventType) {this._ngModelCtrl.$setViewValue(value, eventType); this.render();}, getViewValue: function () {return this._ngModelCtrl.$viewValue;}, selectNext: function () {return changeSelectedButton(this.$element, 1);}, selectPrevious: function () {return changeSelectedButton(this.$element, -1);}, setActiveDescendant: function (radioId) {this.$element.attr('aria-activedescendant', radioId);}, isDisabled: function () {return this.$element[0].hasAttribute('disabled');}, };}function changeSelectedButton(parent, increment) {var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true); if (buttons.count()) {var validate = function (button) {return !angular.element(button).attr('disabled');}; var selected = parent[0].querySelector('md-radio-button.md-checked'); var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first(); angular.element(target).triggerHandler('click');}}}function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {var CHECKED_CSS = 'md-checked'; return {restrict: 'E', require: '^mdRadioGroup', transclude: true, template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>', link: link, }; function link(scope, element, attr, rgCtrl) {var lastChecked; $mdTheming(element); configureAria(element, scope); if (attr.ngValue) {$mdUtil.nextTick(initialize, false);}else {initialize();}function initialize() {if (!rgCtrl) {throw 'RadioButton: No RadioGroupController could be found.';}rgCtrl.add(render); attr.$observe('value', render); element.on('click', listener).on('$destroy', function () {rgCtrl.remove(render);});}function listener(ev) {if (element[0].hasAttribute('disabled') || rgCtrl.isDisabled()) return; scope.$apply(function () {rgCtrl.setViewValue(attr.value, ev && ev.type);});}function render() {var checked = rgCtrl.getViewValue() == attr.value; if (checked === lastChecked) return; if (element[0].parentNode.nodeName.toLowerCase() !== 'md-radio-group') {element.parent().toggleClass(CHECKED_CSS, checked);}if (checked) {rgCtrl.setActiveDescendant(element.attr('id'));}lastChecked = checked; element.attr('aria-checked', checked).toggleClass(CHECKED_CSS, checked);}function configureAria(element, scope) {element.attr({id: attr.id || 'radio_' + $mdUtil.nextUid(), role: 'radio', 'aria-checked': 'false', }); $mdAria.expectWithText(element, 'aria-label');}}}})(); (function () {'use strict'; SelectDirective.$inject = ['$mdSelect', '$mdUtil', '$mdConstant', '$mdTheming', '$mdAria', '$parse', '$sce', '$injector']; SelectMenuDirective.$inject = ['$parse', '$mdUtil', '$mdConstant', '$mdTheming']; OptionDirective.$inject = ['$mdButtonInkRipple', '$mdUtil', '$mdTheming']; SelectProvider.$inject = ['$$interimElementProvider']; var SELECT_EDGE_MARGIN = 8; var selectNextId = 0; var CHECKBOX_SELECTION_INDICATOR = angular.element('<div class="md-container"><div class="md-icon"></div></div>'); angular .module('material.components.select', ['material.core', 'material.components.backdrop']) .directive('mdSelect', SelectDirective) .directive('mdSelectMenu', SelectMenuDirective) .directive('mdOption', OptionDirective) .directive('mdOptgroup', OptgroupDirective) .directive('mdSelectHeader', SelectHeaderDirective) .provider('$mdSelect', SelectProvider); function SelectDirective($mdSelect, $mdUtil, $mdConstant, $mdTheming, $mdAria, $parse, $sce, $injector) {var keyCodes = $mdConstant.KEY_CODE; var NAVIGATION_KEYS = [keyCodes.SPACE, keyCodes.ENTER, keyCodes.UP_ARROW, keyCodes.DOWN_ARROW]; return {restrict: 'E', require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'], compile: compile, controller: function () {}, }; function compile(element, attr) {var valueEl = angular.element('<md-select-value><span></span></md-select-value>'); valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>'); valueEl.addClass('md-select-value'); if (!valueEl[0].hasAttribute('id')) {valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());}var mdContentEl = element.find('md-content'); if (!mdContentEl.length) {element.append(angular.element('<md-content>').append(element.contents()));}mdContentEl.attr('role', 'presentation'); if (attr.mdOnOpen) {element .find('md-content') .prepend( angular.element( '<div>' + ' <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular>' + '</div>', ), ); element.find('md-option').attr('ng-show', '$$loadingAsyncDone');}if (attr.name) {var autofillClone = angular.element('<select class="md-visually-hidden">'); autofillClone.attr({name: attr.name, 'aria-hidden': 'true', tabindex: '-1', }); var opts = element.find('md-option'); angular.forEach(opts, function (el) {var newEl = angular.element('<option>' + el.innerHTML + '</option>'); if (el.hasAttribute('ng-value')) newEl.attr('ng-value', el.getAttribute('ng-value')); else if (el.hasAttribute('value')) newEl.attr('value', el.getAttribute('value')); autofillClone.append(newEl);}); autofillClone.append('<option ng-value="' + attr.ngModel + '" selected></option>'); element.parent().append(autofillClone);}var isMultiple = $mdUtil.parseAttributeBoolean(attr.multiple); var multipleContent = isMultiple ? 'multiple' : ''; var selectTemplate = '' + '<div class="md-select-menu-container" aria-hidden="true" role="presentation">' + '<md-select-menu role="presentation" {0}>{1}</md-select-menu>' + '</div>'; selectTemplate = $mdUtil.supplant(selectTemplate, [multipleContent, element.html()]); element.empty().append(valueEl); element.append(selectTemplate); if (!attr.tabindex) {attr.$set('tabindex', 0);}return function postLink(scope, element, attr, ctrls) {var untouched = true; var isDisabled, ariaLabelBase; var containerCtrl = ctrls[0]; var mdSelectCtrl = ctrls[1]; var ngModelCtrl = ctrls[2]; var formCtrl = ctrls[3]; var valueEl = element.find('md-select-value'); var isReadonly = angular.isDefined(attr.readonly); var disableAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk); if (disableAsterisk) {element.addClass('md-no-asterisk');}if (containerCtrl) {var isErrorGetter = containerCtrl.isErrorGetter || function () {return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (formCtrl && formCtrl.$submitted));}; if (containerCtrl.input) {if (element.find('md-select-header').find('input')[0] !== containerCtrl.input[0]) {throw new Error('<md-input-container> can only have *one* child <input>, <textarea> or <select> element!');}}containerCtrl.input = element; if (!containerCtrl.label) {$mdAria.expect(element, 'aria-label', element.attr('placeholder'));}scope.$watch(isErrorGetter, containerCtrl.setInvalid);}var selectContainer, selectScope, selectMenuCtrl; findSelectContainer(); $mdTheming(element); if (formCtrl && angular.isDefined(attr.multiple)) {$mdUtil.nextTick(function () {var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue; if (hasModelValue) {formCtrl.$setPristine();}});}var originalRender = ngModelCtrl.$render; ngModelCtrl.$render = function () {originalRender(); syncLabelText(); syncAriaLabel(); inputCheckValue();}; attr.$observe('placeholder', ngModelCtrl.$render); if (containerCtrl && containerCtrl.label) {attr.$observe('required', function (value) {containerCtrl.label.toggleClass('md-required', value && !disableAsterisk);});}mdSelectCtrl.setLabelText = function (text) {mdSelectCtrl.setIsPlaceholder(!text); var isSelectLabelFromUser = false; if (attr.mdSelectedText && attr.mdSelectedHtml) {throw Error('md-select cannot have both `md-selected-text` and `md-selected-html`');}if (attr.mdSelectedText || attr.mdSelectedHtml) {text = $parse(attr.mdSelectedText || attr.mdSelectedHtml)(scope); isSelectLabelFromUser = true;}else if (!text) {var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : ''); text = tmpPlaceholder || ''; isSelectLabelFromUser = true;}var target = valueEl.children().eq(0); if (attr.mdSelectedHtml) {target.html($sce.getTrustedHtml(text));}else if (isSelectLabelFromUser) {target.text(text);}else {target.html(text);}}; mdSelectCtrl.setIsPlaceholder = function (isPlaceholder) {if (isPlaceholder) {valueEl.addClass('md-select-placeholder'); if (containerCtrl && containerCtrl.label) {containerCtrl.label.addClass('md-placeholder');}}else {valueEl.removeClass('md-select-placeholder'); if (containerCtrl && containerCtrl.label) {containerCtrl.label.removeClass('md-placeholder');}}}; if (!isReadonly) {element.on('focus', function (ev) {containerCtrl && containerCtrl.setFocused(true);}); element.on('blur', function (event) {if (untouched) {untouched = false; if (selectScope._mdSelectIsOpen) {event.stopImmediatePropagation();}}if (selectScope._mdSelectIsOpen) return; containerCtrl && containerCtrl.setFocused(false); inputCheckValue();});}mdSelectCtrl.triggerClose = function () {$parse(attr.mdOnClose)(scope);}; scope.$$postDigest(function () {initAriaLabel(); syncLabelText(); syncAriaLabel();}); function initAriaLabel() {var labelText = element.attr('aria-label') || element.attr('placeholder'); if (!labelText && containerCtrl && containerCtrl.label) {labelText = containerCtrl.label.text();}ariaLabelBase = labelText; $mdAria.expect(element, 'aria-label', labelText);}scope.$watch(function () {return selectMenuCtrl.selectedLabels();}, syncLabelText); function syncLabelText() {if (selectContainer) {selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu'); mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());}}function syncAriaLabel() {if (!ariaLabelBase) return; var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria' }); element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);}var deregisterWatcher; attr.$observe('ngMultiple', function (val) {if (deregisterWatcher) deregisterWatcher(); var parser = $parse(val); deregisterWatcher = scope.$watch( function () {return parser(scope);}, function (multiple, prevVal) {if (multiple === undefined && prevVal === undefined) return; if (multiple) {element.attr('multiple', 'multiple');}else {element.removeAttr('multiple');}element.attr('aria-multiselectable', multiple ? 'true' : 'false'); if (selectContainer) {selectMenuCtrl.setMultiple(multiple); originalRender = ngModelCtrl.$render; ngModelCtrl.$render = function () {originalRender(); syncLabelText(); syncAriaLabel(); inputCheckValue();}; ngModelCtrl.$render();}}, );}); attr.$observe('disabled', function (disabled) {if (angular.isString(disabled)) {disabled = true;}if (isDisabled !== undefined && isDisabled === disabled) {return;}isDisabled = disabled; if (disabled) {element.attr({'aria-disabled': 'true' }).removeAttr('tabindex').off('click', openSelect).off('keydown', handleKeypress);}else {element.attr({tabindex: attr.tabindex, 'aria-disabled': 'false' }).on('click', openSelect).on('keydown', handleKeypress);}}); if (!attr.hasOwnProperty('disabled') && !attr.hasOwnProperty('ngDisabled')) {element.attr({'aria-disabled': 'false' }); element.on('click', openSelect); element.on('keydown', handleKeypress);}var ariaAttrs = {role: 'listbox', 'aria-expanded': 'false', 'aria-multiselectable': isMultiple && !attr.ngMultiple ? 'true' : 'false', }; if (!element[0].hasAttribute('id')) {ariaAttrs.id = 'select_' + $mdUtil.nextUid();}var containerId = 'select_container_' + $mdUtil.nextUid(); selectContainer.attr('id', containerId); if (!element.find('md-select-menu').length) {ariaAttrs['aria-owns'] = containerId;}element.attr(ariaAttrs); scope.$on('$destroy', function () {$mdSelect.destroy().finally(function () {if (containerCtrl) {containerCtrl.setFocused(false); containerCtrl.setHasValue(false); containerCtrl.input = null;}ngModelCtrl.$setTouched();});}); function inputCheckValue() {containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);}function findSelectContainer() {selectContainer = angular.element(element[0].querySelector('.md-select-menu-container')); selectScope = scope; if (attr.mdContainerClass) {var value = selectContainer[0].getAttribute('class') + ' ' + attr.mdContainerClass; selectContainer[0].setAttribute('class', value);}selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu'); selectMenuCtrl.init(ngModelCtrl, attr.ngModel); element.on('$destroy', function () {selectContainer.remove();});}function handleKeypress(e) {if ($mdConstant.isNavigationKey(e)) {e.preventDefault(); openSelect(e);}else {if (shouldHandleKey(e, $mdConstant)) {e.preventDefault(); var node = selectMenuCtrl.optNodeForKeyboardSearch(e); if (!node || node.hasAttribute('disabled')) return; var optionCtrl = angular.element(node).controller('mdOption'); if (!selectMenuCtrl.isMultiple) {selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);}selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value); selectMenuCtrl.refreshViewValue();}}}function openSelect() {selectScope._mdSelectIsOpen = true; element.attr('aria-expanded', 'true'); $mdSelect .show({scope: selectScope, preserveScope: true, skipCompile: true, element: selectContainer, target: element[0], selectCtrl: mdSelectCtrl, preserveElement: true, hasBackdrop: true, loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false, }) .finally(function () {selectScope._mdSelectIsOpen = false; element.focus(); element.attr('aria-expanded', 'false'); ngModelCtrl.$setTouched();});}};}}function SelectMenuDirective($parse, $mdUtil, $mdConstant, $mdTheming) {SelectMenuController.$inject = ['$scope', '$attrs', '$element']; return {restrict: 'E', require: ['mdSelectMenu'], scope: false, controller: SelectMenuController, link: {pre: preLink }, }; function preLink(scope, element, attr, ctrls) {var selectCtrl = ctrls[0]; element.addClass('_md'); $mdTheming(element); element.on('click', clickListener); element.on('keypress', keyListener); function keyListener(e) {if (e.keyCode == 13 || e.keyCode == 32) {clickListener(e);}}function clickListener(ev) {var option = $mdUtil.getClosest(ev.target, 'md-option'); var optionCtrl = option && angular.element(option).data('$mdOptionController'); if (!option || !optionCtrl) return; if (option.hasAttribute('disabled')) {ev.stopImmediatePropagation(); return false;}var optionHashKey = selectCtrl.hashGetter(optionCtrl.value); var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]); scope.$apply(function () {if (selectCtrl.isMultiple) {if (isSelected) {selectCtrl.deselect(optionHashKey);}else {selectCtrl.select(optionHashKey, optionCtrl.value);}}else {if (!isSelected) {selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]); selectCtrl.select(optionHashKey, optionCtrl.value);}}selectCtrl.refreshViewValue();});}}function SelectMenuController($scope, $attrs, $element) {var self = this; self.isMultiple = angular.isDefined($attrs.multiple); self.selected = {}; self.options = {}; $scope.$watchCollection( function () {return self.options;}, function () {self.ngModel.$render();}, ); var deregisterCollectionWatch; var defaultIsEmpty; self.setMultiple = function (isMultiple) {var ngModel = self.ngModel; defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty; self.isMultiple = isMultiple; if (deregisterCollectionWatch) deregisterCollectionWatch(); if (self.isMultiple) {ngModel.$validators['md-multiple'] = validateArray; ngModel.$render = renderMultiple; $scope.$watchCollection(self.modelBinding, function (value) {if (validateArray(value)) renderMultiple(value); self.ngModel.$setPristine();}); ngModel.$isEmpty = function (value) {return !value || value.length === 0;};}else {delete ngModel.$validators['md-multiple']; ngModel.$render = renderSingular;}function validateArray(modelValue, viewValue) {return angular.isArray(modelValue || viewValue || []);}}; var searchStr = ''; var clearSearchTimeout, optNodes, optText; var CLEAR_SEARCH_AFTER = 300; self.optNodeForKeyboardSearch = function (e) {clearSearchTimeout && clearTimeout(clearSearchTimeout); clearSearchTimeout = setTimeout(function () {clearSearchTimeout = undefined; searchStr = ''; optText = undefined; optNodes = undefined;}, CLEAR_SEARCH_AFTER); var keyCode = e.keyCode - ($mdConstant.isNumPadKey(e) ? 48 : 0); searchStr += String.fromCharCode(keyCode); var search = new RegExp('^' + searchStr, 'i'); if (!optNodes) {optNodes = $element.find('md-option'); optText = new Array(optNodes.length); angular.forEach(optNodes, function (el, i) {optText[i] = el.textContent.trim();});}for (var i = 0; i < optText.length; ++i) {if (search.test(optText[i])) {return optNodes[i];}}}; self.init = function (ngModel, binding) {self.ngModel = ngModel; self.modelBinding = binding; self.ngModel.$isEmpty = function ($viewValue) {return !self.options[self.hashGetter($viewValue)];}; var trackByOption = $mdUtil.getModelOption(ngModel, 'trackBy'); if (trackByOption) {var trackByLocals = {}; var trackByParsed = $parse(trackByOption); self.hashGetter = function (value, valueScope) {trackByLocals.$value = value; return trackByParsed(valueScope || $scope, trackByLocals);};}else {self.hashGetter = function getHashValue(value) {if (angular.isObject(value)) {return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));}return value;};}self.setMultiple(self.isMultiple);}; self.selectedLabels = function (opts) {opts = opts || {}; var mode = opts.mode || 'html'; var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]')); if (selectedOptionEls.length) {var mapFn; if (mode == 'html') {mapFn = function (el) {if (el.hasAttribute('md-option-empty')) {return '';}var html = el.innerHTML; var rippleContainer = el.querySelector('.md-ripple-container'); if (rippleContainer) {html = html.replace(rippleContainer.outerHTML, '');}var checkboxContainer = el.querySelector('.md-container'); if (checkboxContainer) {html = html.replace(checkboxContainer.outerHTML, '');}return html;};}else if (mode == 'aria') {mapFn = function (el) {return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent;};}return $mdUtil.uniq(selectedOptionEls.map(mapFn)).join(', ');}else {return '';}}; self.select = function (hashKey, hashedValue) {var option = self.options[hashKey]; option && option.setSelected(true); self.selected[hashKey] = hashedValue;}; self.deselect = function (hashKey) {var option = self.options[hashKey]; option && option.setSelected(false); delete self.selected[hashKey];}; self.addOption = function (hashKey, optionCtrl) {if (angular.isDefined(self.options[hashKey])) {throw new Error('Duplicate md-option values are not allowed in a select. ' + 'Duplicate value "' + optionCtrl.value + '" found.');}self.options[hashKey] = optionCtrl; if (angular.isDefined(self.selected[hashKey])) {self.select(hashKey, optionCtrl.value); if (angular.isDefined(self.ngModel.$modelValue) && self.hashGetter(self.ngModel.$modelValue) === hashKey) {self.ngModel.$validate();}self.refreshViewValue();}}; self.removeOption = function (hashKey) {delete self.options[hashKey];}; self.refreshViewValue = function () {var values = []; var option; for (var hashKey in self.selected) {if ((option = self.options[hashKey])) {values.push(option.value);}else {values.push(self.selected[hashKey]);}}var usingTrackBy = $mdUtil.getModelOption(self.ngModel, 'trackBy'); var newVal = self.isMultiple ? values : values[0]; var prevVal = self.ngModel.$modelValue; if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal + '' !== newVal) {self.ngModel.$setViewValue(newVal); self.ngModel.$render();}}; function renderMultiple() {var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || []; if (!angular.isArray(newSelectedValues)) return; var oldSelected = Object.keys(self.selected); var newSelectedHashes = newSelectedValues.map(self.hashGetter); var deselected = oldSelected.filter(function (hash) {return newSelectedHashes.indexOf(hash) === -1;}); deselected.forEach(self.deselect); newSelectedHashes.forEach(function (hashKey, i) {self.select(hashKey, newSelectedValues[i]);});}function renderSingular() {var value = self.ngModel.$viewValue || self.ngModel.$modelValue; Object.keys(self.selected).forEach(self.deselect); self.select(self.hashGetter(value), value);}}}function OptionDirective($mdButtonInkRipple, $mdUtil, $mdTheming) {OptionController.$inject = ['$element']; return {restrict: 'E', require: ['mdOption', '^^mdSelectMenu'], controller: OptionController, compile: compile, }; function compile(element, attr) {element.append(angular.element('<div class="md-text">').append(element.contents())); element.attr('tabindex', attr.tabindex || '0'); if (!hasDefinedValue(attr)) {element.attr('md-option-empty', '');}return postLink;}function hasDefinedValue(attr) {var value = attr.value; var ngValue = attr.ngValue; return value || ngValue;}function postLink(scope, element, attr, ctrls) {var optionCtrl = ctrls[0]; var selectCtrl = ctrls[1]; $mdTheming(element); if (selectCtrl.isMultiple) {element.addClass('md-checkbox-enabled'); element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());}if (angular.isDefined(attr.ngValue)) {scope.$watch(attr.ngValue, setOptionValue);}else if (angular.isDefined(attr.value)) {setOptionValue(attr.value);}else {scope.$watch(function () {return element.text().trim();}, setOptionValue);}attr.$observe('disabled', function (disabled) {if (disabled) {element.attr('tabindex', '-1');}else {element.attr('tabindex', '0');}}); scope.$$postDigest(function () {attr.$observe('selected', function (selected) {if (!angular.isDefined(selected)) return; if (typeof selected == 'string') selected = true; if (selected) {if (!selectCtrl.isMultiple) {selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);}selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);}else {selectCtrl.deselect(optionCtrl.hashKey);}selectCtrl.refreshViewValue();});}); $mdButtonInkRipple.attach(scope, element); configureAria(); function setOptionValue(newValue, oldValue, prevAttempt) {if (!selectCtrl.hashGetter) {if (!prevAttempt) {scope.$$postDigest(function () {setOptionValue(newValue, oldValue, true);});}return;}var oldHashKey = selectCtrl.hashGetter(oldValue, scope); var newHashKey = selectCtrl.hashGetter(newValue, scope); optionCtrl.hashKey = newHashKey; optionCtrl.value = newValue; selectCtrl.removeOption(oldHashKey, optionCtrl); selectCtrl.addOption(newHashKey, optionCtrl);}scope.$on('$destroy', function () {selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);}); function configureAria() {var ariaAttrs = {role: 'option', 'aria-selected': 'false', }; if (!element[0].hasAttribute('id')) {ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();}element.attr(ariaAttrs);}}function OptionController($element) {this.selected = false; this.setSelected = function (isSelected) {if (isSelected && !this.selected) {$element.attr({selected: 'selected', 'aria-selected': 'true', });}else if (!isSelected && this.selected) {$element.removeAttr('selected'); $element.attr('aria-selected', 'false');}this.selected = isSelected;};}}function OptgroupDirective() {return {restrict: 'E', compile: compile, }; function compile(el, attrs) {if (!hasSelectHeader()) {setupLabelElement();}function hasSelectHeader() {return el.parent().find('md-select-header').length;}function setupLabelElement() {var labelElement = el.find('label'); if (!labelElement.length) {labelElement = angular.element('<label>'); el.prepend(labelElement);}labelElement.addClass('md-container-ignore'); labelElement.attr('aria-hidden', 'true'); if (attrs.label) labelElement.text(attrs.label);}}}function SelectHeaderDirective() {return {restrict: 'E', };}function SelectProvider($$interimElementProvider) {selectDefaultOptions.$inject = ['$mdSelect', '$mdConstant', '$mdUtil', '$window', '$q', '$$rAF', '$animateCss', '$animate', '$document']; return $$interimElementProvider('$mdSelect').setDefaults({methods: ['target'], options: selectDefaultOptions, }); function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {var ERROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!"; var animator = $mdUtil.dom.animator; var keyCodes = $mdConstant.KEY_CODE; return {parent: 'body', themable: true, onShow: onShow, onRemove: onRemove, hasBackdrop: true, disableParentScroll: true, }; function onRemove(scope, element, opts) {var animationRunner = null; var destroyListener = scope.$on('$destroy', function () {animationRunner.end();}); opts = opts || {}; opts.cleanupInteraction(); opts.cleanupResizing(); opts.hideBackdrop(); return opts.$destroy === true ? cleanElement() : animateRemoval().then(cleanElement); function animateRemoval() {animationRunner = $animateCss(element, {addClass: 'md-leave' }); return animationRunner.start();}function cleanElement() {destroyListener(); element.removeClass('md-active').attr('aria-hidden', 'true').css('display', 'none'); element.parent().find('md-select-value').removeAttr('aria-hidden'); announceClosed(opts); if (!opts.$destroy && opts.restoreFocus) {opts.target.focus();}}}function onShow(scope, element, opts) {watchAsyncLoad(); sanitizeAndConfigure(scope, opts); opts.hideBackdrop = showBackdrop(scope, element, opts); return showDropDown(scope, element, opts).then(function (response) {element.attr('aria-hidden', 'false'); opts.alreadyOpen = true; opts.cleanupInteraction = activateInteraction(); opts.cleanupResizing = activateResizing(); autoFocus(opts.focusedNode); return response;}, opts.hideBackdrop); function showDropDown(scope, element, opts) {if (opts.parent !== element.parent()) {element.parent().attr('aria-owns', element.attr('id'));}element.parent().find('md-select-value').attr('aria-hidden', 'true'); opts.parent.append(element); return $q(function (resolve, reject) {try {$animateCss(element, {removeClass: 'md-leave', duration: 0 }).start().then(positionAndFocusMenu).then(resolve);}catch (e) {reject(e);}});}function positionAndFocusMenu() {return $q(function (resolve) {if (opts.isRemoved) return $q.reject(false); var info = calculateMenuPositions(scope, element, opts); info.container.element.css(animator.toCss(info.container.styles)); info.dropDown.element.css(animator.toCss(info.dropDown.styles)); $$rAF(function () {element.addClass('md-active'); info.dropDown.element.css(animator.toCss({transform: '' })); resolve();});});}function showBackdrop(scope, element, options) {if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);}else {options.disableParentScroll = false;}if (options.hasBackdrop) {options.backdrop = $mdUtil.createBackdrop(scope, 'md-select-backdrop md-click-catcher'); $animate.enter(options.backdrop, $document[0].body, null, {duration: 0 });}return function hideBackdrop() {if (options.backdrop) options.backdrop.remove(); if (options.disableParentScroll) options.restoreScroll(); delete options.restoreScroll;};}function autoFocus(focusedNode) {if (focusedNode && !focusedNode.hasAttribute('disabled')) {focusedNode.focus();}}function sanitizeAndConfigure(scope, options) {var selectEl = element.find('md-select-menu'); if (!options.target) {throw new Error($mdUtil.supplant(ERROR_TARGET_EXPECTED, [options.target]));}angular.extend(options, {isRemoved: false, target: angular.element(options.target), parent: angular.element(options.parent), selectEl: selectEl, contentEl: element.find('md-content'), optionNodes: selectEl[0].getElementsByTagName('md-option'), });}function activateResizing() {var debouncedOnResize = (function (scope, target, options) {return function () {if (options.isRemoved) return; var updates = calculateMenuPositions(scope, target, options); var container = updates.container; var dropDown = updates.dropDown; container.element.css(animator.toCss(container.styles)); dropDown.element.css(animator.toCss(dropDown.styles));};})(scope, element, opts); var window = angular.element($window); window.on('resize', debouncedOnResize); window.on('orientationchange', debouncedOnResize); return function deactivateResizing() {window.off('resize', debouncedOnResize); window.off('orientationchange', debouncedOnResize);};}function watchAsyncLoad() {if (opts.loadingAsync && !opts.isRemoved) {scope.$$loadingAsyncDone = false; $q.when(opts.loadingAsync) .then(function () {scope.$$loadingAsyncDone = true; delete opts.loadingAsync;}) .then(function () {$$rAF(positionAndFocusMenu);});}}function activateInteraction() {if (opts.isRemoved) return; var dropDown = opts.selectEl; var selectCtrl = dropDown.controller('mdSelectMenu') || {}; element.addClass('md-clickable'); opts.backdrop && opts.backdrop.on('click', onBackdropClick); dropDown.on('keydown', onMenuKeyDown); dropDown.on('click', checkCloseMenu); return function cleanupInteraction() {opts.backdrop && opts.backdrop.off('click', onBackdropClick); dropDown.off('keydown', onMenuKeyDown); dropDown.off('click', checkCloseMenu); element.removeClass('md-clickable'); opts.isRemoved = true;}; function onBackdropClick(e) {e.preventDefault(); e.stopPropagation(); opts.restoreFocus = false; $mdUtil.nextTick($mdSelect.hide, true);}function onMenuKeyDown(ev) {ev.preventDefault(); ev.stopPropagation(); switch (ev.keyCode) {case keyCodes.UP_ARROW: return focusPrevOption(); case keyCodes.DOWN_ARROW: return focusNextOption(); case keyCodes.SPACE: case keyCodes.ENTER: var option = $mdUtil.getClosest(ev.target, 'md-option'); if (option) {dropDown.triggerHandler({type: 'click', target: option, }); ev.preventDefault();}checkCloseMenu(ev); break; case keyCodes.TAB: case keyCodes.ESCAPE: ev.stopPropagation(); ev.preventDefault(); opts.restoreFocus = true; $mdUtil.nextTick($mdSelect.hide, true); break; default: if (shouldHandleKey(ev, $mdConstant)) {var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev); opts.focusedNode = optNode || opts.focusedNode; optNode && optNode.focus();}}}function focusOption(direction) {var optionsArray = $mdUtil.nodesToArray(opts.optionNodes); var index = optionsArray.indexOf(opts.focusedNode); var newOption; do {if (index === -1) {index = 0;}else if (direction === 'next' && index < optionsArray.length - 1) {index++;}else if (direction === 'prev' && index > 0) {index--;}newOption = optionsArray[index]; if (newOption.hasAttribute('disabled')) newOption = undefined;}while (!newOption && index < optionsArray.length - 1 && index > 0); newOption && newOption.focus(); opts.focusedNode = newOption;}function focusNextOption() {focusOption('next');}function focusPrevOption() {focusOption('prev');}function checkCloseMenu(ev) {if (ev && ev.type == 'click' && ev.currentTarget != dropDown[0]) return; if (mouseOnScrollbar()) return; var option = $mdUtil.getClosest(ev.target, 'md-option'); if (option && option.hasAttribute && !option.hasAttribute('disabled')) {ev.preventDefault(); ev.stopPropagation(); if (!selectCtrl.isMultiple) {opts.restoreFocus = true; $mdUtil.nextTick(function () {$mdSelect.hide(selectCtrl.ngModel.$viewValue);}, true);}}function mouseOnScrollbar() {var clickOnScrollbar = false; if (ev && ev.currentTarget.children.length > 0) {var child = ev.currentTarget.children[0]; var hasScrollbar = child.scrollHeight > child.clientHeight; if (hasScrollbar && child.children.length > 0) {var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left; if (relPosX > child.querySelector('md-option').offsetWidth) clickOnScrollbar = true;}}return clickOnScrollbar;}}}}function announceClosed(opts) {var mdSelect = opts.selectCtrl; if (mdSelect) {var menuController = opts.selectEl.controller('mdSelectMenu'); mdSelect.setLabelText(menuController ? menuController.selectedLabels() : ''); mdSelect.triggerClose();}}function calculateMenuPositions(scope, element, opts) {var containerNode = element[0], targetNode = opts.target[0].children[0], parentNode = $document[0].body, selectNode = opts.selectEl[0], contentNode = opts.contentEl[0], parentRect = parentNode.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), shouldOpenAroundTarget = false, bounds = {left: parentRect.left + SELECT_EDGE_MARGIN, top: SELECT_EDGE_MARGIN, bottom: parentRect.height - SELECT_EDGE_MARGIN, right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0), }, spaceAvailable = {top: targetRect.top - bounds.top, left: targetRect.left - bounds.left, right: bounds.right - (targetRect.left + targetRect.width), bottom: bounds.bottom - (targetRect.top + targetRect.height), }, maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2, selectedNode = selectNode.querySelector('md-option[selected]'), optionNodes = selectNode.getElementsByTagName('md-option'), optgroupNodes = selectNode.getElementsByTagName('md-optgroup'), isScrollable = calculateScrollable(element, contentNode), centeredNode; var loading = isPromiseLike(opts.loadingAsync); if (!loading) {if (selectedNode) {centeredNode = selectedNode;}else if (optgroupNodes.length) {centeredNode = optgroupNodes[0];}else if (optionNodes.length) {centeredNode = optionNodes[0];}else {centeredNode = contentNode.firstElementChild || contentNode;}}else {centeredNode = contentNode.firstElementChild || contentNode;}if (contentNode.offsetWidth > maxWidth) {contentNode.style['max-width'] = maxWidth + 'px';}else {contentNode.style.maxWidth = null;}if (shouldOpenAroundTarget) {contentNode.style['min-width'] = targetRect.width + 'px';}if (isScrollable) {selectNode.classList.add('md-overflow');}var focusedNode = centeredNode; if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode; centeredNode = focusedNode;}opts.focusedNode = focusedNode; containerNode.style.display = 'block'; var selectMenuRect = selectNode.getBoundingClientRect(); var centeredRect = getOffsetRect(centeredNode); if (centeredNode) {var centeredStyle = $window.getComputedStyle(centeredNode); centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0; centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;}if (isScrollable) {var scrollBuffer = contentNode.offsetHeight / 2; contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer; if (spaceAvailable.top < scrollBuffer) {contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);}else if (spaceAvailable.bottom < scrollBuffer) {contentNode.scrollTop = Math.max( centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom, );}}var left, top, transformOrigin, minWidth, fontSize; if (shouldOpenAroundTarget) {left = targetRect.left; top = targetRect.top + targetRect.height; transformOrigin = '50% 0'; if (top + selectMenuRect.height > bounds.bottom) {top = targetRect.top - selectMenuRect.height; transformOrigin = '50% 100%';}}else {left = targetRect.left + centeredRect.left - centeredRect.paddingLeft + 2; top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2; transformOrigin = centeredRect.left + targetRect.width / 2 + 'px ' + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px'; minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth); fontSize = window.getComputedStyle(targetNode)['font-size'];}var containerRect = containerNode.getBoundingClientRect(); var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100; var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100; return {container: {element: angular.element(containerNode), styles: {left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)), top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)), 'min-width': minWidth, 'font-size': fontSize, }, }, dropDown: {element: angular.element(selectNode), styles: {transformOrigin: transformOrigin, transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : '', }, }, };}}function isPromiseLike(obj) {return obj && angular.isFunction(obj.then);}function clamp(min, n, max) {return Math.max(min, Math.min(n, max));}function getOffsetRect(node) {return node ? {left: node.offsetLeft, top: node.offsetTop, width: node.offsetWidth, height: node.offsetHeight, }: {left: 0, top: 0, width: 0, height: 0 };}function calculateScrollable(element, contentNode) {var isScrollable = false; try {var oldDisplay = element[0].style.display; element[0].style.display = 'block'; isScrollable = contentNode.scrollHeight > contentNode.offsetHeight; element[0].style.display = oldDisplay;}finally {}return isScrollable;}}function shouldHandleKey(ev, $mdConstant) {var char = String.fromCharCode(ev.keyCode); var isNonUsefulKey = ev.keyCode <= 31; return char && char.length && !isNonUsefulKey && !$mdConstant.isMetaKey(ev) && !$mdConstant.isFnLockKey(ev) && !$mdConstant.hasModifierKey(ev);}})(); (function () {'use strict'; angular .module('material.components.showHide', ['material.core']) .directive('ngShow', createDirective('ngShow', true)) .directive('ngHide', createDirective('ngHide', false)); function createDirective(name, targetValue) {return [ '$mdUtil', '$window', function ($mdUtil, $window) {return {restrict: 'A', multiElement: true, link: function ($scope, $element, $attr) {var unregister = $scope.$on('$md-resize-enable', function () {unregister(); var node = $element[0]; var cachedTransitionStyles = node.nodeType === $window.Node.ELEMENT_NODE ? $window.getComputedStyle(node) : {}; $scope.$watch($attr[name], function (value) {if (!!value === targetValue) {$mdUtil.nextTick(function () {$scope.$broadcast('$md-resize');}); var opts = {cachedTransitionStyles: cachedTransitionStyles, }; $mdUtil.dom.animator.waitTransitionEnd($element, opts).then(function () {$scope.$broadcast('$md-resize');});}});});}, };}, ];}})(); (function () {'use strict'; SidenavService.$inject = ['$mdComponentRegistry', '$mdUtil', '$q', '$log']; SidenavDirective.$inject = [ '$mdMedia', '$mdUtil', '$mdConstant', '$mdTheming', '$mdInteraction', '$animate', '$compile', '$parse', '$log', '$q', '$document', '$window', '$$rAF', ]; SidenavController.$inject = ['$scope', '$attrs', '$mdComponentRegistry', '$q', '$interpolate']; angular .module('material.components.sidenav', ['material.core', 'material.components.backdrop']) .factory('$mdSidenav', SidenavService) .directive('mdSidenav', SidenavDirective) .directive('mdSidenavFocus', SidenavFocusDirective) .controller('$mdSidenavController', SidenavController); function SidenavService($mdComponentRegistry, $mdUtil, $q, $log) {var errorMsg = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?"; var service = {find: findInstance, waitFor: waitForInstance, }; return function (handle, enableWait) {if (angular.isUndefined(handle)) return service; var shouldWait = enableWait === true; var instance = service.find(handle, shouldWait); return !instance && shouldWait ? service.waitFor(handle) : !instance && angular.isUndefined(enableWait) ? addLegacyAPI(service, handle) : instance;}; function addLegacyAPI(service, handle) {var falseFn = function () {return false;}; var rejectFn = function () {return $q.when($mdUtil.supplant(errorMsg, [handle || '']));}; return angular.extend( {isLockedOpen: falseFn, isOpen: falseFn, toggle: rejectFn, open: rejectFn, close: rejectFn, onClose: angular.noop, then: function (callback) {return waitForInstance(handle).then(callback || angular.noop);}, }, service, );}function findInstance(handle, shouldWait) {var instance = $mdComponentRegistry.get(handle); if (!instance && !shouldWait) {$log.error($mdUtil.supplant(errorMsg, [handle || ''])); return undefined;}return instance;}function waitForInstance(handle) {return $mdComponentRegistry.when(handle).catch($log.error);}}function SidenavFocusDirective() {return {restrict: 'A', require: '^mdSidenav', link: function (scope, element, attr, sidenavCtrl) {}, };}function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $mdInteraction, $animate, $compile, $parse, $log, $q, $document, $window, $$rAF) {return {restrict: 'E', scope: {isOpen: '=?mdIsOpen', }, controller: '$mdSidenavController', compile: function (element) {element.addClass('md-closed').attr('tabIndex', '-1'); return postLink;}, }; function postLink(scope, element, attr, sidenavCtrl) {var lastParentOverFlow; var backdrop; var disableScrollTarget = null; var triggeringInteractionType; var triggeringElement = null; var previousContainerStyles; var promise = $q.when(true); var isLockedOpenParsed = $parse(attr.mdIsLockedOpen); var ngWindow = angular.element($window); var isLocked = function () {return isLockedOpenParsed(scope.$parent, {$media: function (arg) {$log.warn('$media is deprecated for is-locked-open. Use $mdMedia instead.'); return $mdMedia(arg);}, $mdMedia: $mdMedia, });}; if (attr.mdDisableScrollTarget) {disableScrollTarget = $document[0].querySelector(attr.mdDisableScrollTarget); if (disableScrollTarget) {disableScrollTarget = angular.element(disableScrollTarget);}else {$log.warn( $mdUtil.supplant("mdSidenav: couldn't find element matching " + 'selector "{selector}". Falling back to parent.', {selector: attr.mdDisableScrollTarget, }), );}}if (!disableScrollTarget) {disableScrollTarget = element.parent();}if (!attr.hasOwnProperty('mdDisableBackdrop')) {backdrop = $mdUtil.createBackdrop(scope, 'md-sidenav-backdrop md-opaque ng-enter');}element.addClass('_md'); $mdTheming(element); if (backdrop) $mdTheming.inherit(backdrop, element); element.on('$destroy', function () {backdrop && backdrop.remove(); sidenavCtrl.destroy();}); scope.$on('$destroy', function () {backdrop && backdrop.remove();}); scope.$watch(isLocked, updateIsLocked); scope.$watch('isOpen', updateIsOpen); sidenavCtrl.$toggleOpen = toggleOpen; function updateIsLocked(isLocked, oldValue) {scope.isLockedOpen = isLocked; if (isLocked === oldValue) {element.toggleClass('md-locked-open', !!isLocked);}else {$animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');}if (backdrop) {backdrop.toggleClass('md-locked-open', !!isLocked);}}function updateIsOpen(isOpen) {var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, '[md-sidenav-focus]') || element; var parent = element.parent(); parent[isOpen ? 'on' : 'off']('keydown', onKeyDown); if (backdrop) backdrop[isOpen ? 'on' : 'off']('click', close); var restorePositioning = updateContainerPositions(parent, isOpen); if (isOpen) {triggeringElement = $document[0].activeElement; triggeringInteractionType = $mdInteraction.getLastInteractionType();}disableParentScroll(isOpen); return (promise = $q .all([ isOpen && backdrop ? $animate.enter(backdrop, parent) : backdrop ? $animate.leave(backdrop) : $q.when(true), $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed'), ]) .then(function () {if (scope.isOpen) {$$rAF(function () {ngWindow.triggerHandler('resize');}); focusEl && focusEl.focus();}restorePositioning && restorePositioning();}));}function updateContainerPositions(parent, willOpen) {var drawerEl = element[0]; var scrollTop = parent[0].scrollTop; if (willOpen && scrollTop) {previousContainerStyles = {top: drawerEl.style.top, bottom: drawerEl.style.bottom, height: drawerEl.style.height, }; var positionStyle = {top: scrollTop + 'px', bottom: 'auto', height: parent[0].clientHeight + 'px', }; element.css(positionStyle); backdrop.css(positionStyle);}if (!willOpen && previousContainerStyles) {return function () {drawerEl.style.top = previousContainerStyles.top; drawerEl.style.bottom = previousContainerStyles.bottom; drawerEl.style.height = previousContainerStyles.height; backdrop[0].style.top = null; backdrop[0].style.bottom = null; backdrop[0].style.height = null; previousContainerStyles = null;};}}function disableParentScroll(disabled) {if (disabled && !lastParentOverFlow) {lastParentOverFlow = disableScrollTarget.css('overflow'); disableScrollTarget.css('overflow', 'hidden');}else if (angular.isDefined(lastParentOverFlow)) {disableScrollTarget.css('overflow', lastParentOverFlow); lastParentOverFlow = undefined;}}function toggleOpen(isOpen) {if (scope.isOpen == isOpen) {return $q.when(true);}else {if (scope.isOpen && sidenavCtrl.onCloseCb) sidenavCtrl.onCloseCb(); return $q(function (resolve) {scope.isOpen = isOpen; $mdUtil.nextTick(function () {promise.then(function (result) {if (!scope.isOpen && triggeringElement && triggeringInteractionType === 'keyboard') {triggeringElement.focus(); triggeringElement = null;}resolve(result);});});});}}function onKeyDown(ev) {var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE; return isEscape ? close(ev) : $q.when(true);}function close(ev) {ev.preventDefault(); return sidenavCtrl.close();}}}function SidenavController($scope, $attrs, $mdComponentRegistry, $q, $interpolate) {var self = this; self.isOpen = function () {return !!$scope.isOpen;}; self.isLockedOpen = function () {return !!$scope.isLockedOpen;}; self.onClose = function (callback) {self.onCloseCb = callback; return self;}; self.open = function () {return self.$toggleOpen(true);}; self.close = function () {return self.$toggleOpen(false);}; self.toggle = function () {return self.$toggleOpen(!$scope.isOpen);}; self.$toggleOpen = function (value) {return $q.when(($scope.isOpen = value));}; var rawId = $attrs.mdComponentId; var hasDataBinding = rawId && rawId.indexOf($interpolate.startSymbol()) > -1; var componentId = hasDataBinding ? $interpolate(rawId)($scope.$parent) : rawId; self.destroy = $mdComponentRegistry.register(self, componentId); if (hasDataBinding) {$attrs.$observe('mdComponentId', function (id) {if (id && id !== self.$$mdHandle) {self.destroy(); self.destroy = $mdComponentRegistry.register(self, id);}});}}})(); (function () {'use strict'; SliderDirective.$inject = ['$$rAF', '$window', '$mdAria', '$mdUtil', '$mdConstant', '$mdTheming', '$mdGesture', '$parse', '$log', '$timeout']; angular .module('material.components.slider', ['material.core']) .directive('mdSlider', SliderDirective) .directive('mdSliderContainer', SliderContainerDirective); function SliderContainerDirective() {return {controller: function () {}, compile: function (elem) {var slider = elem.find('md-slider'); if (!slider) {return;}var vertical = slider.attr('md-vertical'); if (vertical !== undefined) {elem.attr('md-vertical', '');}if (!slider.attr('flex')) {slider.attr('flex', '');}return function postLink(scope, element, attr, ctrl) {element.addClass('_md'); function setDisable(value) {element.children().attr('disabled', value); element.find('input').attr('disabled', value);}var stopDisabledWatch = angular.noop; if (attr.disabled) {setDisable(true);}else if (attr.ngDisabled) {stopDisabledWatch = scope.$watch(attr.ngDisabled, function (value) {setDisable(value);});}scope.$on('$destroy', function () {stopDisabledWatch();}); var initialMaxWidth; ctrl.fitInputWidthToTextLength = function (length) {var input = element[0].querySelector('md-input-container'); if (input) {var computedStyle = getComputedStyle(input); var minWidth = parseInt(computedStyle.minWidth); var padding = parseInt(computedStyle.padding) * 2; initialMaxWidth = initialMaxWidth || parseInt(computedStyle.maxWidth); var newMaxWidth = Math.max(initialMaxWidth, minWidth + padding + (minWidth / 2) * length); input.style.maxWidth = newMaxWidth + 'px';}};};}, };}function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log, $timeout) {return {scope: {}, require: ['?ngModel', '?^mdSliderContainer'], template: '<div class="md-slider-wrapper">' + '<div class="md-slider-content">' + '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + '</div>' + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + '</div>' + '<div class="md-disabled-thumb"></div>' + '</div>' + '</div>' + '</div>', compile: compile, }; function compile(tElement, tAttrs) {var wrapper = angular.element(tElement[0].getElementsByClassName('md-slider-wrapper')); var tabIndex = tAttrs.tabindex || 0; wrapper.attr('tabindex', tabIndex); if (tAttrs.disabled || tAttrs.ngDisabled) wrapper.attr('tabindex', -1); wrapper.attr('role', 'slider'); $mdAria.expect(tElement, 'aria-label'); return postLink;}function postLink(scope, element, attr, ctrls) {$mdTheming(element); var ngModelCtrl = ctrls[0] || {$setViewValue: function (val) {this.$viewValue = val; this.$viewChangeListeners.forEach(function (cb) {cb();});}, $parsers: [], $formatters: [], $viewChangeListeners: [], }; var containerCtrl = ctrls[1]; var container = angular.element($mdUtil.getClosest(element, '_md-slider-container', true)); var isDisabled = attr.ngDisabled ? angular.bind(null, $parse(attr.ngDisabled), scope.$parent) : function () {return element[0].hasAttribute('disabled');}; var thumb = angular.element(element[0].querySelector('.md-thumb')); var thumbText = angular.element(element[0].querySelector('.md-thumb-text')); var thumbContainer = thumb.parent(); var trackContainer = angular.element(element[0].querySelector('.md-track-container')); var activeTrack = angular.element(element[0].querySelector('.md-track-fill')); var tickContainer = angular.element(element[0].querySelector('.md-track-ticks')); var wrapper = angular.element(element[0].getElementsByClassName('md-slider-wrapper')); var content = angular.element(element[0].getElementsByClassName('md-slider-content')); var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000); var DEFAULT_ROUND = 3; var vertical = angular.isDefined(attr.mdVertical); var discrete = angular.isDefined(attr.mdDiscrete); var invert = angular.isDefined(attr.mdInvert); angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0); angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100); angular.isDefined(attr.step) ? attr.$observe('step', updateStep) : updateStep(1); angular.isDefined(attr.round) ? attr.$observe('round', updateRound) : updateRound(DEFAULT_ROUND); var stopDisabledWatch = angular.noop; if (attr.ngDisabled) {stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);}$mdGesture.register(wrapper, 'drag', {horizontal: !vertical }); scope.mouseActive = false; wrapper .on('keydown', keydownListener) .on('mousedown', mouseDownListener) .on('focus', focusListener) .on('blur', blurListener) .on('$md.pressdown', onPressDown) .on('$md.pressup', onPressUp) .on('$md.dragstart', onDragStart) .on('$md.drag', onDrag) .on('$md.dragend', onDragEnd); function updateAll() {refreshSliderDimensions(); ngModelRender();}setTimeout(updateAll, 0); var debouncedUpdateAll = $$rAF.throttle(updateAll); angular.element($window).on('resize', debouncedUpdateAll); scope.$on('$destroy', function () {angular.element($window).off('resize', debouncedUpdateAll);}); ngModelCtrl.$render = ngModelRender; ngModelCtrl.$viewChangeListeners.push(ngModelRender); ngModelCtrl.$formatters.push(minMaxValidator); ngModelCtrl.$formatters.push(stepValidator); var min; var max; var step; var round; function updateMin(value) {min = parseFloat(value); element.attr('aria-valuemin', value); updateAll();}function updateMax(value) {max = parseFloat(value); element.attr('aria-valuemax', value); updateAll();}function updateStep(value) {step = parseFloat(value);}function updateRound(value) {round = minMaxValidator(parseInt(value), 0, 6);}function updateAriaDisabled() {element.attr('aria-disabled', !!isDisabled());}var tickCanvas, tickCtx; function redrawTicks() {if (!discrete || isDisabled()) return; if (angular.isUndefined(step)) return; if (step <= 0) {var msg = 'Slider step value must be greater than zero when in discrete mode'; $log.error(msg); throw new Error(msg);}var numSteps = Math.floor((max - min) / step); if (!tickCanvas) {tickCanvas = angular.element('<canvas>').css('position', 'absolute'); tickContainer.append(tickCanvas); tickCtx = tickCanvas[0].getContext('2d');}var dimensions = getSliderDimensions(); if (dimensions && !dimensions.height && !dimensions.width) {refreshSliderDimensions(); dimensions = sliderDimensions;}tickCanvas[0].width = dimensions.width; tickCanvas[0].height = dimensions.height; var distance; for (var i = 0; i <= numSteps; i++) {var trackTicksStyle = $window.getComputedStyle(tickContainer[0]); tickCtx.fillStyle = trackTicksStyle.color || 'black'; distance = Math.floor((vertical ? dimensions.height : dimensions.width) * (i / numSteps)); tickCtx.fillRect(vertical ? 0 : distance - 1, vertical ? distance - 1 : 0, vertical ? dimensions.width : 2, vertical ? 2 : dimensions.height);}}function clearTicks() {if (tickCanvas && tickCtx) {var dimensions = getSliderDimensions(); tickCtx.clearRect(0, 0, dimensions.width, dimensions.height);}}var sliderDimensions = {}; refreshSliderDimensions(); function refreshSliderDimensions() {sliderDimensions = trackContainer[0].getBoundingClientRect();}function getSliderDimensions() {throttledRefreshDimensions(); return sliderDimensions;}function keydownListener(ev) {if (isDisabled()) return; var changeAmount; if (vertical ? ev.keyCode === $mdConstant.KEY_CODE.DOWN_ARROW : ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {changeAmount = -step;}else if (vertical ? ev.keyCode === $mdConstant.KEY_CODE.UP_ARROW : ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {changeAmount = step;}changeAmount = invert ? -changeAmount : changeAmount; if (changeAmount) {if (ev.metaKey || ev.ctrlKey || ev.altKey) {changeAmount *= 4;}ev.preventDefault(); ev.stopPropagation(); scope.$evalAsync(function () {setModelValue(ngModelCtrl.$viewValue + changeAmount);});}}function mouseDownListener() {redrawTicks(); scope.mouseActive = true; wrapper.removeClass('md-focused'); $timeout(function () {scope.mouseActive = false;}, 100);}function focusListener() {if (scope.mouseActive === false) {wrapper.addClass('md-focused');}}function blurListener() {wrapper.removeClass('md-focused'); element.removeClass('md-active'); clearTicks();}function setModelValue(value) {ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));}function ngModelRender() {if (isNaN(ngModelCtrl.$viewValue)) {ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;}ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$viewValue); var percent = valueToPercent(ngModelCtrl.$viewValue); scope.modelValue = ngModelCtrl.$viewValue; element.attr('aria-valuenow', ngModelCtrl.$viewValue); setSliderPercent(percent); thumbText.text(ngModelCtrl.$viewValue);}function minMaxValidator(value, minValue, maxValue) {if (angular.isNumber(value)) {minValue = angular.isNumber(minValue) ? minValue : min; maxValue = angular.isNumber(maxValue) ? maxValue : max; return Math.max(minValue, Math.min(maxValue, value));}}function stepValidator(value) {if (angular.isNumber(value)) {var formattedValue = Math.round((value - min) / step) * step + min; formattedValue = Math.round(formattedValue * Math.pow(10, round)) / Math.pow(10, round); if (containerCtrl && containerCtrl.fitInputWidthToTextLength) {$mdUtil.debounce(function () {containerCtrl.fitInputWidthToTextLength(formattedValue.toString().length);}, 100)();}return formattedValue;}}function setSliderPercent(percent) {percent = clamp(percent); var thumbPosition = percent * 100 + '%'; var activeTrackPercent = invert ? (1 - percent) * 100 + '%' : thumbPosition; if (vertical) {thumbContainer.css('bottom', thumbPosition);}else {$mdUtil.bidiProperty(thumbContainer, 'left', 'right', thumbPosition);}activeTrack.css(vertical ? 'height' : 'width', activeTrackPercent); element.toggleClass(invert ? 'md-max' : 'md-min', percent === 0); element.toggleClass(invert ? 'md-min' : 'md-max', percent === 1);}var isDragging = false; function onPressDown(ev) {if (isDisabled()) return; element.addClass('md-active'); element[0].focus(); refreshSliderDimensions(); var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x)); var closestVal = minMaxValidator(stepValidator(exactVal)); scope.$apply(function () {setModelValue(closestVal); setSliderPercent(valueToPercent(closestVal));});}function onPressUp(ev) {if (isDisabled()) return; element.removeClass('md-dragging'); var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x)); var closestVal = minMaxValidator(stepValidator(exactVal)); scope.$apply(function () {setModelValue(closestVal); ngModelRender();});}function onDragStart(ev) {if (isDisabled()) return; isDragging = true; ev.stopPropagation(); element.addClass('md-dragging'); setSliderFromEvent(ev);}function onDrag(ev) {if (!isDragging) return; ev.stopPropagation(); setSliderFromEvent(ev);}function onDragEnd(ev) {if (!isDragging) return; ev.stopPropagation(); isDragging = false;}function setSliderFromEvent(ev) {if (discrete) adjustThumbPosition(vertical ? ev.pointer.y : ev.pointer.x); else doSlide(vertical ? ev.pointer.y : ev.pointer.x);}function doSlide(x) {scope.$evalAsync(function () {setModelValue(percentToValue(positionToPercent(x)));});}function adjustThumbPosition(x) {var exactVal = percentToValue(positionToPercent(x)); var closestVal = minMaxValidator(stepValidator(exactVal)); setSliderPercent(positionToPercent(x)); thumbText.text(closestVal);}function clamp(value) {return Math.max(0, Math.min(value || 0, 1));}function positionToPercent(position) {var offset = vertical ? sliderDimensions.top : sliderDimensions.left; var size = vertical ? sliderDimensions.height : sliderDimensions.width; var calc = (position - offset) / size; if (!vertical && $mdUtil.bidi() === 'rtl') {calc = 1 - calc;}return Math.max(0, Math.min(1, vertical ? 1 - calc : calc));}function percentToValue(percent) {var adjustedPercent = invert ? 1 - percent : percent; return min + adjustedPercent * (max - min);}function valueToPercent(val) {var percent = (val - min) / (max - min); return invert ? 1 - percent : percent;}}}})(); (function () {'use strict'; MdSticky.$inject = ['$mdConstant', '$$rAF', '$mdUtil', '$compile']; angular.module('material.components.sticky', ['material.core', 'material.components.content']).factory('$mdSticky', MdSticky); function MdSticky($mdConstant, $$rAF, $mdUtil, $compile) {var browserStickySupport = $mdUtil.checkStickySupport(); return function registerStickyElement(scope, element, stickyClone) {var contentCtrl = element.controller('mdContent'); if (!contentCtrl) return; if (browserStickySupport) {element.css({position: browserStickySupport, top: 0, 'z-index': 2, });}else {var $$sticky = contentCtrl.$element.data('$$sticky'); if (!$$sticky) {$$sticky = setupSticky(contentCtrl); contentCtrl.$element.data('$$sticky', $$sticky);}var cloneElement = stickyClone || $compile(element.clone())(scope); var deregister = $$sticky.add(element, cloneElement); scope.$on('$destroy', deregister);}}; function setupSticky(contentCtrl) {var contentEl = contentCtrl.$element; var debouncedRefreshElements = $$rAF.throttle(refreshElements); setupAugmentedScrollEvents(contentEl); contentEl.on('$scrollstart', debouncedRefreshElements); contentEl.on('$scroll', onScroll); var self; return (self = {prev: null, current: null, next: null, items: [], add: add, refreshElements: refreshElements, }); function add(element, stickyClone) {stickyClone.addClass('md-sticky-clone'); var item = {element: element, clone: stickyClone, }; self.items.push(item); $mdUtil.nextTick(function () {contentEl.prepend(item.clone);}); debouncedRefreshElements(); return function remove() {self.items.forEach(function (item, index) {if (item.element[0] === element[0]) {self.items.splice(index, 1); item.clone.remove();}}); debouncedRefreshElements();};}function refreshElements() {self.items.forEach(refreshPosition); self.items = self.items.sort(function (a, b) {return a.top < b.top ? -1 : 1;}); var item; var currentScrollTop = contentEl.prop('scrollTop'); for (var i = self.items.length - 1; i >= 0; i--) {if (currentScrollTop > self.items[i].top) {item = self.items[i]; break;}}setCurrentItem(item);}function refreshPosition(item) {var current = item.element[0]; item.top = 0; item.left = 0; item.right = 0; while (current && current !== contentEl[0]) {item.top += current.offsetTop; item.left += current.offsetLeft; if (current.offsetParent) {item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft;}current = current.offsetParent;}item.height = item.element.prop('offsetHeight'); var defaultVal = $mdUtil.floatingScrollbars() ? '0' : undefined; $mdUtil.bidi(item.clone, 'margin-left', item.left, defaultVal); $mdUtil.bidi(item.clone, 'margin-right', defaultVal, item.right);}function onScroll() {var scrollTop = contentEl.prop('scrollTop'); var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0); onScroll.prevScrollTop = scrollTop; if (scrollTop === 0) {setCurrentItem(null); return;}if (isScrollingDown) {if (self.next && self.next.top <= scrollTop) {setCurrentItem(self.next); return;}if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop)); return;}}if (!isScrollingDown) {if (self.current && self.prev && scrollTop < self.current.top) {setCurrentItem(self.prev); return;}if (self.next && self.current && scrollTop >= self.next.top - self.current.height) {translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height)); return;}}if (self.current) {translate(self.current, scrollTop);}}function setCurrentItem(item) {if (self.current === item) return; if (self.current) {translate(self.current, null); setStickyState(self.current, null);}if (item) {setStickyState(item, 'active');}self.current = item; var index = self.items.indexOf(item); self.next = self.items[index + 1]; self.prev = self.items[index - 1]; setStickyState(self.next, 'next'); setStickyState(self.prev, 'prev');}function setStickyState(item, state) {if (!item || item.state === state) return; if (item.state) {item.clone.attr('sticky-prev-state', item.state); item.element.attr('sticky-prev-state', item.state);}item.clone.attr('sticky-state', state); item.element.attr('sticky-state', state); item.state = state;}function translate(item, amount) {if (!item) return; if (amount === null || amount === undefined) {if (item.translateY) {item.translateY = null; item.clone.css($mdConstant.CSS.TRANSFORM, '');}}else {item.translateY = amount; $mdUtil.bidi(item.clone, $mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)', 'translateY(' + amount + 'px)');}}}function setupAugmentedScrollEvents(element) {var SCROLL_END_DELAY = 200; var isScrolling; var lastScrollTime; element.on('scroll touchmove', function () {if (!isScrolling) {isScrolling = true; $$rAF.throttle(loopScrollEvent); element.triggerHandler('$scrollstart');}element.triggerHandler('$scroll'); lastScrollTime = +$mdUtil.now();}); function loopScrollEvent() {if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {isScrolling = false; element.triggerHandler('$scrollend');}else {element.triggerHandler('$scroll'); $$rAF.throttle(loopScrollEvent);}}}}})(); (function () {'use strict'; MdSubheaderDirective.$inject = ['$mdSticky', '$compile', '$mdTheming', '$mdUtil', '$mdAria']; angular.module('material.components.subheader', ['material.core', 'material.components.sticky']).directive('mdSubheader', MdSubheaderDirective); function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil, $mdAria) {return {restrict: 'E', replace: true, transclude: true, template: '<div class="md-subheader _md">' + ' <div class="md-subheader-inner">' + ' <div class="md-subheader-content"></div>' + ' </div>' + '</div>', link: function postLink(scope, element, attr, controllers, transclude) {$mdTheming(element); element.addClass('_md'); $mdUtil.prefixer().removeAttribute(element, 'ng-repeat'); var outerHTML = element[0].outerHTML; function getContent(el) {return angular.element(el[0].querySelector('.md-subheader-content'));}attr.$set('role', 'heading'); $mdAria.expect(element, 'aria-level', '2'); transclude(scope, function (clone) {getContent(element).append(clone);}); if (!element.hasClass('md-no-sticky')) {transclude(scope, function (clone) {var wrapper = $compile('<div class="md-subheader-wrapper" aria-hidden="true">' + outerHTML + '</div>')(scope); $mdUtil.nextTick(function () {getContent(wrapper).append(clone);}); $mdSticky(scope, element, wrapper);});}}, };}})(); (function () {'use strict'; angular .module('material.components.swipe', ['material.core']) .directive('mdSwipeLeft', getDirective('SwipeLeft')) .directive('mdSwipeRight', getDirective('SwipeRight')) .directive('mdSwipeUp', getDirective('SwipeUp')) .directive('mdSwipeDown', getDirective('SwipeDown')); function getDirective(name) {DirectiveFactory.$inject = ['$parse']; var directiveName = 'md' + name; var eventName = '$md.' + name.toLowerCase(); return DirectiveFactory; function DirectiveFactory($parse) {return {restrict: 'A', link: postLink }; function postLink(scope, element, attr) {var fn = $parse(attr[directiveName]); element.on(eventName, function (ev) {scope.$applyAsync(function () {fn(scope, {$event: ev });});});}}}})(); (function () {'use strict'; MdSwitch.$inject = ['mdCheckboxDirective', '$mdUtil', '$mdConstant', '$parse', '$$rAF', '$mdGesture', '$timeout']; angular.module('material.components.switch', ['material.core', 'material.components.checkbox']).directive('mdSwitch', MdSwitch); function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture, $timeout) {var checkboxDirective = mdCheckboxDirective[0]; return {restrict: 'E', priority: $mdConstant.BEFORE_NG_ARIA, transclude: true, template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + '</div>' + '</div>' + '<div ng-transclude class="md-label"></div>', require: ['^?mdInputContainer', '?ngModel', '?^form'], compile: mdSwitchCompile, }; function mdSwitchCompile(element, attr) {var checkboxLink = checkboxDirective.compile(element, attr).post; element.addClass('md-dragging'); return function (scope, element, attr, ctrls) {var containerCtrl = ctrls[0]; var ngModel = ctrls[1] || $mdUtil.fakeNgModel(); var formCtrl = ctrls[2]; var disabledGetter = null; if (attr.disabled != null) {disabledGetter = function () {return true;};}else if (attr.ngDisabled) {disabledGetter = $parse(attr.ngDisabled);}var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container')); var switchContainer = angular.element(element[0].querySelector('.md-container')); var labelContainer = angular.element(element[0].querySelector('.md-label')); $$rAF(function () {element.removeClass('md-dragging');}); checkboxLink(scope, element, attr, ctrls); if (disabledGetter) {scope.$watch(disabledGetter, function (isDisabled) {element.attr('tabindex', isDisabled ? -1 : 0);});}attr.$observe('mdInvert', function (newValue) {var isInverted = $mdUtil.parseAttributeBoolean(newValue); isInverted ? element.prepend(labelContainer) : element.prepend(switchContainer); element.toggleClass('md-inverted', isInverted);}); $mdGesture.register(switchContainer, 'drag'); switchContainer.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd); var drag; function onDragStart(ev) {if (disabledGetter && disabledGetter(scope)) return; ev.stopPropagation(); element.addClass('md-dragging'); drag = {width: thumbContainer.prop('offsetWidth') };}function onDrag(ev) {if (!drag) return; ev.stopPropagation(); ev.srcEvent && ev.srcEvent.preventDefault(); var percent = ev.pointer.distanceX / drag.width; var translate = ngModel.$viewValue ? 1 + percent : percent; translate = Math.max(0, Math.min(1, translate)); thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + 100 * translate + '%,0,0)'); drag.translate = translate;}function onDragEnd(ev) {if (!drag) return; ev.stopPropagation(); element.removeClass('md-dragging'); thumbContainer.css($mdConstant.CSS.TRANSFORM, ''); var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5; if (isChanged) {applyModelValue(!ngModel.$viewValue);}drag = null; scope.skipToggle = true; $timeout(function () {scope.skipToggle = false;}, 1);}function applyModelValue(newValue) {scope.$apply(function () {ngModel.$setViewValue(newValue); ngModel.$render();});}};}}})(); (function () {'use strict'; angular.module('material.components.tabs', ['material.core', 'material.components.icon']);})(); (function () {'use strict'; angular.module('material.components.tabs').service('MdTabsPaginationService', MdTabsPaginationService); function MdTabsPaginationService() {return {decreasePageOffset: decreasePageOffset, increasePageOffset: increasePageOffset, getTabOffsets: getTabOffsets, getTotalTabsWidth: getTotalTabsWidth, }; function decreasePageOffset(elements, currentOffset) {var canvas = elements.canvas, tabOffsets = getTabOffsets(elements), i, firstVisibleTabOffset; for (i = 0; i < tabOffsets.length; i++) {if (tabOffsets[i] >= currentOffset) {firstVisibleTabOffset = tabOffsets[i]; break;}}return Math.max(0, firstVisibleTabOffset - canvas.clientWidth);}function increasePageOffset(elements, currentOffset) {var canvas = elements.canvas, maxOffset = getTotalTabsWidth(elements) - canvas.clientWidth, tabOffsets = getTabOffsets(elements), i, firstHiddenTabOffset; for (i = 0; i < tabOffsets.length, tabOffsets[i] <= currentOffset + canvas.clientWidth; i++) {firstHiddenTabOffset = tabOffsets[i];}return Math.min(maxOffset, firstHiddenTabOffset);}function getTabOffsets(elements) {var i, tab, currentOffset = 0, offsets = []; for (i = 0; i < elements.tabs.length; i++) {tab = elements.tabs[i]; offsets.push(currentOffset); currentOffset += tab.offsetWidth;}return offsets;}function getTotalTabsWidth(elements) {var sum = 0, i, tab; for (i = 0; i < elements.tabs.length; i++) {tab = elements.tabs[i]; sum += tab.offsetWidth;}return sum;}}})(); (function () {'use strict'; MdToastDirective.$inject = ['$mdToast']; MdToastProvider.$inject = ['$$interimElementProvider']; angular .module('material.components.toast', ['material.core', 'material.components.button']) .directive('mdToast', MdToastDirective) .provider('$mdToast', MdToastProvider); function MdToastDirective($mdToast) {return {restrict: 'E', link: function postLink(scope, element) {element.addClass('_md'); scope.$on('$destroy', function () {$mdToast.destroy();});}, };}function MdToastProvider($$interimElementProvider) {MdToastController.$inject = ['$mdToast', '$scope']; toastDefaultOptions.$inject = ['$animate', '$mdToast', '$mdUtil', '$mdMedia']; var ACTION_RESOLVE = 'ok'; var activeToastContent; var $mdToast = $$interimElementProvider('$mdToast') .setDefaults({methods: ['position', 'hideDelay', 'capsule', 'parent', 'position', 'toastClass'], options: toastDefaultOptions, }) .addPreset('simple', {argOption: 'textContent', methods: ['textContent', 'content', 'action', 'highlightAction', 'highlightClass', 'theme', 'parent'], options: [ '$mdToast', '$mdTheming', function ($mdToast, $mdTheming) {return {template: '<md-toast md-theme="{{toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' + ' <div class="md-toast-content">' + ' <span class="md-toast-text" role="alert" aria-relevant="all" aria-atomic="true">' + ' {{toast.content }}' + ' </span>' + ' <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ' + ' ng-class="highlightClasses">' + ' {{toast.action }}' + ' </md-button>' + ' </div>' + '</md-toast>', controller: MdToastController, theme: $mdTheming.defaultTheme(), controllerAs: 'toast', bindToController: true, };}, ], }) .addMethod('updateTextContent', updateTextContent) .addMethod('updateContent', updateTextContent); function updateTextContent(newContent) {activeToastContent = newContent;}return $mdToast; function MdToastController($mdToast, $scope) {this.$onInit = function () {var self = this; if (self.highlightAction) {$scope.highlightClasses = ['md-highlight', self.highlightClass];}$scope.$watch( function () {return activeToastContent;}, function () {self.content = activeToastContent;}, ); this.resolve = function () {$mdToast.hide(ACTION_RESOLVE);};};}function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown'; return {onShow: onShow, onRemove: onRemove, toastClass: '', position: 'bottom left', themable: true, hideDelay: 3000, autoWrap: true, transformTemplate: function (template, options) {var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template); if (shouldAddWrapper) {var templateRoot = document.createElement('md-template'); templateRoot.innerHTML = template; for (var i = 0; i < templateRoot.children.length; i++) {if (templateRoot.children[i].nodeName === 'MD-TOAST') {var wrapper = angular.element('<div class="md-toast-content">'); wrapper.append(angular.element(templateRoot.children[i].childNodes)); templateRoot.children[i].appendChild(wrapper[0]);}}return templateRoot.innerHTML;}return template || '';}, }; function onShow(scope, element, options) {activeToastContent = options.textContent || options.content; var isSmScreen = !$mdMedia('gt-sm'); element = $mdUtil.extractElementByName(element, 'md-toast', true); options.element = element; options.onSwipe = function (ev, gesture) {var swipe = ev.type.replace('$md.', ''); var direction = swipe.replace('swipe', ''); if ( (direction === 'down' && options.position.indexOf('top') != -1 && !isSmScreen) || (direction === 'up' && (options.position.indexOf('bottom') != -1 || isSmScreen)) ) {return;}if ((direction === 'left' || direction === 'right') && isSmScreen) {return;}element.addClass('md-' + swipe); $mdUtil.nextTick($mdToast.cancel);}; options.openClass = toastOpenClass(options.position); element.addClass(options.toastClass); options.parent.addClass(options.openClass); if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {options.parent.css('position', 'relative');}element.on(SWIPE_EVENTS, options.onSwipe); element.addClass( isSmScreen ? 'md-bottom' : options.position .split(' ') .map(function (pos) {return 'md-' + pos;}) .join(' '), ); if (options.parent) options.parent.addClass('md-toast-animating'); return $animate.enter(element, options.parent).then(function () {if (options.parent) options.parent.removeClass('md-toast-animating');});}function onRemove(scope, element, options) {element.off(SWIPE_EVENTS, options.onSwipe); if (options.parent) options.parent.addClass('md-toast-animating'); if (options.openClass) options.parent.removeClass(options.openClass); return (options.$destroy == true ? element.remove() : $animate.leave(element)).then(function () {if (options.parent) options.parent.removeClass('md-toast-animating'); if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {options.parent.css('position', '');}});}function toastOpenClass(position) {if (!$mdMedia('gt-xs')) {return 'md-toast-open-bottom';}return 'md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');}}}})(); (function () {'use strict'; mdToolbarDirective.$inject = ['$$rAF', '$mdConstant', '$mdUtil', '$mdTheming', '$animate']; angular.module('material.components.toolbar', ['material.core', 'material.components.content']).directive('mdToolbar', mdToolbarDirective); function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)'); return {template: '', restrict: 'E', link: function (scope, element, attr) {element.addClass('_md'); $mdTheming(element); $mdUtil.nextTick(function () {element.addClass('_md-toolbar-transitions');}, false); if (angular.isDefined(attr.mdScrollShrink)) {setupScrollShrink();}function setupScrollShrink() {var toolbarHeight; var contentElement; var disableScrollShrink = angular.noop; var y = 0; var prevScrollTop = 0; var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5; var debouncedContentScroll = $$rAF.throttle(onContentScroll); var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000); scope.$on('$mdContentLoaded', onMdContentLoad); attr.$observe('mdScrollShrink', onChangeScrollShrink); if (attr.ngShow) {scope.$watch(attr.ngShow, updateToolbarHeight);}if (attr.ngHide) {scope.$watch(attr.ngHide, updateToolbarHeight);}scope.$on('$destroy', disableScrollShrink); function onChangeScrollShrink(shrinkWithScroll) {var closestContent = element.parent().find('md-content'); if (!contentElement && closestContent.length) {onMdContentLoad(null, closestContent);}shrinkWithScroll = scope.$eval(shrinkWithScroll); if (shrinkWithScroll === false) {disableScrollShrink();}else {disableScrollShrink = enableScrollShrink();}}function onMdContentLoad($event, newContentEl) {if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {if (contentElement) {contentElement.off('scroll', debouncedContentScroll);}contentElement = newContentEl; disableScrollShrink = enableScrollShrink();}}function onContentScroll(e) {var scrollTop = e ? e.target.scrollTop : prevScrollTop; debouncedUpdateHeight(); y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop)); element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor])); contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor])); prevScrollTop = scrollTop; $mdUtil.nextTick(function () {var hasWhiteFrame = element.hasClass('md-whiteframe-z1'); if (hasWhiteFrame && !y) {$animate.removeClass(element, 'md-whiteframe-z1');}else if (!hasWhiteFrame && y) {$animate.addClass(element, 'md-whiteframe-z1');}});}function enableScrollShrink() {if (!contentElement) return angular.noop; contentElement.on('scroll', debouncedContentScroll); contentElement.attr('scroll-shrink', 'true'); $mdUtil.nextTick(updateToolbarHeight, false); return function disableScrollShrink() {contentElement.off('scroll', debouncedContentScroll); contentElement.attr('scroll-shrink', 'false'); updateToolbarHeight();};}function updateToolbarHeight() {toolbarHeight = element.prop('offsetHeight'); var margin = -toolbarHeight * shrinkSpeedFactor + 'px'; contentElement.css({'margin-top': margin, 'margin-bottom': margin, }); onContentScroll();}}}, };}})(); (function () {'use strict'; MdTooltipDirective.$inject = ['$timeout', '$window', '$$rAF', '$document', '$interpolate', '$mdUtil', '$mdPanel', '$$mdTooltipRegistry']; angular .module('material.components.tooltip', ['material.core', 'material.components.panel']) .directive('mdTooltip', MdTooltipDirective) .service('$$mdTooltipRegistry', MdTooltipRegistry); function MdTooltipDirective($timeout, $window, $$rAF, $document, $interpolate, $mdUtil, $mdPanel, $$mdTooltipRegistry) {var ENTER_EVENTS = 'focus touchstart mouseenter'; var LEAVE_EVENTS = 'blur touchcancel mouseleave'; var TOOLTIP_DEFAULT_Z_INDEX = 100; var TOOLTIP_DEFAULT_SHOW_DELAY = 0; var TOOLTIP_DEFAULT_DIRECTION = 'bottom'; var TOOLTIP_DIRECTIONS = {top: {x: $mdPanel.xPosition.CENTER, y: $mdPanel.yPosition.ABOVE }, right: {x: $mdPanel.xPosition.OFFSET_END, y: $mdPanel.yPosition.CENTER }, bottom: {x: $mdPanel.xPosition.CENTER, y: $mdPanel.yPosition.BELOW }, left: {x: $mdPanel.xPosition.OFFSET_START, y: $mdPanel.yPosition.CENTER }, }; return {restrict: 'E', priority: 210, scope: {mdZIndex: '=?mdZIndex', mdDelay: '=?mdDelay', mdVisible: '=?mdVisible', mdAutohide: '=?mdAutohide', mdDirection: '@?mdDirection', }, link: linkFunc, }; function linkFunc(scope, element, attr) {var tooltipId = 'md-tooltip-' + $mdUtil.nextUid(); var parent = $mdUtil.getParentWithPointerEvents(element); var debouncedOnResize = $$rAF.throttle(updatePosition); var mouseActive = false; var origin, position, panelPosition, panelRef, autohide, showTimeout, elementFocusedOnWindowBlur = null; setDefaults(); addAriaLabel(); element.detach(); updatePosition(); bindEvents(); configureWatchers(); function setDefaults() {scope.mdZIndex = scope.mdZIndex || TOOLTIP_DEFAULT_Z_INDEX; scope.mdDelay = scope.mdDelay || TOOLTIP_DEFAULT_SHOW_DELAY; if (!TOOLTIP_DIRECTIONS[scope.mdDirection]) {scope.mdDirection = TOOLTIP_DEFAULT_DIRECTION;}}function addAriaLabel(labelText) {var interpolatedText = labelText || $interpolate(element.text().trim())(scope.$parent); if ((!parent.attr('aria-label') && !parent.attr('aria-labelledby')) || parent.attr('md-labeled-by-tooltip')) {parent.attr('aria-label', interpolatedText); if (!parent.attr('md-labeled-by-tooltip')) {parent.attr('md-labeled-by-tooltip', tooltipId);}}}function updatePosition() {setDefaults(); if (panelRef && panelRef.panelEl) {panelRef.panelEl.removeClass(origin);}origin = 'md-origin-' + scope.mdDirection; position = TOOLTIP_DIRECTIONS[scope.mdDirection]; panelPosition = $mdPanel.newPanelPosition().relativeTo(parent).addPanelPosition(position.x, position.y); if (panelRef && panelRef.panelEl) {panelRef.panelEl.addClass(origin); panelRef.updatePosition(panelPosition);}}function bindEvents() {if (parent[0] && 'MutationObserver' in $window) {var attributeObserver = new MutationObserver(function (mutations) {if (isDisabledMutation(mutations)) {$mdUtil.nextTick(function () {setVisible(false);});}}); attributeObserver.observe(parent[0], {attributes: true, });}elementFocusedOnWindowBlur = false; $$mdTooltipRegistry.register('scroll', windowScrollEventHandler, true); $$mdTooltipRegistry.register('blur', windowBlurEventHandler); $$mdTooltipRegistry.register('resize', debouncedOnResize); scope.$on('$destroy', onDestroy); parent.on('mousedown', mousedownEventHandler); parent.on(ENTER_EVENTS, enterEventHandler); function isDisabledMutation(mutations) {mutations.some(function (mutation) {return mutation.attributeName === 'disabled' && parent[0].disabled;}); return false;}function windowScrollEventHandler() {setVisible(false);}function windowBlurEventHandler() {elementFocusedOnWindowBlur = document.activeElement === parent[0];}function enterEventHandler($event) {if ($event.type === 'focus' && elementFocusedOnWindowBlur) {elementFocusedOnWindowBlur = false;}else if (!scope.mdVisible) {parent.on(LEAVE_EVENTS, leaveEventHandler); setVisible(true); if ($event.type === 'touchstart') {parent.one('touchend', function () {$mdUtil.nextTick(function () {$document.one('touchend', leaveEventHandler);}, false);});}}}function leaveEventHandler() {autohide = scope.hasOwnProperty('mdAutohide') ? scope.mdAutohide : attr.hasOwnProperty('mdAutohide'); if (autohide || mouseActive || $document[0].activeElement !== parent[0]) {if (showTimeout) {$timeout.cancel(showTimeout); setVisible.queued = false; showTimeout = null;}parent.off(LEAVE_EVENTS, leaveEventHandler); parent.triggerHandler('blur'); setVisible(false);}mouseActive = false;}function mousedownEventHandler() {mouseActive = true;}function onDestroy() {$$mdTooltipRegistry.deregister('scroll', windowScrollEventHandler, true); $$mdTooltipRegistry.deregister('blur', windowBlurEventHandler); $$mdTooltipRegistry.deregister('resize', debouncedOnResize); parent.off(ENTER_EVENTS, enterEventHandler).off(LEAVE_EVENTS, leaveEventHandler).off('mousedown', mousedownEventHandler); leaveEventHandler(); attributeObserver && attributeObserver.disconnect();}}function configureWatchers() {if (element[0] && 'MutationObserver' in $window) {var attributeObserver = new MutationObserver(function (mutations) {mutations.forEach(function (mutation) {if (mutation.attributeName === 'md-visible' && !scope.visibleWatcher) {scope.visibleWatcher = scope.$watch('mdVisible', onVisibleChanged);}});}); attributeObserver.observe(element[0], {attributes: true, }); if (attr.hasOwnProperty('mdVisible')) {scope.visibleWatcher = scope.$watch('mdVisible', onVisibleChanged);}}else {scope.visibleWatcher = scope.$watch('mdVisible', onVisibleChanged);}scope.$watch('mdDirection', updatePosition); element.one('$destroy', onElementDestroy); parent.one('$destroy', onElementDestroy); scope.$on('$destroy', function () {setVisible(false); panelRef && panelRef.destroy(); attributeObserver && attributeObserver.disconnect(); element.remove();}); if (element.text().indexOf($interpolate.startSymbol()) > -1) {scope.$watch(function () {return element.text().trim();}, addAriaLabel);}function onElementDestroy() {scope.$destroy();}}function setVisible(value) {if ((setVisible.queued && setVisible.value === !!value) || (!setVisible.queued && scope.mdVisible === !!value)) {return;}setVisible.value = !!value; if (!setVisible.queued) {if (value) {setVisible.queued = true; showTimeout = $timeout(function () {scope.mdVisible = setVisible.value; setVisible.queued = false; showTimeout = null; if (!scope.visibleWatcher) {onVisibleChanged(scope.mdVisible);}}, scope.mdDelay);}else {$mdUtil.nextTick(function () {scope.mdVisible = false; if (!scope.visibleWatcher) {onVisibleChanged(false);}});}}}function onVisibleChanged(isVisible) {isVisible ? showTooltip() : hideTooltip();}function showTooltip() {if (!element[0].textContent.trim()) {throw new Error('Text for the tooltip has not been provided. ' + 'Please include text within the mdTooltip element.');}if (!panelRef) {var attachTo = angular.element(document.body); var panelAnimation = $mdPanel.newPanelAnimation().openFrom(parent).closeTo(parent).withAnimation({open: 'md-show', close: 'md-hide', }); var panelConfig = {id: tooltipId, attachTo: attachTo, contentElement: element, propagateContainerEvents: true, panelClass: 'md-tooltip ' + origin, animation: panelAnimation, position: panelPosition, zIndex: scope.mdZIndex, focusOnOpen: false, }; panelRef = $mdPanel.create(panelConfig);}panelRef.open().then(function () {panelRef.panelEl.attr('role', 'tooltip');});}function hideTooltip() {panelRef && panelRef.close();}}}function MdTooltipRegistry() {var listeners = {}; var ngWindow = angular.element(window); return {register: register, deregister: deregister, }; function globalEventHandler(event) {if (listeners[event.type]) {listeners[event.type].forEach(function (currentHandler) {currentHandler.call(this, event);}, this);}}function register(type, handler, useCapture) {var handlers = (listeners[type] = listeners[type] || []); if (!handlers.length) {useCapture ? window.addEventListener(type, globalEventHandler, true) : ngWindow.on(type, globalEventHandler);}if (handlers.indexOf(handler) === -1) {handlers.push(handler);}}function deregister(type, handler, useCapture) {var handlers = listeners[type]; var index = handlers ? handlers.indexOf(handler) : -1; if (index > -1) {handlers.splice(index, 1); if (handlers.length === 0) {useCapture ? window.removeEventListener(type, globalEventHandler, true) : ngWindow.off(type, globalEventHandler);}}}}})(); (function () {'use strict'; MdTruncateController.$inject = ['$element']; angular.module('material.components.truncate', ['material.core']).directive('mdTruncate', MdTruncateDirective); function MdTruncateDirective() {return {restrict: 'AE', controller: MdTruncateController, controllerAs: '$ctrl', bindToController: true, };}function MdTruncateController($element) {$element.addClass('md-truncate');}})(); (function () {'use strict'; VirtualRepeatContainerController.$inject = ['$$rAF', '$mdUtil', '$mdConstant', '$parse', '$rootScope', '$window', '$scope', '$element', '$attrs']; VirtualRepeatController.$inject = ['$scope', '$element', '$attrs', '$browser', '$document', '$rootScope', '$$rAF', '$mdUtil']; VirtualRepeatDirective.$inject = ['$parse']; angular .module('material.components.virtualRepeat', ['material.core', 'material.components.showHide']) .directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective) .directive('mdVirtualRepeat', VirtualRepeatDirective) .directive('mdForceHeight', ForceHeightDirective); function VirtualRepeatContainerDirective() {return {controller: VirtualRepeatContainerController, template: virtualRepeatContainerTemplate, compile: function virtualRepeatContainerCompile($element, $attrs) {$element .addClass('md-virtual-repeat-container') .addClass($attrs.hasOwnProperty('mdOrientHorizontal') ? 'md-orient-horizontal' : 'md-orient-vertical');}, };}function virtualRepeatContainerTemplate($element) {return ( '<div class="md-virtual-repeat-scroller" role="presentation">' + '<div class="md-virtual-repeat-sizer" role="presentation"></div>' + '<div class="md-virtual-repeat-offsetter" role="presentation">' + $element[0].innerHTML + '</div></div>' );}var NUM_EXTRA = 3; function VirtualRepeatContainerController($$rAF, $mdUtil, $mdConstant, $parse, $rootScope, $window, $scope, $element, $attrs) {this.$rootScope = $rootScope; this.$scope = $scope; this.$element = $element; this.$attrs = $attrs; this.size = 0; this.scrollSize = 0; this.scrollOffset = 0; this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal'); this.repeater = null; this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink'); this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0; this.originalSize = null; this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0; this.oldElementSize = null; this.maxElementPixels = $mdConstant.ELEMENT_MAX_PIXELS; if (this.$attrs.mdTopIndex) {this.bindTopIndex = $parse(this.$attrs.mdTopIndex); this.topIndex = this.bindTopIndex(this.$scope); if (!angular.isDefined(this.topIndex)) {this.topIndex = 0; this.bindTopIndex.assign(this.$scope, 0);}this.$scope.$watch( this.bindTopIndex, angular.bind(this, function (newIndex) {if (newIndex !== this.topIndex) {this.scrollToIndex(newIndex);}}), );}else {this.topIndex = 0;}this.scroller = $element[0].querySelector('.md-virtual-repeat-scroller'); this.sizer = this.scroller.querySelector('.md-virtual-repeat-sizer'); this.offsetter = this.scroller.querySelector('.md-virtual-repeat-offsetter'); var boundUpdateSize = angular.bind(this, this.updateSize); $$rAF( angular.bind(this, function () {boundUpdateSize(); var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false); var jWindow = angular.element($window); if (!this.size) {debouncedUpdateSize();}jWindow.on('resize', debouncedUpdateSize); $scope.$on('$destroy', function () {jWindow.off('resize', debouncedUpdateSize);}); $scope.$emit('$md-resize-enable'); $scope.$on('$md-resize', boundUpdateSize);}), );}VirtualRepeatContainerController.prototype.register = function (repeaterCtrl) {this.repeater = repeaterCtrl; angular.element(this.scroller).on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));}; VirtualRepeatContainerController.prototype.isHorizontal = function () {return this.horizontal;}; VirtualRepeatContainerController.prototype.getSize = function () {return this.size;}; VirtualRepeatContainerController.prototype.setSize_ = function (size) {var dimension = this.getDimensionName_(); this.size = size; this.$element[0].style[dimension] = size + 'px';}; VirtualRepeatContainerController.prototype.unsetSize_ = function () {this.$element[0].style[this.getDimensionName_()] = this.oldElementSize; this.oldElementSize = null;}; VirtualRepeatContainerController.prototype.updateSize = function () {if (this.originalSize) return; this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight; this.handleScroll_(); this.repeater && this.repeater.containerUpdated();}; VirtualRepeatContainerController.prototype.getScrollSize = function () {return this.scrollSize;}; VirtualRepeatContainerController.prototype.getDimensionName_ = function () {return this.isHorizontal() ? 'width' : 'height';}; VirtualRepeatContainerController.prototype.sizeScroller_ = function (size) {var dimension = this.getDimensionName_(); var crossDimension = this.isHorizontal() ? 'height' : 'width'; this.sizer.innerHTML = ''; if (size < this.maxElementPixels) {this.sizer.style[dimension] = size + 'px';}else {this.sizer.style[dimension] = 'auto'; this.sizer.style[crossDimension] = 'auto'; var numChildren = Math.floor(size / this.maxElementPixels); var sizerChild = document.createElement('div'); sizerChild.style[dimension] = this.maxElementPixels + 'px'; sizerChild.style[crossDimension] = '1px'; for (var i = 0; i < numChildren; i++) {this.sizer.appendChild(sizerChild.cloneNode(false));}sizerChild.style[dimension] = size - numChildren * this.maxElementPixels + 'px'; this.sizer.appendChild(sizerChild);}}; VirtualRepeatContainerController.prototype.autoShrink_ = function (size) {var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize()); if (this.autoShrink && shrinkSize !== this.size) {if (this.oldElementSize === null) {this.oldElementSize = this.$element[0].style[this.getDimensionName_()];}var currentSize = this.originalSize || this.size; if (!currentSize || shrinkSize < currentSize) {if (!this.originalSize) {this.originalSize = this.size;}this.setSize_(shrinkSize);}else if (this.originalSize !== null) {this.unsetSize_(); var _originalSize = this.originalSize; this.originalSize = null; if (!_originalSize) this.updateSize(); this.setSize_(_originalSize || this.size);}this.repeater.containerUpdated();}}; VirtualRepeatContainerController.prototype.setScrollSize = function (itemsSize) {var size = itemsSize + this.offsetSize; if (this.scrollSize === size) return; this.sizeScroller_(size); this.autoShrink_(size); this.scrollSize = size;}; VirtualRepeatContainerController.prototype.getScrollOffset = function () {return this.scrollOffset;}; VirtualRepeatContainerController.prototype.scrollTo = function (position) {this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position; this.handleScroll_();}; VirtualRepeatContainerController.prototype.scrollToIndex = function (index) {var itemSize = this.repeater.getItemSize(); var itemsLength = this.repeater.itemsLength; if (index > itemsLength) {index = itemsLength - 1;}this.scrollTo(itemSize * index);}; VirtualRepeatContainerController.prototype.resetScroll = function () {this.scrollTo(0);}; VirtualRepeatContainerController.prototype.handleScroll_ = function () {var ltr = document.dir != 'rtl' && document.body.dir != 'rtl'; if (!ltr && !this.maxSize) {this.scroller.scrollLeft = this.scrollSize; this.maxSize = this.scroller.scrollLeft;}var offset = this.isHorizontal() ? (ltr ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft) : this.scroller.scrollTop; if (offset === this.scrollOffset || offset > this.scrollSize - this.size) return; var itemSize = this.repeater.getItemSize(); if (!itemSize) return; var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA); var transform = (this.isHorizontal() ? 'translateX(' : 'translateY(') + (!this.isHorizontal() || ltr ? numItems * itemSize : -(numItems * itemSize)) + 'px)'; this.scrollOffset = offset; this.offsetter.style.webkitTransform = transform; this.offsetter.style.transform = transform; if (this.bindTopIndex) {var topIndex = Math.floor(offset / itemSize); if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {this.topIndex = topIndex; this.bindTopIndex.assign(this.$scope, topIndex); if (!this.$rootScope.$$phase) this.$scope.$digest();}}this.repeater.containerUpdated();}; function VirtualRepeatDirective($parse) {return {controller: VirtualRepeatController, priority: 1000, require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'], restrict: 'A', terminal: true, transclude: 'element', compile: function VirtualRepeatCompile($element, $attrs) {var expression = $attrs.mdVirtualRepeat; var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/); var repeatName = match[1]; var repeatListExpression = $parse(match[2]); var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName); return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);};}, };}function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF, $mdUtil) {this.$scope = $scope; this.$element = $element; this.$attrs = $attrs; this.$browser = $browser; this.$document = $document; this.$mdUtil = $mdUtil; this.$rootScope = $rootScope; this.$$rAF = $$rAF; this.onDemand = $mdUtil.parseAttributeBoolean($attrs.mdOnDemand); this.browserCheckUrlChange = $browser.$$checkUrlChange; this.newStartIndex = 0; this.newEndIndex = 0; this.newVisibleEnd = 0; this.startIndex = 0; this.endIndex = 0; this.itemSize = $scope.$eval($attrs.mdItemSize) || null; this.isFirstRender = true; this.isVirtualRepeatUpdating_ = false; this.itemsLength = 0; this.unwatchItemSize_ = angular.noop; this.blocks = {}; this.pooledBlocks = []; $scope.$on('$destroy', angular.bind(this, this.cleanupBlocks_));}VirtualRepeatController.Block; VirtualRepeatController.prototype.link_ = function (container, transclude, repeatName, repeatListExpression, extraName) {this.container = container; this.transclude = transclude; this.repeatName = repeatName; this.rawRepeatListExpression = repeatListExpression; this.extraName = extraName; this.sized = false; this.repeatListExpression = angular.bind(this, this.repeatListExpression_); this.container.register(this);}; VirtualRepeatController.prototype.cleanupBlocks_ = function () {angular.forEach(this.pooledBlocks, function cleanupBlock(block) {block.element.remove();});}; VirtualRepeatController.prototype.readItemSize_ = function () {if (this.itemSize) {return;}this.items = this.repeatListExpression(this.$scope); this.parentNode = this.$element[0].parentNode; var block = this.getBlock_(0); if (!block.element[0].parentNode) {this.parentNode.appendChild(block.element[0]);}this.itemSize = block.element[0][this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null; this.blocks[0] = block; this.poolBlock_(0); if (this.itemSize) {this.containerUpdated();}}; VirtualRepeatController.prototype.repeatListExpression_ = function (scope) {var repeatList = this.rawRepeatListExpression(scope); if (this.onDemand && repeatList) {var virtualList = new VirtualRepeatModelArrayLike(repeatList); virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd); return virtualList;}else {return repeatList;}}; VirtualRepeatController.prototype.containerUpdated = function () {if (!this.itemSize) {if (this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop) {this.unwatchItemSize_();}this.unwatchItemSize_ = this.$scope.$watchCollection( this.repeatListExpression, angular.bind(this, function (items) {if (items && items.length) {this.readItemSize_();}}), ); if (!this.$rootScope.$$phase) this.$scope.$digest(); return;}else if (!this.sized) {this.items = this.repeatListExpression(this.$scope);}if (!this.sized) {this.unwatchItemSize_(); this.sized = true; this.$scope.$watchCollection( this.repeatListExpression, angular.bind(this, function (items, oldItems) {if (!this.isVirtualRepeatUpdating_) {this.virtualRepeatUpdate_(items, oldItems);}}), );}this.updateIndexes_(); if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {if (this.items instanceof VirtualRepeatModelArrayLike) {this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);}this.virtualRepeatUpdate_(this.items, this.items);}}; VirtualRepeatController.prototype.getItemSize = function () {return this.itemSize;}; VirtualRepeatController.prototype.getItemCount = function () {return this.itemsLength;}; VirtualRepeatController.prototype.virtualRepeatUpdate_ = function (items, oldItems) {this.isVirtualRepeatUpdating_ = true; var itemsLength = (items && items.length) || 0; var lengthChanged = false; if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {this.items = items; var previousScrollOffset = this.container.getScrollOffset(); this.container.resetScroll(); this.container.scrollTo(previousScrollOffset);}if (itemsLength !== this.itemsLength) {lengthChanged = true; this.itemsLength = itemsLength;}this.items = items; if (items !== oldItems || lengthChanged) {this.updateIndexes_();}this.parentNode = this.$element[0].parentNode; if (lengthChanged) {this.container.setScrollSize(itemsLength * this.itemSize);}Object.keys(this.blocks).forEach(function (blockIndex) {var index = parseInt(blockIndex, 10); if (index < this.newStartIndex || index >= this.newEndIndex) {this.poolBlock_(index);}}, this); this.$browser.$$checkUrlChange = angular.noop; var i, block, newStartBlocks = [], newEndBlocks = []; for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {block = this.getBlock_(i); this.updateBlock_(block, i); newStartBlocks.push(block);}for (; this.blocks[i] != null; i++) {this.updateBlock_(this.blocks[i], i);}var maxIndex = i - 1; for (; i < this.newEndIndex; i++) {block = this.getBlock_(i); this.updateBlock_(block, i); newEndBlocks.push(block);}if (newStartBlocks.length) {this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);}if (newEndBlocks.length) {this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);}this.$browser.$$checkUrlChange = this.browserCheckUrlChange; this.startIndex = this.newStartIndex; this.endIndex = this.newEndIndex; if (this.isFirstRender) {this.isFirstRender = false; var firstRenderStartIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex; this.$mdUtil.nextTick( function () {this.container.scrollToIndex(firstRenderStartIndex);}.bind(this), );}this.isVirtualRepeatUpdating_ = false;}; VirtualRepeatController.prototype.getBlock_ = function (index) {if (this.pooledBlocks.length) {return this.pooledBlocks.pop();}var block; this.transclude( angular.bind(this, function (clone, scope) {block = {element: clone, new: true, scope: scope, }; this.updateScope_(scope, index); this.parentNode.appendChild(clone[0]);}), ); return block;}; VirtualRepeatController.prototype.updateBlock_ = function (block, index) {this.blocks[index] = block; if (!block.new && block.scope.$index === index && block.scope[this.repeatName] === this.items[index]) {return;}block.new = false; this.updateScope_(block.scope, index); if (!this.$rootScope.$$phase) {block.scope.$digest();}}; VirtualRepeatController.prototype.updateScope_ = function (scope, index) {scope.$index = index; scope[this.repeatName] = this.items && this.items[index]; if (this.extraName) scope[this.extraName(this.$scope)] = this.items[index];}; VirtualRepeatController.prototype.poolBlock_ = function (index) {this.pooledBlocks.push(this.blocks[index]); this.parentNode.removeChild(this.blocks[index].element[0]); delete this.blocks[index];}; VirtualRepeatController.prototype.domFragmentFromBlocks_ = function (blocks) {var fragment = this.$document[0].createDocumentFragment(); blocks.forEach(function (block) {fragment.appendChild(block.element[0]);}); return fragment;}; VirtualRepeatController.prototype.updateIndexes_ = function () {var itemsLength = this.items ? this.items.length : 0; var containerLength = Math.ceil(this.container.getSize() / this.itemSize); this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize))); this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA; this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd); this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);}; function VirtualRepeatModelArrayLike(model) {if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) {throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ');}this.model = model;}VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function (start, end) {for (var i = start; i < end; i++) {if (!this.hasOwnProperty(i)) {this[i] = this.model.getItemAtIndex(i);}}this.length = this.model.getLength();}; function ForceHeightDirective($mdUtil) {return {restrict: 'A', link: function (scope, element, attrs) {var height = scope.$eval(attrs.mdForceHeight) || null; if (height && element) {element[0].style.height = height;}}, };}ForceHeightDirective.$inject = ['$mdUtil'];})(); (function () {'use strict'; MdWhiteframeDirective.$inject = ['$log']; angular.module('material.components.whiteframe', ['material.core']).directive('mdWhiteframe', MdWhiteframeDirective); function MdWhiteframeDirective($log) {var DISABLE_DP = -1; var MIN_DP = 1; var MAX_DP = 24; var DEFAULT_DP = 4; return {link: postLink, }; function postLink(scope, element, attr) {var oldClass = ''; attr.$observe('mdWhiteframe', function (elevation) {elevation = parseInt(elevation, 10) || DEFAULT_DP; if (elevation != DISABLE_DP && (elevation > MAX_DP || elevation < MIN_DP)) {$log.warn('md-whiteframe attribute value is invalid. It should be a number between ' + MIN_DP + ' and ' + MAX_DP, element[0]); elevation = DEFAULT_DP;}var newClass = elevation == DISABLE_DP ? '' : 'md-whiteframe-' + elevation + 'dp'; attr.$updateClass(newClass, oldClass); oldClass = newClass;});}}})(); (function () {'use strict'; MdAutocompleteCtrl.$inject = [ '$scope', '$element', '$mdUtil', '$mdConstant', '$mdTheming', '$window', '$animate', '$rootElement', '$attrs', '$q', '$log', '$mdLiveAnnouncer', ]; angular.module('material.components.autocomplete').controller('MdAutocompleteCtrl', MdAutocompleteCtrl); var ITEM_HEIGHT = 48, MAX_ITEMS = 5, MENU_PADDING = 8, INPUT_PADDING = 2; function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q, $log, $mdLiveAnnouncer) {var ctrl = this, itemParts = $scope.itemsExpr.split(/ in /i), itemExpr = itemParts[1], elements = null, cache = {}, noBlur = false, selectedItemWatchers = [], hasFocus = false, fetchesInProgress = 0, enableWrapScroll = null, inputModelCtrl = null, debouncedOnResize = $mdUtil.debounce(onWindowResize); defineProperty('hidden', handleHiddenChange, true); ctrl.scope = $scope; ctrl.parent = $scope.$parent; ctrl.itemName = itemParts[0]; ctrl.matches = []; ctrl.loading = false; ctrl.hidden = true; ctrl.index = null; ctrl.id = $mdUtil.nextUid(); ctrl.isDisabled = null; ctrl.isRequired = null; ctrl.isReadonly = null; ctrl.hasNotFound = false; ctrl.keydown = keydown; ctrl.blur = blur; ctrl.focus = focus; ctrl.clear = clearValue; ctrl.select = select; ctrl.listEnter = onListEnter; ctrl.listLeave = onListLeave; ctrl.mouseUp = onMouseup; ctrl.getCurrentDisplayValue = getCurrentDisplayValue; ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher; ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher; ctrl.notFoundVisible = notFoundVisible; ctrl.loadingIsVisible = loadingIsVisible; ctrl.positionDropdown = positionDropdown; var ReportType = {Count: 1, Selected: 2, }; return init(); function init() {$mdUtil.initOptionalProperties($scope, $attrs, {searchText: '', selectedItem: null, clearButton: false, }); $mdTheming($element); configureWatchers(); $mdUtil.nextTick(function () {gatherElements(); moveDropdown(); if ($scope.autofocus) {$element.on('focus', focusInputElement);}});}function updateModelValidators() {if (!$scope.requireMatch || !inputModelCtrl) return; inputModelCtrl.$setValidity('md-require-match', !!$scope.selectedItem || !$scope.searchText);}function positionDropdown() {if (!elements) {return $mdUtil.nextTick(positionDropdown, false, $scope);}var dropdownHeight = ($scope.dropdownItems || MAX_ITEMS) * ITEM_HEIGHT; var hrect = elements.wrap.getBoundingClientRect(), vrect = elements.snap.getBoundingClientRect(), root = elements.root.getBoundingClientRect(), top = vrect.bottom - root.top, bot = root.bottom - vrect.top, left = hrect.left - root.left, width = hrect.width, offset = getVerticalOffset(), position = $scope.dropdownPosition, styles; if (!position) {position = top > bot && root.height - top - MENU_PADDING < dropdownHeight ? 'top' : 'bottom';}if ($attrs.mdFloatingLabel) {left += INPUT_PADDING; width -= INPUT_PADDING * 2;}styles = {left: left + 'px', minWidth: width + 'px', maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px', }; if (position === 'top') {styles.top = 'auto'; styles.bottom = bot + 'px'; styles.maxHeight = Math.min(dropdownHeight, hrect.top - root.top - MENU_PADDING) + 'px';}else {var bottomSpace = root.bottom - hrect.bottom - MENU_PADDING + $mdUtil.getViewportTop(); styles.top = top - offset + 'px'; styles.bottom = 'auto'; styles.maxHeight = Math.min(dropdownHeight, bottomSpace) + 'px';}elements.$.scrollContainer.css(styles); $mdUtil.nextTick(correctHorizontalAlignment, false); function getVerticalOffset() {var offset = 0; var inputContainer = $element.find('md-input-container'); if (inputContainer.length) {var input = inputContainer.find('input'); offset = inputContainer.prop('offsetHeight'); offset -= input.prop('offsetTop'); offset -= input.prop('offsetHeight'); offset += inputContainer.prop('offsetTop');}return offset;}function correctHorizontalAlignment() {var dropdown = elements.scrollContainer.getBoundingClientRect(), styles = {}; if (dropdown.right > root.right - MENU_PADDING) {styles.left = hrect.right - dropdown.width + 'px';}elements.$.scrollContainer.css(styles);}}function moveDropdown() {if (!elements.$.root.length) return; $mdTheming(elements.$.scrollContainer); elements.$.scrollContainer.detach(); elements.$.root.append(elements.$.scrollContainer); if ($animate.pin) $animate.pin(elements.$.scrollContainer, $rootElement);}function focusInputElement() {elements.input.focus();}function configureWatchers() {var wait = parseInt($scope.delay, 10) || 0; $attrs.$observe('disabled', function (value) {ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, false);}); $attrs.$observe('required', function (value) {ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, false);}); $attrs.$observe('readonly', function (value) {ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, false);}); $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText); $scope.$watch('selectedItem', selectedItemChange); angular.element($window).on('resize', debouncedOnResize); $scope.$on('$destroy', cleanup);}function cleanup() {if (!ctrl.hidden) {$mdUtil.enableScrolling();}angular.element($window).off('resize', debouncedOnResize); if (elements) {var items = ['ul', 'scroller', 'scrollContainer', 'input']; angular.forEach(items, function (key) {elements.$[key].remove();});}}function onWindowResize() {if (!ctrl.hidden) {positionDropdown();}}function gatherElements() {var snapWrap = gatherSnapWrap(); elements = {main: $element[0], scrollContainer: $element[0].querySelector('.md-virtual-repeat-container'), scroller: $element[0].querySelector('.md-virtual-repeat-scroller'), ul: $element.find('ul')[0], input: $element.find('input')[0], wrap: snapWrap.wrap, snap: snapWrap.snap, root: document.body, }; elements.li = elements.ul.getElementsByTagName('li'); elements.$ = getAngularElements(elements); inputModelCtrl = elements.$.input.controller('ngModel');}function gatherSnapWrap() {var element; var value; for (element = $element; element.length; element = element.parent()) {value = element.attr('md-autocomplete-snap'); if (angular.isDefined(value)) break;}if (element.length) {return {snap: element[0], wrap: value.toLowerCase() === 'width' ? element[0] : $element.find('md-autocomplete-wrap')[0], };}var wrap = $element.find('md-autocomplete-wrap')[0]; return {snap: wrap, wrap: wrap, };}function getAngularElements(elements) {var obj = {}; for (var key in elements) {if (elements.hasOwnProperty(key)) obj[key] = angular.element(elements[key]);}return obj;}function handleHiddenChange(hidden, oldHidden) {if (!hidden && oldHidden) {positionDropdown(); reportMessages(true, ReportType.Count | ReportType.Selected); if (elements) {$mdUtil.disableScrollAround(elements.ul); enableWrapScroll = disableElementScrollEvents(angular.element(elements.wrap));}}else if (hidden && !oldHidden) {$mdUtil.enableScrolling(); if (enableWrapScroll) {enableWrapScroll(); enableWrapScroll = null;}}}function disableElementScrollEvents(element) {function preventDefault(e) {e.preventDefault();}element.on('wheel', preventDefault); element.on('touchmove', preventDefault); return function () {element.off('wheel', preventDefault); element.off('touchmove', preventDefault);};}function onListEnter() {noBlur = true;}function onListLeave() {if (!hasFocus && !ctrl.hidden) elements.input.focus(); noBlur = false; ctrl.hidden = shouldHide();}function onMouseup() {elements.input.focus();}function selectedItemChange(selectedItem, previousSelectedItem) {updateModelValidators(); if (selectedItem) {getDisplayValue(selectedItem).then(function (val) {$scope.searchText = val; handleSelectedItemChange(selectedItem, previousSelectedItem);});}else if (previousSelectedItem && $scope.searchText) {getDisplayValue(previousSelectedItem).then(function (displayValue) {if (angular.isString($scope.searchText) && displayValue.toString().toLowerCase() === $scope.searchText.toLowerCase()) {$scope.searchText = '';}});}if (selectedItem !== previousSelectedItem) announceItemChange();}function announceItemChange() {angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));}function announceTextChange() {angular.isFunction($scope.textChange) && $scope.textChange();}function handleSelectedItemChange(selectedItem, previousSelectedItem) {selectedItemWatchers.forEach(function (watcher) {watcher(selectedItem, previousSelectedItem);});}function registerSelectedItemWatcher(cb) {if (selectedItemWatchers.indexOf(cb) == -1) {selectedItemWatchers.push(cb);}}function unregisterSelectedItemWatcher(cb) {var i = selectedItemWatchers.indexOf(cb); if (i != -1) {selectedItemWatchers.splice(i, 1);}}function handleSearchText(searchText, previousSearchText) {ctrl.index = getDefaultIndex(); if (searchText === previousSearchText) return; updateModelValidators(); getDisplayValue($scope.selectedItem).then(function (val) {if (searchText !== val) {$scope.selectedItem = null; if (searchText !== previousSearchText) announceTextChange(); if (!isMinLengthMet()) {ctrl.matches = []; setLoading(false); reportMessages(false, ReportType.Count);}else {handleQuery();}}});}function blur($event) {hasFocus = false; if (!noBlur) {ctrl.hidden = shouldHide(); evalAttr('ngBlur', {$event: $event });}}function doBlur(forceBlur) {if (forceBlur) {noBlur = false; hasFocus = false;}elements.input.blur();}function focus($event) {hasFocus = true; if (isSearchable() && isMinLengthMet()) {handleQuery();}ctrl.hidden = shouldHide(); evalAttr('ngFocus', {$event: $event });}function keydown(event) {switch (event.keyCode) {case $mdConstant.KEY_CODE.DOWN_ARROW: if (ctrl.loading) return; event.stopPropagation(); event.preventDefault(); ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1); updateScroll(); reportMessages(false, ReportType.Selected); break; case $mdConstant.KEY_CODE.UP_ARROW: if (ctrl.loading) return; event.stopPropagation(); event.preventDefault(); ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1); updateScroll(); reportMessages(false, ReportType.Selected); break; case $mdConstant.KEY_CODE.TAB: onListLeave(); if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return; select(ctrl.index); break; case $mdConstant.KEY_CODE.ENTER: if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return; if (hasSelection()) return; event.stopPropagation(); event.preventDefault(); select(ctrl.index); break; case $mdConstant.KEY_CODE.ESCAPE: event.preventDefault(); if (!shouldProcessEscape()) return; event.stopPropagation(); clearSelectedItem(); if ($scope.searchText && hasEscapeOption('clear')) {clearSearchText();}ctrl.hidden = true; if (hasEscapeOption('blur')) {doBlur(true);}break; default: }}function getMinLength() {return angular.isNumber($scope.minLength) ? $scope.minLength : 1;}function getDisplayValue(item) {return $q.when(getItemText(item) || item).then(function (itemText) {if (itemText && !angular.isString(itemText)) {$log.warn('md-autocomplete: Could not resolve display value to a string. ' + 'Please check the `md-item-text` attribute.');}return itemText;}); function getItemText(item) {return item && $scope.itemText ? $scope.itemText(getItemAsNameVal(item)) : null;}}function getItemAsNameVal(item) {if (!item) return undefined; var locals = {}; if (ctrl.itemName) locals[ctrl.itemName] = item; return locals;}function getDefaultIndex() {return $scope.autoselect ? 0 : -1;}function setLoading(value) {if (ctrl.loading != value) {ctrl.loading = value;}ctrl.hidden = shouldHide();}function shouldHide() {if (!isSearchable()) return true; else return !shouldShow();}function isSearchable() {if (ctrl.loading && !hasMatches()) return false; else if (hasSelection()) return false; else if (!hasFocus) return false; return true;}function shouldProcessEscape() {return hasEscapeOption('blur') || !ctrl.hidden || ctrl.loading || (hasEscapeOption('clear') && $scope.searchText);}function hasEscapeOption(option) {return !$scope.escapeOptions || $scope.escapeOptions.toLowerCase().indexOf(option) !== -1;}function shouldShow() {return (isMinLengthMet() && hasMatches()) || notFoundVisible();}function hasMatches() {return ctrl.matches.length ? true : false;}function hasSelection() {return ctrl.scope.selectedItem ? true : false;}function loadingIsVisible() {return ctrl.loading && !hasSelection();}function getCurrentDisplayValue() {return getDisplayValue(ctrl.matches[ctrl.index]);}function isMinLengthMet() {return ($scope.searchText || '').length >= getMinLength();}function defineProperty(key, handler, value) {Object.defineProperty(ctrl, key, {get: function () {return value;}, set: function (newValue) {var oldValue = value; value = newValue; handler(newValue, oldValue);}, });}function select(index) {$mdUtil.nextTick(function () {getDisplayValue(ctrl.matches[index]) .then(function (val) {var ngModel = elements.$.input.controller('ngModel'); ngModel.$setViewValue(val); ngModel.$render();}) .finally(function () {$scope.selectedItem = ctrl.matches[index]; setLoading(false);});}, false);}function clearValue() {clearSelectedItem(); clearSearchText();}function clearSelectedItem() {ctrl.index = 0; ctrl.matches = [];}function clearSearchText() {setLoading(true); $scope.searchText = ''; var eventObj = document.createEvent('CustomEvent'); eventObj.initCustomEvent('change', true, true, {value: '' }); elements.input.dispatchEvent(eventObj); elements.input.blur(); $scope.searchText = ''; elements.input.focus();}function fetchResults(searchText) {var items = $scope.$parent.$eval(itemExpr), term = searchText.toLowerCase(), isList = angular.isArray(items), isPromise = !!items.then; if (isList) onResultsRetrieved(items); else if (isPromise) handleAsyncResults(items); function handleAsyncResults(items) {if (!items) return; items = $q.when(items); fetchesInProgress++; setLoading(true); $mdUtil.nextTick( function () {items.then(onResultsRetrieved).finally(function () {if (--fetchesInProgress === 0) {setLoading(false);}});}, true, $scope, );}function onResultsRetrieved(matches) {cache[term] = matches; if ((searchText || '') !== ($scope.searchText || '')) {return;}handleResults(matches);}}function reportMessages(isPolite, types) {var politeness = isPolite ? 'polite' : 'assertive'; var messages = []; if (types & ReportType.Selected && ctrl.index !== -1) {messages.push(getCurrentDisplayValue());}if (types & ReportType.Count) {messages.push($q.resolve(getCountMessage()));}$q.all(messages).then(function (data) {$mdLiveAnnouncer.announce(data.join(' '), politeness);});}function getCountMessage() {switch (ctrl.matches.length) {case 0: return 'There are no matches available.'; case 1: return 'There is 1 match available.'; default: return 'There are ' + ctrl.matches.length + ' matches available.';}}function updateScroll() {if (!elements.li[0]) return; var height = elements.li[0].offsetHeight, top = height * ctrl.index, bot = top + height, hgt = elements.scroller.clientHeight, scrollTop = elements.scroller.scrollTop; if (top < scrollTop) {scrollTo(top);}else if (bot > scrollTop + hgt) {scrollTo(bot - hgt);}}function isPromiseFetching() {return fetchesInProgress !== 0;}function scrollTo(offset) {elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);}function notFoundVisible() {var textLength = (ctrl.scope.searchText || '').length; return ( ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection() );}function handleQuery() {var searchText = $scope.searchText || ''; var term = searchText.toLowerCase(); if (!$scope.noCache && cache[term]) {handleResults(cache[term]);}else {fetchResults(searchText);}ctrl.hidden = shouldHide();}function handleResults(results) {ctrl.matches = results; ctrl.hidden = shouldHide(); if (ctrl.loading) setLoading(false); if ($scope.selectOnMatch) selectItemOnMatch(); positionDropdown(); reportMessages(true, ReportType.Count);}function selectItemOnMatch() {var searchText = $scope.searchText, matches = ctrl.matches, item = matches[0]; if (matches.length === 1) getDisplayValue(item).then(function (displayValue) {var isMatching = searchText == displayValue; if ($scope.matchInsensitive && !isMatching) {isMatching = searchText.toLowerCase() == displayValue.toLowerCase();}if (isMatching) select(0);});}function evalAttr(attr, locals) {if ($attrs[attr]) {$scope.$parent.$eval($attrs[attr], locals || {});}}}})(); (function () {'use strict'; MdAutocomplete.$inject = ['$$mdSvgRegistry']; angular.module('material.components.autocomplete').directive('mdAutocomplete', MdAutocomplete); function MdAutocomplete($$mdSvgRegistry) {return {controller: 'MdAutocompleteCtrl', controllerAs: '$mdAutocompleteCtrl', scope: {inputName: '@mdInputName', inputMinlength: '@mdInputMinlength', inputMaxlength: '@mdInputMaxlength', searchText: '=?mdSearchText', selectedItem: '=?mdSelectedItem', itemsExpr: '@mdItems', itemText: '&mdItemText', placeholder: '@placeholder', noCache: '=?mdNoCache', requireMatch: '=?mdRequireMatch', selectOnMatch: '=?mdSelectOnMatch', matchInsensitive: '=?mdMatchCaseInsensitive', itemChange: '&?mdSelectedItemChange', textChange: '&?mdSearchTextChange', minLength: '=?mdMinLength', delay: '=?mdDelay', autofocus: '=?mdAutofocus', floatingLabel: '@?mdFloatingLabel', autoselect: '=?mdAutoselect', menuClass: '@?mdMenuClass', inputId: '@?mdInputId', escapeOptions: '@?mdEscapeOptions', dropdownItems: '=?mdDropdownItems', dropdownPosition: '@?mdDropdownPosition', clearButton: '=?mdClearButton', }, compile: function (tElement, tAttrs) {var attributes = ['md-select-on-focus', 'md-no-asterisk', 'ng-trim', 'ng-pattern']; var input = tElement.find('input'); attributes.forEach(function (attribute) {var attrValue = tAttrs[tAttrs.$normalize(attribute)]; if (attrValue !== null) {input.attr(attribute, attrValue);}}); return function (scope, element, attrs, ctrl) {ctrl.hasNotFound = !!element.attr('md-has-not-found'); if (!angular.isDefined(attrs.mdClearButton) && !scope.floatingLabel) {scope.clearButton = true;}};}, template: function (element, attr) {var noItemsTemplate = getNoItemsTemplate(), itemTemplate = getItemTemplate(), leftover = element.html(), tabindex = attr.tabindex; if (noItemsTemplate) element.attr('md-has-not-found', true); element.attr('tabindex', '-1'); return ( "\ <md-autocomplete-wrap\ ng-class=\"{'md-whiteframe-z1': !floatingLabel, \ 'md-menu-showing': !$mdAutocompleteCtrl.hidden, \ 'md-show-clear-button': !!clearButton }\">\ " + getInputElement() + '\ ' + getClearButton() + '\ <md-progress-linear\ class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\ ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\ md-mode="indeterminate"></md-progress-linear>\ <md-virtual-repeat-container\ md-auto-shrink\ md-auto-shrink-min="1"\ ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\ ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\ ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\ ng-hide="$mdAutocompleteCtrl.hidden"\ class="md-autocomplete-suggestions-container md-whiteframe-z1"\ ng-class="{\'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\ role="presentation">\ <ul class="md-autocomplete-suggestions"\ ng-class="::menuClass"\ id="ul-{{$mdAutocompleteCtrl.id}}">\ <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"\ ng-class="{selected: $index === $mdAutocompleteCtrl.index }"\ ng-click="$mdAutocompleteCtrl.select($index)"\ md-extra-name="$mdAutocompleteCtrl.itemName">\ ' + itemTemplate + '\ </li>' + noItemsTemplate + '\ </ul>\ </md-virtual-repeat-container>\ </md-autocomplete-wrap>' ); function getItemTemplate() {var templateTag = element.find('md-item-template').detach(), html = templateTag.length ? templateTag.html() : element.html(); if (!templateTag.length) element.empty(); return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html + '</md-autocomplete-parent-scope>';}function getNoItemsTemplate() {var templateTag = element.find('md-not-found').detach(), template = templateTag.length ? templateTag.html() : ''; return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\ md-autocomplete-parent-scope>' + template + '</li>' : '';}function getInputElement() {if (attr.mdFloatingLabel) {return ( '\ <md-input-container ng-if="floatingLabel">\ <label>{{floatingLabel}}</label>\ <input type="search"\ ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\ id="{{inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\ name="{{inputName}}"\ autocomplete="off"\ ng-required="$mdAutocompleteCtrl.isRequired"\ ng-readonly="$mdAutocompleteCtrl.isReadonly"\ ng-minlength="inputMinlength"\ ng-maxlength="inputMaxlength"\ ng-disabled="$mdAutocompleteCtrl.isDisabled"\ ng-model="$mdAutocompleteCtrl.scope.searchText"\ ng-model-options="{allowInvalid: true }"\ ng-keydown="$mdAutocompleteCtrl.keydown($event)"\ ng-blur="$mdAutocompleteCtrl.blur($event)"\ ng-focus="$mdAutocompleteCtrl.focus($event)"\ aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\ aria-label="{{floatingLabel}}"\ aria-autocomplete="list"\ role="combobox"\ aria-haspopup="true"\ aria-activedescendant=""\ aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\ <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\ </md-input-container>' );}else {return ( '\ <input type="search"\ ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\ id="{{inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\ name="{{inputName}}"\ ng-if="!floatingLabel"\ autocomplete="off"\ ng-required="$mdAutocompleteCtrl.isRequired"\ ng-disabled="$mdAutocompleteCtrl.isDisabled"\ ng-readonly="$mdAutocompleteCtrl.isReadonly"\ ng-minlength="inputMinlength"\ ng-maxlength="inputMaxlength"\ ng-model="$mdAutocompleteCtrl.scope.searchText"\ ng-keydown="$mdAutocompleteCtrl.keydown($event)"\ ng-blur="$mdAutocompleteCtrl.blur($event)"\ ng-focus="$mdAutocompleteCtrl.focus($event)"\ placeholder="{{placeholder}}"\ aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\ aria-label="{{placeholder}}"\ aria-autocomplete="list"\ role="combobox"\ aria-haspopup="true"\ aria-activedescendant=""\ aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>' );}}function getClearButton() {return ( '' + '<button ' + 'type="button" ' + 'aria-label="Clear Input" ' + 'tabindex="-1" ' + 'ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" ' + 'ng-click="$mdAutocompleteCtrl.clear($event)">' + '<md-icon md-svg-src="' + $$mdSvgRegistry.mdClose + '"></md-icon>' + '</button>' );}}, };}})(); (function () {'use strict'; MdAutocompleteItemScopeDirective.$inject = ['$compile', '$mdUtil']; angular.module('material.components.autocomplete').directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective); function MdAutocompleteItemScopeDirective($compile, $mdUtil) {return {restrict: 'AE', compile: compile, terminal: true, transclude: 'element', }; function compile(tElement, tAttr, transclude) {return function postLink(scope, element, attr) {var ctrl = scope.$mdAutocompleteCtrl; var newScope = ctrl.parent.$new(); var itemName = ctrl.itemName; watchVariable('$index', '$index'); watchVariable('item', itemName); connectScopes(); transclude(newScope, function (clone) {element.after(clone);}); function watchVariable(variable, alias) {newScope[alias] = scope[variable]; scope.$watch(variable, function (value) {$mdUtil.nextTick(function () {newScope[alias] = value;});});}function connectScopes() {var scopeDigesting = false; var newScopeDigesting = false; scope.$watch(function () {if (newScopeDigesting || scopeDigesting) {return;}scopeDigesting = true; scope.$$postDigest(function () {if (!newScopeDigesting) {newScope.$digest();}scopeDigesting = newScopeDigesting = false;});}); newScope.$watch(function () {newScopeDigesting = true;});}};}}})(); (function () {'use strict'; MdHighlightCtrl.$inject = ['$scope', '$element', '$attrs']; angular.module('material.components.autocomplete').controller('MdHighlightCtrl', MdHighlightCtrl); function MdHighlightCtrl($scope, $element, $attrs) {this.$scope = $scope; this.$element = $element; this.$attrs = $attrs; this.regex = null;}MdHighlightCtrl.prototype.init = function (unsafeTermFn, unsafeContentFn) {this.flags = this.$attrs.mdHighlightFlags || ''; this.unregisterFn = this.$scope.$watch( function ($scope) {return {term: unsafeTermFn($scope), contentText: unsafeContentFn($scope), };}.bind(this), this.onRender.bind(this), true, ); this.$element.on('$destroy', this.unregisterFn);}; MdHighlightCtrl.prototype.onRender = function (state, prevState) {var contentText = state.contentText; if (this.regex === null || state.term !== prevState.term) {this.regex = this.createRegex(state.term, this.flags);}if (state.term) {this.applyRegex(contentText);}else {this.$element.text(contentText);}}; MdHighlightCtrl.prototype.applyRegex = function (text) {var tokens = this.resolveTokens(text); this.$element.empty(); tokens.forEach( function (token) {if (token.isMatch) {var tokenEl = angular.element('<span class="highlight">').text(token.text); this.$element.append(tokenEl);}else {this.$element.append(document.createTextNode(token));}}.bind(this), );}; MdHighlightCtrl.prototype.resolveTokens = function (string) {var tokens = []; var lastIndex = 0; string.replace(this.regex, function (match, index) {appendToken(lastIndex, index); tokens.push({text: match, isMatch: true, }); lastIndex = index + match.length;}); appendToken(lastIndex); return tokens; function appendToken(from, to) {var targetText = string.slice(from, to); targetText && tokens.push(targetText);}}; MdHighlightCtrl.prototype.createRegex = function (term, flags) {var startFlag = '', endFlag = ''; var regexTerm = this.sanitizeRegex(term); if (flags.indexOf('^') >= 0) startFlag = '^'; if (flags.indexOf('$') >= 0) endFlag = '$'; return new RegExp(startFlag + regexTerm + endFlag, flags.replace(/[$\^]/g, ''));}; MdHighlightCtrl.prototype.sanitizeRegex = function (term) {return term && term.toString().replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, '\\$&');};})(); (function () {'use strict'; MdHighlight.$inject = ['$interpolate', '$parse']; angular.module('material.components.autocomplete').directive('mdHighlightText', MdHighlight); function MdHighlight($interpolate, $parse) {return {terminal: true, controller: 'MdHighlightCtrl', compile: function mdHighlightCompile(tElement, tAttr) {var termExpr = $parse(tAttr.mdHighlightText); var unsafeContentExpr = $interpolate(tElement.html()); return function mdHighlightLink(scope, element, attr, ctrl) {ctrl.init(termExpr, unsafeContentExpr);};}, };}})(); (function () {'use strict'; MdChipCtrl.$inject = ['$scope', '$element', '$mdConstant', '$timeout', '$mdUtil']; angular.module('material.components.chips').controller('MdChipCtrl', MdChipCtrl); function MdChipCtrl($scope, $element, $mdConstant, $timeout, $mdUtil) {this.$scope = $scope; this.$element = $element; this.$mdConstant = $mdConstant; this.$timeout = $timeout; this.$mdUtil = $mdUtil; this.isEditting = false; this.parentController = undefined; this.enableChipEdit = false;}MdChipCtrl.prototype.init = function (controller) {this.parentController = controller; this.enableChipEdit = this.parentController.enableChipEdit; if (this.enableChipEdit) {this.$element.on('keydown', this.chipKeyDown.bind(this)); this.$element.on('mousedown', this.chipMouseDown.bind(this)); this.getChipContent().addClass('_md-chip-content-edit-is-enabled');}}; MdChipCtrl.prototype.getChipContent = function () {var chipContents = this.$element[0].getElementsByClassName('md-chip-content'); return angular.element(chipContents[0]);}; MdChipCtrl.prototype.getContentElement = function () {return angular.element(this.getChipContent().children()[0]);}; MdChipCtrl.prototype.getChipIndex = function () {return parseInt(this.$element.attr('index'));}; MdChipCtrl.prototype.goOutOfEditMode = function () {if (!this.isEditting) return; this.isEditting = false; this.$element.removeClass('_md-chip-editing'); this.getChipContent()[0].contentEditable = 'false'; var chipIndex = this.getChipIndex(); var content = this.getContentElement().text(); if (content) {this.parentController.updateChipContents(chipIndex, this.getContentElement().text()); this.$mdUtil.nextTick( function () {if (this.parentController.selectedChip === chipIndex) {this.parentController.focusChip(chipIndex);}}.bind(this), );}else {this.parentController.removeChipAndFocusInput(chipIndex);}}; MdChipCtrl.prototype.selectNodeContents = function (node) {var range, selection; if (document.body.createTextRange) {range = document.body.createTextRange(); range.moveToElementText(node); range.select();}else if (window.getSelection) {selection = window.getSelection(); range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range);}}; MdChipCtrl.prototype.goInEditMode = function () {this.isEditting = true; this.$element.addClass('_md-chip-editing'); this.getChipContent()[0].contentEditable = 'true'; this.getChipContent().on( 'blur', function () {this.goOutOfEditMode();}.bind(this), ); this.selectNodeContents(this.getChipContent()[0]);}; MdChipCtrl.prototype.chipKeyDown = function (event) {if (!this.isEditting && (event.keyCode === this.$mdConstant.KEY_CODE.ENTER || event.keyCode === this.$mdConstant.KEY_CODE.SPACE)) {event.preventDefault(); this.goInEditMode();}else if (this.isEditting && event.keyCode === this.$mdConstant.KEY_CODE.ENTER) {event.preventDefault(); this.goOutOfEditMode();}}; MdChipCtrl.prototype.chipMouseDown = function () {if (this.getChipIndex() == this.parentController.selectedChip && this.enableChipEdit && !this.isEditting) {this.goInEditMode();}};})(); (function () {'use strict'; MdChip.$inject = ['$mdTheming', '$mdUtil', '$compile', '$timeout']; angular.module('material.components.chips').directive('mdChip', MdChip); var DELETE_HINT_TEMPLATE = '\ <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">\ {{$mdChipsCtrl.deleteHint}}\ </span>'; function MdChip($mdTheming, $mdUtil, $compile, $timeout) {var deleteHintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE); return {restrict: 'E', require: ['^?mdChips', 'mdChip'], link: postLink, controller: 'MdChipCtrl', }; function postLink(scope, element, attr, ctrls) {var chipsController = ctrls.shift(); var chipController = ctrls.shift(); var chipContentElement = angular.element(element[0].querySelector('.md-chip-content')); $mdTheming(element); if (chipsController) {chipController.init(chipsController); chipContentElement.append($compile(deleteHintTemplate)(scope)); chipContentElement.on('blur', function () {chipsController.resetSelectedChip(); chipsController.$scope.$applyAsync();});}$timeout(function () {if (!chipsController) {return;}if (chipsController.shouldFocusLastChip) {chipsController.focusLastChipThenInput();}});}}})(); (function () {'use strict'; MdChipRemove.$inject = ['$timeout']; angular.module('material.components.chips').directive('mdChipRemove', MdChipRemove); function MdChipRemove($timeout) {return {restrict: 'A', require: '^mdChips', scope: false, link: postLink, }; function postLink(scope, element, attr, ctrl) {element.on('click', function (event) {scope.$apply(function () {ctrl.removeChip(scope.$$replacedScope.$index);});}); $timeout(function () {element.attr({tabindex: -1, 'aria-hidden': true }); element.find('button').attr('tabindex', '-1');});}}})(); (function () {'use strict'; MdChipTransclude.$inject = ['$compile']; angular.module('material.components.chips').directive('mdChipTransclude', MdChipTransclude); function MdChipTransclude($compile) {return {restrict: 'EA', terminal: true, link: link, scope: false, }; function link(scope, element, attr) {var ctrl = scope.$parent.$mdChipsCtrl, newScope = ctrl.parent.$new(false, ctrl.parent); newScope.$$replacedScope = scope; newScope.$chip = scope.$chip; newScope.$index = scope.$index; newScope.$mdChipsCtrl = ctrl; var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude); element.html(newHtml); $compile(element.contents())(newScope);}}})(); (function () {'use strict'; MdChipsCtrl.$inject = ['$scope', '$attrs', '$mdConstant', '$log', '$element', '$timeout', '$mdUtil']; var DEFAULT_CHIP_APPEND_DELAY = 300; angular.module('material.components.chips').controller('MdChipsCtrl', MdChipsCtrl); function MdChipsCtrl($scope, $attrs, $mdConstant, $log, $element, $timeout, $mdUtil) {this.$timeout = $timeout; this.$mdConstant = $mdConstant; this.$scope = $scope; this.parent = $scope.$parent; this.$mdUtil = $mdUtil; this.$log = $log; this.$element = $element; this.$attrs = $attrs; this.ngModelCtrl = null; this.userInputNgModelCtrl = null; this.autocompleteCtrl = null; this.userInputElement = null; this.items = []; this.selectedChip = -1; this.enableChipEdit = $mdUtil.parseAttributeBoolean($attrs.mdEnableChipEdit); this.addOnBlur = $mdUtil.parseAttributeBoolean($attrs.mdAddOnBlur); this.inputAriaLabel = 'Chips input.'; this.containerHint = 'Chips container. Use arrow keys to select chips.'; this.deleteHint = 'Press delete to remove this chip.'; this.deleteButtonLabel = 'Remove'; this.chipBuffer = ''; this.useTransformChip = false; this.useOnAdd = false; this.useOnRemove = false; this.wrapperId = ''; this.contentIds = []; this.ariaTabIndex = null; this.chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY; this.init();}MdChipsCtrl.prototype.init = function () {var ctrl = this; ctrl.wrapperId = '_md-chips-wrapper-' + ctrl.$mdUtil.nextUid(); ctrl.$scope.$watchCollection('$mdChipsCtrl.items', function () {ctrl.setupInputAria(); ctrl.setupWrapperAria();}); ctrl.$attrs.$observe('mdChipAppendDelay', function (newValue) {ctrl.chipAppendDelay = parseInt(newValue) || DEFAULT_CHIP_APPEND_DELAY;});}; MdChipsCtrl.prototype.setupInputAria = function () {var input = this.$element.find('input'); if (!input) {return;}input.attr('role', 'textbox'); input.attr('aria-multiline', true);}; MdChipsCtrl.prototype.setupWrapperAria = function () {var ctrl = this, wrapper = this.$element.find('md-chips-wrap'); if (this.items && this.items.length) {wrapper.attr('role', 'listbox'); this.contentIds = this.items.map(function () {return ctrl.wrapperId + '-chip-' + ctrl.$mdUtil.nextUid();}); wrapper.attr('aria-owns', this.contentIds.join(' '));}else {wrapper.removeAttr('role'); wrapper.removeAttr('aria-owns');}}; MdChipsCtrl.prototype.inputKeydown = function (event) {var chipBuffer = this.getChipBuffer(); if (this.autocompleteCtrl && event.isDefaultPrevented && event.isDefaultPrevented()) {return;}if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {if (this.getCursorPosition(event.target) !== 0) {return;}event.preventDefault(); event.stopPropagation(); if (this.items.length) {this.selectAndFocusChipSafe(this.items.length - 1);}return;}if (!this.separatorKeys || this.separatorKeys.length < 1) {this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];}if (this.separatorKeys.indexOf(event.keyCode) !== -1) {if ((this.autocompleteCtrl && this.requireMatch) || !chipBuffer) return; event.preventDefault(); if (this.hasMaxChipsReached()) return; this.appendChip(chipBuffer.trim()); this.resetChipBuffer(); return false;}}; MdChipsCtrl.prototype.getCursorPosition = function (element) {try {if (element.selectionStart === element.selectionEnd) {return element.selectionStart;}}catch (e) {if (!element.value) {return 0;}}}; MdChipsCtrl.prototype.updateChipContents = function (chipIndex, chipContents) {if (chipIndex >= 0 && chipIndex < this.items.length) {this.items[chipIndex] = chipContents; this.ngModelCtrl.$setDirty();}}; MdChipsCtrl.prototype.isEditingChip = function () {return !!this.$element[0].querySelector('._md-chip-editing');}; MdChipsCtrl.prototype.isRemovable = function () {if (!this.ngModelCtrl) {return false;}return this.readonly ? this.removable : angular.isDefined(this.removable) ? this.removable : true;}; MdChipsCtrl.prototype.chipKeydown = function (event) {if (this.getChipBuffer()) return; if (this.isEditingChip()) return; switch (event.keyCode) {case this.$mdConstant.KEY_CODE.BACKSPACE: case this.$mdConstant.KEY_CODE.DELETE: if (this.selectedChip < 0) return; event.preventDefault(); if (!this.isRemovable()) return; this.removeAndSelectAdjacentChip(this.selectedChip); break; case this.$mdConstant.KEY_CODE.LEFT_ARROW: event.preventDefault(); if (this.selectedChip < 0 || (this.readonly && this.selectedChip == 0)) {this.selectedChip = this.items.length;}if (this.items.length) this.selectAndFocusChipSafe(this.selectedChip - 1); break; case this.$mdConstant.KEY_CODE.RIGHT_ARROW: event.preventDefault(); this.selectAndFocusChipSafe(this.selectedChip + 1); break; case this.$mdConstant.KEY_CODE.ESCAPE: case this.$mdConstant.KEY_CODE.TAB: if (this.selectedChip < 0) return; event.preventDefault(); this.onFocus(); break;}}; MdChipsCtrl.prototype.getPlaceholder = function () {var useSecondary = this.items && this.items.length && (this.secondaryPlaceholder == '' || this.secondaryPlaceholder); return useSecondary ? this.secondaryPlaceholder : this.placeholder;}; MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function (index) {var self = this; var selIndex = self.getAdjacentChipIndex(index); var wrap = this.$element[0].querySelector('md-chips-wrap'); var chip = this.$element[0].querySelector('md-chip[index="' + index + '"]'); self.removeChip(index); self.$timeout(function () {self.$timeout(function () {self.selectAndFocusChipSafe(selIndex);});});}; MdChipsCtrl.prototype.resetSelectedChip = function () {this.selectedChip = -1; this.ariaTabIndex = null;}; MdChipsCtrl.prototype.getAdjacentChipIndex = function (index) {var len = this.items.length - 1; return len == 0 ? -1 : index == len ? index - 1 : index;}; MdChipsCtrl.prototype.appendChip = function (newChip) {this.shouldFocusLastChip = true; if (this.useTransformChip && this.transformChip) {var transformedChip = this.transformChip({$chip: newChip }); if (angular.isDefined(transformedChip)) {newChip = transformedChip;}}if (angular.isObject(newChip)) {var identical = this.items.some(function (item) {return angular.equals(newChip, item);}); if (identical) return;}if (newChip == null || this.items.indexOf(newChip) + 1) return; var length = this.items.push(newChip); var index = length - 1; this.ngModelCtrl.$setDirty(); this.validateModel(); if (this.useOnAdd && this.onAdd) {this.onAdd({$chip: newChip, $index: index });}}; MdChipsCtrl.prototype.useTransformChipExpression = function () {this.useTransformChip = true;}; MdChipsCtrl.prototype.useOnAddExpression = function () {this.useOnAdd = true;}; MdChipsCtrl.prototype.useOnRemoveExpression = function () {this.useOnRemove = true;}; MdChipsCtrl.prototype.useOnSelectExpression = function () {this.useOnSelect = true;}; MdChipsCtrl.prototype.getChipBuffer = function () {var chipBuffer = !this.userInputElement ? this.chipBuffer : this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value; return angular.isString(chipBuffer) ? chipBuffer : '';}; MdChipsCtrl.prototype.resetChipBuffer = function () {if (this.userInputElement) {if (this.userInputNgModelCtrl) {this.userInputNgModelCtrl.$setViewValue(''); this.userInputNgModelCtrl.$render();}else {this.userInputElement[0].value = '';}}else {this.chipBuffer = '';}}; MdChipsCtrl.prototype.hasMaxChipsReached = function () {if (angular.isString(this.maxChips)) this.maxChips = parseInt(this.maxChips, 10) || 0; return this.maxChips > 0 && this.items.length >= this.maxChips;}; MdChipsCtrl.prototype.validateModel = function () {this.ngModelCtrl.$setValidity('md-max-chips', !this.hasMaxChipsReached());}; MdChipsCtrl.prototype.removeChip = function (index) {var removed = this.items.splice(index, 1); this.ngModelCtrl.$setDirty(); this.validateModel(); if (removed && removed.length && this.useOnRemove && this.onRemove) {this.onRemove({$chip: removed[0], $index: index });}}; MdChipsCtrl.prototype.removeChipAndFocusInput = function (index) {this.removeChip(index); if (this.autocompleteCtrl) {this.autocompleteCtrl.hidden = true; this.$mdUtil.nextTick(this.onFocus.bind(this));}else {this.onFocus();}}; MdChipsCtrl.prototype.selectAndFocusChipSafe = function (index) {if (!this.items.length || index === -1) {return this.focusInput();}if (index >= this.items.length) {if (this.readonly) {index = 0;}else {return this.onFocus();}}index = Math.max(index, 0); index = Math.min(index, this.items.length - 1); this.selectChip(index); this.focusChip(index);}; MdChipsCtrl.prototype.focusLastChipThenInput = function () {var ctrl = this; ctrl.shouldFocusLastChip = false; ctrl.focusChip(this.items.length - 1); ctrl.$timeout(function () {ctrl.focusInput();}, ctrl.chipAppendDelay);}; MdChipsCtrl.prototype.focusInput = function () {this.selectChip(-1); this.onFocus();}; MdChipsCtrl.prototype.selectChip = function (index) {if (index >= -1 && index <= this.items.length) {this.selectedChip = index; if (this.useOnSelect && this.onSelect) {this.onSelect({$chip: this.items[index] });}}else {this.$log.warn('Selected Chip index out of bounds; ignoring.');}}; MdChipsCtrl.prototype.selectAndFocusChip = function (index) {this.selectChip(index); if (index != -1) {this.focusChip(index);}}; MdChipsCtrl.prototype.focusChip = function (index) {var chipContent = this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content'); this.ariaTabIndex = index; chipContent.focus();}; MdChipsCtrl.prototype.configureNgModel = function (ngModelCtrl) {this.ngModelCtrl = ngModelCtrl; var self = this; ngModelCtrl.$render = function () {self.items = self.ngModelCtrl.$viewValue;};}; MdChipsCtrl.prototype.onFocus = function () {var input = this.$element[0].querySelector('input'); input && input.focus(); this.resetSelectedChip();}; MdChipsCtrl.prototype.onInputFocus = function () {this.inputHasFocus = true; this.setupInputAria(); this.resetSelectedChip();}; MdChipsCtrl.prototype.onInputBlur = function () {this.inputHasFocus = false; if (this.shouldAddOnBlur()) {this.appendChip(this.getChipBuffer().trim()); this.resetChipBuffer();}}; MdChipsCtrl.prototype.configureUserInput = function (inputElement) {this.userInputElement = inputElement; var ngModelCtrl = inputElement.controller('ngModel'); if (ngModelCtrl != this.ngModelCtrl) {this.userInputNgModelCtrl = ngModelCtrl;}var scope = this.$scope; var ctrl = this; var scopeApplyFn = function (event, fn) {scope.$evalAsync(angular.bind(ctrl, fn, event));}; inputElement .attr({tabindex: 0 }) .on('keydown', function (event) {scopeApplyFn(event, ctrl.inputKeydown);}) .on('focus', function (event) {scopeApplyFn(event, ctrl.onInputFocus);}) .on('blur', function (event) {scopeApplyFn(event, ctrl.onInputBlur);});}; MdChipsCtrl.prototype.configureAutocomplete = function (ctrl) {if (ctrl) {this.autocompleteCtrl = ctrl; ctrl.registerSelectedItemWatcher( angular.bind(this, function (item) {if (item) {if (this.hasMaxChipsReached()) return; this.appendChip(item); this.resetChipBuffer();}}), ); this.$element.find('input').on('focus', angular.bind(this, this.onInputFocus)).on('blur', angular.bind(this, this.onInputBlur));}}; MdChipsCtrl.prototype.shouldAddOnBlur = function () {this.validateModel(); var chipBuffer = this.getChipBuffer().trim(); var isModelValid = this.ngModelCtrl.$valid; var isAutocompleteShowing = this.autocompleteCtrl && !this.autocompleteCtrl.hidden; if (this.userInputNgModelCtrl) {isModelValid = isModelValid && this.userInputNgModelCtrl.$valid;}return this.addOnBlur && !this.requireMatch && chipBuffer && isModelValid && !isAutocompleteShowing;}; MdChipsCtrl.prototype.hasFocus = function () {return this.inputHasFocus || this.selectedChip >= 0;}; MdChipsCtrl.prototype.contentIdFor = function (index) {return this.contentIds[index];};})(); (function () {'use strict'; MdChips.$inject = ['$mdTheming', '$mdUtil', '$compile', '$log', '$timeout', '$$mdSvgRegistry']; angular.module('material.components.chips').directive('mdChips', MdChips); var MD_CHIPS_TEMPLATE = '\ <md-chips-wrap\ id="{{$mdChipsCtrl.wrapperId}}"\ tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"\ ng-keydown="$mdChipsCtrl.chipKeydown($event)"\ ng-class="{\'md-focused\': $mdChipsCtrl.hasFocus(), \ \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,\ \'md-removable\': $mdChipsCtrl.isRemovable() }"\ aria-setsize="{{$mdChipsCtrl.items.length}}"\ class="md-chips">\ <span ng-if="$mdChipsCtrl.readonly" class="md-visually-hidden">\ {{$mdChipsCtrl.containerHint}}\ </span>\ <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\ index="{{$index}}"\ ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">\ <div class="md-chip-content"\ tabindex="{{$mdChipsCtrl.ariaTabIndex == $index ? 0 : -1}}"\ id="{{$mdChipsCtrl.contentIdFor($index)}}"\ role="option"\ aria-selected="{{$mdChipsCtrl.selectedChip == $index}}" \ aria-posinset="{{$index}}"\ ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"\ ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\ md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\ <div ng-if="$mdChipsCtrl.isRemovable()"\ class="md-chip-remove-container"\ tabindex="-1"\ md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\ </md-chip>\ <div class="md-chip-input-container" ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">\ <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\ </div>\ </md-chips-wrap>'; var CHIP_INPUT_TEMPLATE = '\ <input\ class="md-input"\ tabindex="0"\ aria-label="{{$mdChipsCtrl.inputAriaLabel}}" \ placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\ ng-model="$mdChipsCtrl.chipBuffer"\ ng-focus="$mdChipsCtrl.onInputFocus()"\ ng-blur="$mdChipsCtrl.onInputBlur()"\ ng-keydown="$mdChipsCtrl.inputKeydown($event)">'; var CHIP_DEFAULT_TEMPLATE = '\ <span>{{$chip}}</span>'; var CHIP_REMOVE_TEMPLATE = '\ <button\ class="md-chip-remove"\ ng-if="$mdChipsCtrl.isRemovable()"\ ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"\ type="button"\ tabindex="-1">\ <md-icon md-svg-src="{{$mdChipsCtrl.mdCloseIcon }}"></md-icon>\ <span class="md-visually-hidden">\ {{$mdChipsCtrl.deleteButtonLabel}}\ </span>\ </button>'; function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout, $$mdSvgRegistry) {var templates = getTemplates(); return {template: function (element, attrs) {attrs['$mdUserTemplate'] = element.clone(); return templates.chips;}, require: ['mdChips'], restrict: 'E', controller: 'MdChipsCtrl', controllerAs: '$mdChipsCtrl', bindToController: true, compile: compile, scope: {readonly: '=readonly', removable: '=mdRemovable', placeholder: '@', secondaryPlaceholder: '@', maxChips: '@mdMaxChips', transformChip: '&mdTransformChip', onAppend: '&mdOnAppend', onAdd: '&mdOnAdd', onRemove: '&mdOnRemove', onSelect: '&mdOnSelect', inputAriaLabel: '@', containerHint: '@', deleteHint: '@', deleteButtonLabel: '@', separatorKeys: '=?mdSeparatorKeys', requireMatch: '=?mdRequireMatch', chipAppendDelayString: '@?mdChipAppendDelay', }, }; function compile(element, attr) {var userTemplate = attr['$mdUserTemplate']; attr['$mdUserTemplate'] = null; var chipTemplate = getTemplateByQuery('md-chips>md-chip-template'); var chipRemoveSelector = $mdUtil .prefixer() .buildList('md-chip-remove') .map(function (attr) {return 'md-chips>*[' + attr + ']';}) .join(','); var chipRemoveTemplate = getTemplateByQuery(chipRemoveSelector) || templates.remove, chipContentsTemplate = chipTemplate || templates.default, chipInputTemplate = getTemplateByQuery('md-chips>md-autocomplete') || getTemplateByQuery('md-chips>input') || templates.input, staticChips = userTemplate.find('md-chip'); if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {$log.warn('invalid placement of md-chip-remove within md-chip-template.');}function getTemplateByQuery(query) {if (!attr.ngModel) return; var element = userTemplate[0].querySelector(query); return element && element.outerHTML;}return function postLink(scope, element, attrs, controllers) {$mdUtil.initOptionalProperties(scope, attr); $mdTheming(element); var mdChipsCtrl = controllers[0]; if (chipTemplate) {mdChipsCtrl.enableChipEdit = false;}mdChipsCtrl.chipContentsTemplate = chipContentsTemplate; mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate; mdChipsCtrl.chipInputTemplate = chipInputTemplate; mdChipsCtrl.mdCloseIcon = $$mdSvgRegistry.mdClose; element.attr({tabindex: -1 }).on('focus', function () {mdChipsCtrl.onFocus();}); if (attr.ngModel) {mdChipsCtrl.configureNgModel(element.controller('ngModel')); if (attrs.mdTransformChip) mdChipsCtrl.useTransformChipExpression(); if (attrs.mdOnAppend) mdChipsCtrl.useOnAppendExpression(); if (attrs.mdOnAdd) mdChipsCtrl.useOnAddExpression(); if (attrs.mdOnRemove) mdChipsCtrl.useOnRemoveExpression(); if (attrs.mdOnSelect) mdChipsCtrl.useOnSelectExpression(); if (chipInputTemplate != templates.input) {scope.$watch('$mdChipsCtrl.readonly', function (readonly) {if (!readonly) {$mdUtil.nextTick(function () {if (chipInputTemplate.indexOf('<md-autocomplete') === 0) {var autocompleteEl = element.find('md-autocomplete'); mdChipsCtrl.configureAutocomplete(autocompleteEl.controller('mdAutocomplete'));}mdChipsCtrl.configureUserInput(element.find('input'));});}});}$mdUtil.nextTick(function () {var input = element.find('input'); input && input.toggleClass('md-input', true);});}if (staticChips.length > 0) {var compiledStaticChips = $compile(staticChips.clone())(scope.$parent); $timeout(function () {element.find('md-chips-wrap').prepend(compiledStaticChips);});}};}function getTemplates() {return {chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE), input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE), default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE), remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE), };}}})(); (function () {'use strict'; angular.module('material.components.chips').controller('MdContactChipsCtrl', MdContactChipsCtrl); function MdContactChipsCtrl() {this.selectedItem = null; this.searchText = '';}MdContactChipsCtrl.prototype.queryContact = function (searchText) {return this.contactQuery({$query: searchText });}; MdContactChipsCtrl.prototype.itemName = function (item) {return item[this.contactName];};})(); (function () {'use strict'; MdContactChips.$inject = ['$mdTheming', '$mdUtil']; angular.module('material.components.chips').directive('mdContactChips', MdContactChips); var MD_CONTACT_CHIPS_TEMPLATE = '\ <md-chips class="md-contact-chips"\ ng-model="$mdContactChipsCtrl.contacts"\ md-require-match="$mdContactChipsCtrl.requireMatch"\ md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}" \ md-autocomplete-snap>\ <md-autocomplete\ md-menu-class="md-contact-chips-suggestions"\ md-selected-item="$mdContactChipsCtrl.selectedItem"\ md-search-text="$mdContactChipsCtrl.searchText"\ md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\ md-item-text="$mdContactChipsCtrl.itemName(item)"\ md-no-cache="true"\ md-min-length="$mdContactChipsCtrl.minLength"\ md-autoselect\ placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?\ $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\ <div class="md-contact-suggestion">\ <img \ ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\ alt="{{item[$mdContactChipsCtrl.contactName]}}"\ ng-if="item[$mdContactChipsCtrl.contactImage]" />\ <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\ md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\ {{item[$mdContactChipsCtrl.contactName]}}\ </span>\ <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\ </div>\ </md-autocomplete>\ <md-chip-template>\ <div class="md-contact-avatar">\ <img \ ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\ alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\ ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\ </div>\ <div class="md-contact-name">\ {{$chip[$mdContactChipsCtrl.contactName]}}\ </div>\ </md-chip-template>\ </md-chips>'; function MdContactChips($mdTheming, $mdUtil) {return {template: function (element, attrs) {return MD_CONTACT_CHIPS_TEMPLATE;}, restrict: 'E', controller: 'MdContactChipsCtrl', controllerAs: '$mdContactChipsCtrl', bindToController: true, compile: compile, scope: {contactQuery: '&mdContacts', placeholder: '@', secondaryPlaceholder: '@', contactName: '@mdContactName', contactImage: '@mdContactImage', contactEmail: '@mdContactEmail', contacts: '=ngModel', requireMatch: '=?mdRequireMatch', minLength: '=?mdMinLength', highlightFlags: '@?mdHighlightFlags', chipAppendDelay: '@?mdChipAppendDelay', }, }; function compile(element, attr) {return function postLink(scope, element, attrs, controllers) {var contactChipsController = controllers; $mdUtil.initOptionalProperties(scope, attr); $mdTheming(element); element.attr('tabindex', '-1'); attrs.$observe('mdChipAppendDelay', function (newValue) {contactChipsController.chipAppendDelay = newValue;});};}}})(); (function () {'use strict'; (function () {'use strict'; CalendarCtrl.$inject = ['$element', '$scope', '$$mdDateUtil', '$mdUtil', '$mdConstant', '$mdTheming', '$$rAF', '$attrs', '$mdDateLocale']; angular.module('material.components.datepicker').directive('mdCalendar', calendarDirective); function calendarDirective() {return {template: function (tElement, tAttr) {var extraAttrs = tAttr.hasOwnProperty('ngIf') ? '' : 'ng-if="calendarCtrl.isInitialized"'; var template = '' + '<div ng-switch="calendarCtrl.currentView" ' + extraAttrs + '>' + '<md-calendar-year ng-switch-when="year"></md-calendar-year>' + '<md-calendar-month ng-switch-default></md-calendar-month>' + '</div>'; return template;}, scope: {minDate: '=mdMinDate', maxDate: '=mdMaxDate', dateFilter: '=mdDateFilter', _currentView: '@mdCurrentView', }, require: ['ngModel', 'mdCalendar'], controller: CalendarCtrl, controllerAs: 'calendarCtrl', bindToController: true, link: function (scope, element, attrs, controllers) {var ngModelCtrl = controllers[0]; var mdCalendarCtrl = controllers[1]; mdCalendarCtrl.configureNgModel(ngModelCtrl);}, };}var FALLBACK_WIDTH = 340; var nextUniqueId = 0; function CalendarCtrl($element, $scope, $$mdDateUtil, $mdUtil, $mdConstant, $mdTheming, $$rAF, $attrs, $mdDateLocale) {$mdTheming($element); this.$element = $element; this.$scope = $scope; this.dateUtil = $$mdDateUtil; this.$mdUtil = $mdUtil; this.keyCode = $mdConstant.KEY_CODE; this.$$rAF = $$rAF; this.$mdDateLocale = $mdDateLocale; this.today = this.dateUtil.createDateAtMidnight(); this.ngModelCtrl = null; this.SELECTED_DATE_CLASS = 'md-calendar-selected-date'; this.TODAY_CLASS = 'md-calendar-date-today'; this.FOCUSED_DATE_CLASS = 'md-focus'; this.id = nextUniqueId++; this.displayDate = null; this.selectedDate = null; this.firstRenderableDate = null; this.lastRenderableDate = null; this.isInitialized = false; this.width = 0; this.scrollbarWidth = 0; if (!$attrs.tabindex) {$element.attr('tabindex', '-1');}var boundKeyHandler = angular.bind(this, this.handleKeyEvent); var handleKeyElement; if ($element.parent().hasClass('md-datepicker-calendar')) {handleKeyElement = angular.element(document.body);}else {handleKeyElement = $element;}handleKeyElement.on('keydown', boundKeyHandler); $scope.$on('$destroy', function () {handleKeyElement.off('keydown', boundKeyHandler);}); if (angular.version.major === 1 && angular.version.minor <= 4) {this.$onInit();}}CalendarCtrl.prototype.$onInit = function () {this.currentView = this._currentView || 'month'; var dateLocale = this.$mdDateLocale; if (this.minDate && this.minDate > dateLocale.firstRenderableDate) {this.firstRenderableDate = this.minDate;}else {this.firstRenderableDate = dateLocale.firstRenderableDate;}if (this.maxDate && this.maxDate < dateLocale.lastRenderableDate) {this.lastRenderableDate = this.maxDate;}else {this.lastRenderableDate = dateLocale.lastRenderableDate;}}; CalendarCtrl.prototype.configureNgModel = function (ngModelCtrl) {var self = this; self.ngModelCtrl = ngModelCtrl; self.$mdUtil.nextTick(function () {self.isInitialized = true;}); ngModelCtrl.$render = function () {var value = this.$viewValue; self.$scope.$broadcast('md-calendar-parent-changed', value); if (!self.selectedDate) {self.selectedDate = value;}if (!self.displayDate) {self.displayDate = self.selectedDate || self.today;}};}; CalendarCtrl.prototype.setNgModelValue = function (date) {var value = this.dateUtil.createDateAtMidnight(date); this.focus(value); this.$scope.$emit('md-calendar-change', value); this.ngModelCtrl.$setViewValue(value); this.ngModelCtrl.$render(); return value;}; CalendarCtrl.prototype.setCurrentView = function (newView, time) {var self = this; self.$mdUtil.nextTick(function () {self.currentView = newView; if (time) {self.displayDate = angular.isDate(time) ? time : new Date(time);}});}; CalendarCtrl.prototype.focus = function (date) {if (this.dateUtil.isValidDate(date)) {var previousFocus = this.$element[0].querySelector('.md-focus'); if (previousFocus) {previousFocus.classList.remove(this.FOCUSED_DATE_CLASS);}var cellId = this.getDateId(date, this.currentView); var cell = document.getElementById(cellId); if (cell) {cell.classList.add(this.FOCUSED_DATE_CLASS); cell.focus(); this.displayDate = date;}}else {var rootElement = this.$element[0].querySelector('[ng-switch]'); if (rootElement) {rootElement.focus();}}}; CalendarCtrl.prototype.getActionFromKeyEvent = function (event) {var keyCode = this.keyCode; switch (event.which) {case keyCode.ENTER: return 'select'; case keyCode.RIGHT_ARROW: return 'move-right'; case keyCode.LEFT_ARROW: return 'move-left'; case keyCode.DOWN_ARROW: return event.metaKey ? 'move-page-down' : 'move-row-down'; case keyCode.UP_ARROW: return event.metaKey ? 'move-page-up' : 'move-row-up'; case keyCode.PAGE_DOWN: return 'move-page-down'; case keyCode.PAGE_UP: return 'move-page-up'; case keyCode.HOME: return 'start'; case keyCode.END: return 'end'; default: return null;}}; CalendarCtrl.prototype.handleKeyEvent = function (event) {var self = this; this.$scope.$apply(function () {if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {self.$scope.$emit('md-calendar-close'); if (event.which == self.keyCode.TAB) {event.preventDefault();}return;}var action = self.getActionFromKeyEvent(event); if (action) {event.preventDefault(); event.stopPropagation(); self.$scope.$broadcast('md-calendar-parent-action', action);}});}; CalendarCtrl.prototype.hideVerticalScrollbar = function (childCtrl) {var self = this; var element = childCtrl.$element[0]; var scrollMask = element.querySelector('.md-calendar-scroll-mask'); if (self.width > 0) {setWidth();}else {self.$$rAF(function () {var scroller = childCtrl.calendarScroller; self.scrollbarWidth = scroller.offsetWidth - scroller.clientWidth; self.width = element.querySelector('table').offsetWidth; setWidth();});}function setWidth() {var width = self.width || FALLBACK_WIDTH; var scrollbarWidth = self.scrollbarWidth; var scroller = childCtrl.calendarScroller; scrollMask.style.width = width + 'px'; scroller.style.width = width + scrollbarWidth + 'px'; scroller.style.paddingRight = scrollbarWidth + 'px';}}; CalendarCtrl.prototype.getDateId = function (date, namespace) {if (!namespace) {throw new Error('A namespace for the date id has to be specified.');}return ['md', this.id, namespace, date.getFullYear(), date.getMonth(), date.getDate()].join('-');}; CalendarCtrl.prototype.updateVirtualRepeat = function () {var scope = this.$scope; var virtualRepeatResizeListener = scope.$on('$md-resize-enable', function () {if (!scope.$$phase) {scope.$apply();}virtualRepeatResizeListener();});};})();})(); (function () {'use strict'; (function () {'use strict'; CalendarMonthCtrl.$inject = ['$element', '$scope', '$animate', '$q', '$$mdDateUtil', '$mdDateLocale']; angular.module('material.components.datepicker').directive('mdCalendarMonth', calendarDirective); var TBODY_HEIGHT = 265; var TBODY_SINGLE_ROW_HEIGHT = 45; function calendarDirective() {return {template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' + '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container" ' + 'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody ' + 'md-calendar-month-body ' + 'role="rowgroup" ' + 'md-virtual-repeat="i in monthCtrl.items" ' + 'md-month-offset="$index" ' + 'class="md-calendar-month" ' + 'md-start-index="monthCtrl.getSelectedMonthIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '">' + '<tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + 'px\'"></tr>' + '</tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>', require: ['^^mdCalendar', 'mdCalendarMonth'], controller: CalendarMonthCtrl, controllerAs: 'monthCtrl', bindToController: true, link: function (scope, element, attrs, controllers) {var calendarCtrl = controllers[0]; var monthCtrl = controllers[1]; monthCtrl.initialize(calendarCtrl);}, };}function CalendarMonthCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdDateLocale) {this.$element = $element; this.$scope = $scope; this.$animate = $animate; this.$q = $q; this.dateUtil = $$mdDateUtil; this.dateLocale = $mdDateLocale; this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller'); this.isInitialized = false; this.isMonthTransitionInProgress = false; var self = this; this.cellClickHandler = function () {var timestamp = $$mdDateUtil.getTimestampFromNode(this); self.$scope.$apply(function () {self.calendarCtrl.setNgModelValue(timestamp);});}; this.headerClickHandler = function () {self.calendarCtrl.setCurrentView('year', $$mdDateUtil.getTimestampFromNode(this));};}CalendarMonthCtrl.prototype.initialize = function (calendarCtrl) {this.items = {length: this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 2, }; this.calendarCtrl = calendarCtrl; this.attachScopeListeners(); calendarCtrl.updateVirtualRepeat(); calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();}; CalendarMonthCtrl.prototype.getSelectedMonthIndex = function () {var calendarCtrl = this.calendarCtrl; return this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);}; CalendarMonthCtrl.prototype.changeSelectedDate = function (date) {var self = this; var calendarCtrl = self.calendarCtrl; var previousSelectedDate = calendarCtrl.selectedDate; calendarCtrl.selectedDate = date; this.changeDisplayDate(date).then(function () {var selectedDateClass = calendarCtrl.SELECTED_DATE_CLASS; var namespace = 'month'; if (previousSelectedDate) {var prevDateCell = document.getElementById(calendarCtrl.getDateId(previousSelectedDate, namespace)); if (prevDateCell) {prevDateCell.classList.remove(selectedDateClass); prevDateCell.setAttribute('aria-selected', 'false');}}if (date) {var dateCell = document.getElementById(calendarCtrl.getDateId(date, namespace)); if (dateCell) {dateCell.classList.add(selectedDateClass); dateCell.setAttribute('aria-selected', 'true');}}});}; CalendarMonthCtrl.prototype.changeDisplayDate = function (date) {if (!this.isInitialized) {this.buildWeekHeader(); this.calendarCtrl.hideVerticalScrollbar(this); this.isInitialized = true; return this.$q.when();}if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {return this.$q.when();}this.isMonthTransitionInProgress = true; var animationPromise = this.animateDateChange(date); this.calendarCtrl.displayDate = date; var self = this; animationPromise.then(function () {self.isMonthTransitionInProgress = false;}); return animationPromise;}; CalendarMonthCtrl.prototype.animateDateChange = function (date) {if (this.dateUtil.isValidDate(date)) {var monthDistance = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, date); this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;}return this.$q.when();}; CalendarMonthCtrl.prototype.buildWeekHeader = function () {var firstDayOfWeek = this.dateLocale.firstDayOfWeek; var shortDays = this.dateLocale.shortDays; var row = document.createElement('tr'); for (var i = 0; i < 7; i++) {var th = document.createElement('th'); th.textContent = shortDays[(i + firstDayOfWeek) % 7]; row.appendChild(th);}this.$element.find('thead').append(row);}; CalendarMonthCtrl.prototype.attachScopeListeners = function () {var self = this; self.$scope.$on('md-calendar-parent-changed', function (event, value) {self.changeSelectedDate(value);}); self.$scope.$on('md-calendar-parent-action', angular.bind(this, this.handleKeyEvent));}; CalendarMonthCtrl.prototype.handleKeyEvent = function (event, action) {var calendarCtrl = this.calendarCtrl; var displayDate = calendarCtrl.displayDate; if (action === 'select') {calendarCtrl.setNgModelValue(displayDate);}else {var date = null; var dateUtil = this.dateUtil; switch (action) {case 'move-right': date = dateUtil.incrementDays(displayDate, 1); break; case 'move-left': date = dateUtil.incrementDays(displayDate, -1); break; case 'move-page-down': date = dateUtil.incrementMonths(displayDate, 1); break; case 'move-page-up': date = dateUtil.incrementMonths(displayDate, -1); break; case 'move-row-down': date = dateUtil.incrementDays(displayDate, 7); break; case 'move-row-up': date = dateUtil.incrementDays(displayDate, -7); break; case 'start': date = dateUtil.getFirstDateOfMonth(displayDate); break; case 'end': date = dateUtil.getLastDateOfMonth(displayDate); break;}if (date) {date = this.dateUtil.clampDate(date, calendarCtrl.minDate, calendarCtrl.maxDate); this.changeDisplayDate(date).then(function () {calendarCtrl.focus(date);});}}};})();})(); (function () {'use strict'; (function () {'use strict'; mdCalendarMonthBodyDirective.$inject = ['$compile', '$$mdSvgRegistry']; CalendarMonthBodyCtrl.$inject = ['$element', '$$mdDateUtil', '$mdDateLocale']; angular.module('material.components.datepicker').directive('mdCalendarMonthBody', mdCalendarMonthBodyDirective); function mdCalendarMonthBodyDirective($compile, $$mdSvgRegistry) {var ARROW_ICON = $compile('<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon>')({})[0]; return {require: ['^^mdCalendar', '^^mdCalendarMonth', 'mdCalendarMonthBody'], scope: {offset: '=mdMonthOffset' }, controller: CalendarMonthBodyCtrl, controllerAs: 'mdMonthBodyCtrl', bindToController: true, link: function (scope, element, attrs, controllers) {var calendarCtrl = controllers[0]; var monthCtrl = controllers[1]; var monthBodyCtrl = controllers[2]; monthBodyCtrl.calendarCtrl = calendarCtrl; monthBodyCtrl.monthCtrl = monthCtrl; monthBodyCtrl.arrowIcon = ARROW_ICON.cloneNode(true); scope.$watch( function () {return monthBodyCtrl.offset;}, function (offset) {if (angular.isNumber(offset)) {monthBodyCtrl.generateContent();}}, );}, };}function CalendarMonthBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {this.$element = $element; this.dateUtil = $$mdDateUtil; this.dateLocale = $mdDateLocale; this.monthCtrl = null; this.calendarCtrl = null; this.offset = null; this.focusAfterAppend = null;}CalendarMonthBodyCtrl.prototype.generateContent = function () {var date = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset); this.$element.empty().append(this.buildCalendarForMonth(date)); if (this.focusAfterAppend) {this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS); this.focusAfterAppend.focus(); this.focusAfterAppend = null;}}; CalendarMonthBodyCtrl.prototype.buildDateCell = function (opt_date) {var monthCtrl = this.monthCtrl; var calendarCtrl = this.calendarCtrl; var cell = document.createElement('td'); cell.tabIndex = -1; cell.classList.add('md-calendar-date'); cell.setAttribute('role', 'gridcell'); if (opt_date) {cell.setAttribute('tabindex', '-1'); cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date)); cell.id = calendarCtrl.getDateId(opt_date, 'month'); cell.setAttribute('data-timestamp', opt_date.getTime()); if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {cell.classList.add(calendarCtrl.TODAY_CLASS);}if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS); cell.setAttribute('aria-selected', 'true');}var cellText = this.dateLocale.dates[opt_date.getDate()]; if (this.isDateEnabled(opt_date)) {var selectionIndicator = document.createElement('span'); selectionIndicator.classList.add('md-calendar-date-selection-indicator'); selectionIndicator.textContent = cellText; cell.appendChild(selectionIndicator); cell.addEventListener('click', monthCtrl.cellClickHandler); if (calendarCtrl.displayDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.displayDate)) {this.focusAfterAppend = cell;}}else {cell.classList.add('md-calendar-date-disabled'); cell.textContent = cellText;}}return cell;}; CalendarMonthBodyCtrl.prototype.isDateEnabled = function (opt_date) {return ( this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date)) );}; CalendarMonthBodyCtrl.prototype.buildDateRow = function (rowNumber) {var row = document.createElement('tr'); row.setAttribute('role', 'row'); row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber)); return row;}; CalendarMonthBodyCtrl.prototype.buildCalendarForMonth = function (opt_dateInMonth) {var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date(); var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date); var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth); var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date); var monthBody = document.createDocumentFragment(); var rowNumber = 1; var row = this.buildDateRow(rowNumber); monthBody.appendChild(row); var isFinalMonth = this.offset === this.monthCtrl.items.length - 1; var blankCellOffset = 0; var monthLabelCell = document.createElement('td'); var monthLabelCellContent = document.createElement('span'); monthLabelCellContent.textContent = this.dateLocale.monthHeaderFormatter(date); monthLabelCell.appendChild(monthLabelCellContent); monthLabelCell.classList.add('md-calendar-month-label'); if (this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate) {monthLabelCell.classList.add('md-calendar-month-label-disabled');}else {monthLabelCell.addEventListener('click', this.monthCtrl.headerClickHandler); monthLabelCell.setAttribute('data-timestamp', firstDayOfMonth.getTime()); monthLabelCell.setAttribute('aria-label', this.dateLocale.monthFormatter(date)); monthLabelCell.appendChild(this.arrowIcon.cloneNode(true));}if (firstDayOfTheWeek <= 2) {monthLabelCell.setAttribute('colspan', '7'); var monthLabelRow = this.buildDateRow(); monthLabelRow.appendChild(monthLabelCell); monthBody.insertBefore(monthLabelRow, row); if (isFinalMonth) {return monthBody;}}else {blankCellOffset = 3; monthLabelCell.setAttribute('colspan', '3'); row.appendChild(monthLabelCell);}for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {row.appendChild(this.buildDateCell());}var dayOfWeek = firstDayOfTheWeek; var iterationDate = firstDayOfMonth; for (var d = 1; d <= numberOfDaysInMonth; d++) {if (dayOfWeek === 7) {if (isFinalMonth) {return monthBody;}dayOfWeek = 0; rowNumber++; row = this.buildDateRow(rowNumber); monthBody.appendChild(row);}iterationDate.setDate(d); var cell = this.buildDateCell(iterationDate); row.appendChild(cell); dayOfWeek++;}while (row.childNodes.length < 7) {row.appendChild(this.buildDateCell());}while (monthBody.childNodes.length < 6) {var whitespaceRow = this.buildDateRow(); for (var j = 0; j < 7; j++) {whitespaceRow.appendChild(this.buildDateCell());}monthBody.appendChild(whitespaceRow);}return monthBody;}; CalendarMonthBodyCtrl.prototype.getLocaleDay_ = function (date) {return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;};})();})(); (function () {'use strict'; (function () {'use strict'; CalendarYearCtrl.$inject = ['$element', '$scope', '$animate', '$q', '$$mdDateUtil']; angular.module('material.components.datepicker').directive('mdCalendarYear', calendarDirective); var TBODY_HEIGHT = 88; function calendarDirective() {return {template: '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody ' + 'md-calendar-year-body ' + 'role="rowgroup" ' + 'md-virtual-repeat="i in yearCtrl.items" ' + 'md-year-offset="$index" class="md-calendar-year" ' + 'md-start-index="yearCtrl.getFocusedYearIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '">' + '<tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + 'px\'"></tr>' + '</tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>', require: ['^^mdCalendar', 'mdCalendarYear'], controller: CalendarYearCtrl, controllerAs: 'yearCtrl', bindToController: true, link: function (scope, element, attrs, controllers) {var calendarCtrl = controllers[0]; var yearCtrl = controllers[1]; yearCtrl.initialize(calendarCtrl);}, };}function CalendarYearCtrl($element, $scope, $animate, $q, $$mdDateUtil) {this.$element = $element; this.$scope = $scope; this.$animate = $animate; this.$q = $q; this.dateUtil = $$mdDateUtil; this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller'); this.isInitialized = false; this.isMonthTransitionInProgress = false; var self = this; this.cellClickHandler = function () {self.calendarCtrl.setCurrentView('month', $$mdDateUtil.getTimestampFromNode(this));};}CalendarYearCtrl.prototype.initialize = function (calendarCtrl) {this.items = {length: this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 1, }; this.calendarCtrl = calendarCtrl; this.attachScopeListeners(); calendarCtrl.updateVirtualRepeat(); calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();}; CalendarYearCtrl.prototype.getFocusedYearIndex = function () {var calendarCtrl = this.calendarCtrl; return this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);}; CalendarYearCtrl.prototype.changeDate = function (date) {if (!this.isInitialized) {this.calendarCtrl.hideVerticalScrollbar(this); this.isInitialized = true; return this.$q.when();}else if (this.dateUtil.isValidDate(date) && !this.isMonthTransitionInProgress) {var self = this; var animationPromise = this.animateDateChange(date); self.isMonthTransitionInProgress = true; self.calendarCtrl.displayDate = date; return animationPromise.then(function () {self.isMonthTransitionInProgress = false;});}}; CalendarYearCtrl.prototype.animateDateChange = function (date) {if (this.dateUtil.isValidDate(date)) {var monthDistance = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, date); this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;}return this.$q.when();}; CalendarYearCtrl.prototype.handleKeyEvent = function (event, action) {var calendarCtrl = this.calendarCtrl; var displayDate = calendarCtrl.displayDate; if (action === 'select') {this.changeDate(displayDate).then(function () {calendarCtrl.setCurrentView('month', displayDate); calendarCtrl.focus(displayDate);});}else {var date = null; var dateUtil = this.dateUtil; switch (action) {case 'move-right': date = dateUtil.incrementMonths(displayDate, 1); break; case 'move-left': date = dateUtil.incrementMonths(displayDate, -1); break; case 'move-row-down': date = dateUtil.incrementMonths(displayDate, 6); break; case 'move-row-up': date = dateUtil.incrementMonths(displayDate, -6); break;}if (date) {var min = calendarCtrl.minDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.minDate) : null; var max = calendarCtrl.maxDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.maxDate) : null; date = dateUtil.getFirstDateOfMonth(this.dateUtil.clampDate(date, min, max)); this.changeDate(date).then(function () {calendarCtrl.focus(date);});}}}; CalendarYearCtrl.prototype.attachScopeListeners = function () {var self = this; self.$scope.$on('md-calendar-parent-changed', function (event, value) {self.changeDate(value);}); self.$scope.$on('md-calendar-parent-action', angular.bind(self, self.handleKeyEvent));};})();})(); (function () {'use strict'; (function () {'use strict'; CalendarYearBodyCtrl.$inject = ['$element', '$$mdDateUtil', '$mdDateLocale']; angular.module('material.components.datepicker').directive('mdCalendarYearBody', mdCalendarYearDirective); function mdCalendarYearDirective() {return {require: ['^^mdCalendar', '^^mdCalendarYear', 'mdCalendarYearBody'], scope: {offset: '=mdYearOffset' }, controller: CalendarYearBodyCtrl, controllerAs: 'mdYearBodyCtrl', bindToController: true, link: function (scope, element, attrs, controllers) {var calendarCtrl = controllers[0]; var yearCtrl = controllers[1]; var yearBodyCtrl = controllers[2]; yearBodyCtrl.calendarCtrl = calendarCtrl; yearBodyCtrl.yearCtrl = yearCtrl; scope.$watch( function () {return yearBodyCtrl.offset;}, function (offset) {if (angular.isNumber(offset)) {yearBodyCtrl.generateContent();}}, );}, };}function CalendarYearBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {this.$element = $element; this.dateUtil = $$mdDateUtil; this.dateLocale = $mdDateLocale; this.calendarCtrl = null; this.yearCtrl = null; this.offset = null; this.focusAfterAppend = null;}CalendarYearBodyCtrl.prototype.generateContent = function () {var date = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset); this.$element.empty().append(this.buildCalendarForYear(date)); if (this.focusAfterAppend) {this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS); this.focusAfterAppend.focus(); this.focusAfterAppend = null;}}; CalendarYearBodyCtrl.prototype.buildMonthCell = function (year, month) {var calendarCtrl = this.calendarCtrl; var yearCtrl = this.yearCtrl; var cell = this.buildBlankCell(); var firstOfMonth = new Date(year, month, 1); cell.setAttribute('aria-label', this.dateLocale.monthFormatter(firstOfMonth)); cell.id = calendarCtrl.getDateId(firstOfMonth, 'year'); cell.setAttribute('data-timestamp', firstOfMonth.getTime()); if (this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.today)) {cell.classList.add(calendarCtrl.TODAY_CLASS);}if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.selectedDate)) {cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS); cell.setAttribute('aria-selected', 'true');}var cellText = this.dateLocale.shortMonths[month]; if (this.dateUtil.isMonthWithinRange(firstOfMonth, calendarCtrl.minDate, calendarCtrl.maxDate)) {var selectionIndicator = document.createElement('span'); selectionIndicator.classList.add('md-calendar-date-selection-indicator'); selectionIndicator.textContent = cellText; cell.appendChild(selectionIndicator); cell.addEventListener('click', yearCtrl.cellClickHandler); if (calendarCtrl.displayDate && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.displayDate)) {this.focusAfterAppend = cell;}}else {cell.classList.add('md-calendar-date-disabled'); cell.textContent = cellText;}return cell;}; CalendarYearBodyCtrl.prototype.buildBlankCell = function () {var cell = document.createElement('td'); cell.tabIndex = -1; cell.classList.add('md-calendar-date'); cell.setAttribute('role', 'gridcell'); cell.setAttribute('tabindex', '-1'); return cell;}; CalendarYearBodyCtrl.prototype.buildCalendarForYear = function (date) {var year = date.getFullYear(); var yearBody = document.createDocumentFragment(); var monthCell, i; var firstRow = document.createElement('tr'); var labelCell = document.createElement('td'); labelCell.className = 'md-calendar-month-label'; labelCell.textContent = year; firstRow.appendChild(labelCell); for (i = 0; i < 6; i++) {firstRow.appendChild(this.buildMonthCell(year, i));}yearBody.appendChild(firstRow); var secondRow = document.createElement('tr'); secondRow.appendChild(this.buildBlankCell()); for (i = 6; i < 12; i++) {secondRow.appendChild(this.buildMonthCell(year, i));}yearBody.appendChild(secondRow); return yearBody;};})();})(); (function () {'use strict'; (function () {'use strict'; angular.module('material.components.datepicker').config([ '$provide', function ($provide) {function DateLocaleProvider() {this.months = null; this.shortMonths = null; this.days = null; this.shortDays = null; this.dates = null; this.firstDayOfWeek = 0; this.formatDate = null; this.parseDate = null; this.monthHeaderFormatter = null; this.weekNumberFormatter = null; this.longDateFormatter = null; this.msgCalendar = ''; this.msgOpenCalendar = '';}DateLocaleProvider.prototype.$get = function ($locale, $filter) {function defaultFormatDate(date, timezone) {if (!date) {return '';}var localeTime = date.toLocaleTimeString(); var formatDate = date; if (date.getHours() === 0 && (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);}return $filter('date')(formatDate, 'M/d/yyyy', timezone);}function defaultParseDate(dateString) {return new Date(dateString);}function defaultIsDateComplete(dateString) {dateString = dateString.trim(); var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/; return re.test(dateString);}function defaultMonthHeaderFormatter(date) {return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();}function defaultMonthFormatter(date) {return service.months[date.getMonth()] + ' ' + date.getFullYear();}function defaultWeekNumberFormatter(number) {return 'Week ' + number;}function defaultLongDateFormatter(date) {return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(' ');}var defaultShortDays = $locale.DATETIME_FORMATS.SHORTDAY.map(function (day) {return day.substring(0, 1);}); var defaultDates = Array(32); for (var i = 1; i <= 31; i++) {defaultDates[i] = i;}var defaultMsgCalendar = 'Calendar'; var defaultMsgOpenCalendar = 'Open calendar'; var defaultFirstRenderableDate = new Date(1880, 0, 1); var defaultLastRendereableDate = new Date(defaultFirstRenderableDate.getFullYear() + 250, 0, 1); var service = {months: this.months || $locale.DATETIME_FORMATS.MONTH, shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH, days: this.days || $locale.DATETIME_FORMATS.DAY, shortDays: this.shortDays || defaultShortDays, dates: this.dates || defaultDates, firstDayOfWeek: this.firstDayOfWeek || 0, formatDate: this.formatDate || defaultFormatDate, parseDate: this.parseDate || defaultParseDate, isDateComplete: this.isDateComplete || defaultIsDateComplete, monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter, monthFormatter: this.monthFormatter || defaultMonthFormatter, weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter, longDateFormatter: this.longDateFormatter || defaultLongDateFormatter, msgCalendar: this.msgCalendar || defaultMsgCalendar, msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar, firstRenderableDate: this.firstRenderableDate || defaultFirstRenderableDate, lastRenderableDate: this.lastRenderableDate || defaultLastRendereableDate, }; return service;}; DateLocaleProvider.prototype.$get.$inject = ['$locale', '$filter']; $provide.provider('$mdDateLocale', new DateLocaleProvider());}, ]);})();})(); (function () {'use strict'; (function () {'use strict'; angular.module('material.components.datepicker').factory('$$mdDateUtil', function () {return {getFirstDateOfMonth: getFirstDateOfMonth, getNumberOfDaysInMonth: getNumberOfDaysInMonth, getDateInNextMonth: getDateInNextMonth, getDateInPreviousMonth: getDateInPreviousMonth, isInNextMonth: isInNextMonth, isInPreviousMonth: isInPreviousMonth, getDateMidpoint: getDateMidpoint, isSameMonthAndYear: isSameMonthAndYear, getWeekOfMonth: getWeekOfMonth, incrementDays: incrementDays, incrementMonths: incrementMonths, getLastDateOfMonth: getLastDateOfMonth, isSameDay: isSameDay, getMonthDistance: getMonthDistance, isValidDate: isValidDate, setDateTimeToMidnight: setDateTimeToMidnight, createDateAtMidnight: createDateAtMidnight, isDateWithinRange: isDateWithinRange, incrementYears: incrementYears, getYearDistance: getYearDistance, clampDate: clampDate, getTimestampFromNode: getTimestampFromNode, isMonthWithinRange: isMonthWithinRange, }; function getFirstDateOfMonth(date) {return new Date(date.getFullYear(), date.getMonth(), 1);}function getNumberOfDaysInMonth(date) {return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();}function getDateInNextMonth(date) {return new Date(date.getFullYear(), date.getMonth() + 1, 1);}function getDateInPreviousMonth(date) {return new Date(date.getFullYear(), date.getMonth() - 1, 1);}function isSameMonthAndYear(d1, d2) {return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();}function isSameDay(d1, d2) {return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);}function isInNextMonth(startDate, endDate) {var nextMonth = getDateInNextMonth(startDate); return isSameMonthAndYear(nextMonth, endDate);}function isInPreviousMonth(startDate, endDate) {var previousMonth = getDateInPreviousMonth(startDate); return isSameMonthAndYear(endDate, previousMonth);}function getDateMidpoint(d1, d2) {return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);}function getWeekOfMonth(date) {var firstDayOfMonth = getFirstDateOfMonth(date); return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);}function incrementDays(date, numberOfDays) {return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);}function incrementMonths(date, numberOfMonths) {var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1); var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth); if (numberOfDaysInMonth < date.getDate()) {dateInTargetMonth.setDate(numberOfDaysInMonth);}else {dateInTargetMonth.setDate(date.getDate());}return dateInTargetMonth;}function getMonthDistance(start, end) {return 12 * (end.getFullYear() - start.getFullYear()) + (end.getMonth() - start.getMonth());}function getLastDateOfMonth(date) {return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));}function isValidDate(date) {return date && date.getTime && !isNaN(date.getTime());}function setDateTimeToMidnight(date) {if (isValidDate(date)) {date.setHours(0, 0, 0, 0);}}function createDateAtMidnight(opt_value) {var date; if (angular.isUndefined(opt_value)) {date = new Date();}else {date = new Date(opt_value);}setDateTimeToMidnight(date); return date;}function isDateWithinRange(date, minDate, maxDate) {var dateAtMidnight = createDateAtMidnight(date); var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null; var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null; return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);}function incrementYears(date, numberOfYears) {return incrementMonths(date, numberOfYears * 12);}function getYearDistance(start, end) {return end.getFullYear() - start.getFullYear();}function clampDate(date, minDate, maxDate) {var boundDate = date; if (minDate && date < minDate) {boundDate = new Date(minDate.getTime());}if (maxDate && date > maxDate) {boundDate = new Date(maxDate.getTime());}return boundDate;}function getTimestampFromNode(node) {if (node && node.hasAttribute('data-timestamp')) {return Number(node.getAttribute('data-timestamp'));}}function isMonthWithinRange(date, minDate, maxDate) {var month = date.getMonth(); var year = date.getFullYear(); return ( (!minDate || minDate.getFullYear() < year || minDate.getMonth() <= month) && (!maxDate || maxDate.getFullYear() > year || maxDate.getMonth() >= month) );}});})();})(); (function () {'use strict'; (function () {'use strict'; DatePickerCtrl.$inject = [ '$scope', '$element', '$attrs', '$window', '$mdConstant', '$mdTheming', '$mdUtil', '$mdDateLocale', '$$mdDateUtil', '$$rAF', '$filter', ]; datePickerDirective.$inject = ['$$mdSvgRegistry', '$mdUtil', '$mdAria', 'inputDirective']; angular.module('material.components.datepicker').directive('mdDatepicker', datePickerDirective); function datePickerDirective($$mdSvgRegistry, $mdUtil, $mdAria, inputDirective) {return {template: function (tElement, tAttrs) {var hiddenIcons = tAttrs.mdHideIcons; var ariaLabelValue = tAttrs.ariaLabel || tAttrs.mdPlaceholder; var calendarButton = hiddenIcons === 'all' || hiddenIcons === 'calendar' ? '' : '<md-button class="md-datepicker-button md-icon-button" type="button" ' + 'tabindex="-1" aria-hidden="true" ' + 'ng-click="ctrl.openCalendarPane($event)">' + '<md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" ' + 'md-svg-src="' + $$mdSvgRegistry.mdCalendar + '"></md-icon>' + '</md-button>'; var triangleButton = ''; if (hiddenIcons !== 'all' && hiddenIcons !== 'triangle') {triangleButton = '' + '<md-button type="button" md-no-ink ' + 'class="md-datepicker-triangle-button md-icon-button" ' + 'ng-click="ctrl.openCalendarPane($event)" ' + 'aria-label="{{::ctrl.locale.msgOpenCalendar}}">' + '<div class="md-datepicker-expand-triangle"></div>' + '</md-button>'; tElement.addClass(HAS_TRIANGLE_ICON_CLASS);}return ( calendarButton + '<div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' + '<input ' + (ariaLabelValue ? 'aria-label="' + ariaLabelValue + '" ' : '') + 'class="md-datepicker-input" ' + 'aria-haspopup="true" ' + 'aria-expanded="{{ctrl.isCalendarOpen}}" ' + 'ng-focus="ctrl.setFocused(true)" ' + 'ng-blur="ctrl.setFocused(false)"> ' + triangleButton + '</div>' + '<div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}">' + '<div class="md-datepicker-input-mask">' + '<div class="md-datepicker-input-mask-opaque"></div>' + '</div>' + '<div class="md-datepicker-calendar">' + '<md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" ' + 'md-current-view="{{::ctrl.currentView}}"' + 'md-min-date="ctrl.minDate"' + 'md-max-date="ctrl.maxDate"' + 'md-date-filter="ctrl.dateFilter"' + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' + '</md-calendar>' + '</div>' + '</div>' );}, require: ['ngModel', 'mdDatepicker', '?^mdInputContainer', '?^form'], scope: {minDate: '=mdMinDate', maxDate: '=mdMaxDate', placeholder: '@mdPlaceholder', currentView: '@mdCurrentView', dateFilter: '=mdDateFilter', isOpen: '=?mdIsOpen', debounceInterval: '=mdDebounceInterval', dateLocale: '=mdDateLocale', }, controller: DatePickerCtrl, controllerAs: 'ctrl', bindToController: true, link: function (scope, element, attr, controllers) {var ngModelCtrl = controllers[0]; var mdDatePickerCtrl = controllers[1]; var mdInputContainer = controllers[2]; var parentForm = controllers[3]; var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk); mdDatePickerCtrl.configureNgModel(ngModelCtrl, mdInputContainer, inputDirective); if (mdInputContainer) {var spacer = element[0].querySelector('.md-errors-spacer'); if (spacer) {element.after(angular.element('<div>').append(spacer));}mdInputContainer.setHasPlaceholder(attr.mdPlaceholder); mdInputContainer.input = element; mdInputContainer.element .addClass(INPUT_CONTAINER_CLASS) .toggleClass(HAS_CALENDAR_ICON_CLASS, attr.mdHideIcons !== 'calendar' && attr.mdHideIcons !== 'all'); if (!mdInputContainer.label) {$mdAria.expect(element, 'aria-label', attr.mdPlaceholder);}else if (!mdNoAsterisk) {attr.$observe('required', function (value) {mdInputContainer.label.toggleClass('md-required', !!value);});}scope.$watch( mdInputContainer.isErrorGetter || function () {return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (parentForm && parentForm.$submitted));}, mdInputContainer.setInvalid, );}else if (parentForm) {var parentSubmittedWatcher = scope.$watch( function () {return parentForm.$submitted;}, function (isSubmitted) {if (isSubmitted) {mdDatePickerCtrl.updateErrorState(); parentSubmittedWatcher();}}, );}}, };}var EXTRA_INPUT_SIZE = 3; var INVALID_CLASS = 'md-datepicker-invalid'; var OPEN_CLASS = 'md-datepicker-open'; var INPUT_CONTAINER_CLASS = '_md-datepicker-floating-label'; var HAS_CALENDAR_ICON_CLASS = '_md-datepicker-has-calendar-icon'; var HAS_TRIANGLE_ICON_CLASS = '_md-datepicker-has-triangle-icon'; var DEFAULT_DEBOUNCE_INTERVAL = 500; var CALENDAR_PANE_HEIGHT = 368; var CALENDAR_PANE_WIDTH = 360; var IS_MOBILE_REGEX = /ipad|iphone|ipod|android/i; function DatePickerCtrl($scope, $element, $attrs, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF, $filter) {this.$window = $window; this.dateUtil = $$mdDateUtil; this.$mdConstant = $mdConstant; this.$mdUtil = $mdUtil; this.$$rAF = $$rAF; this.$mdDateLocale = $mdDateLocale; this.documentElement = angular.element(document.documentElement); this.ngModelCtrl = null; this.inputElement = $element[0].querySelector('input'); this.ngInputElement = angular.element(this.inputElement); this.inputContainer = $element[0].querySelector('.md-datepicker-input-container'); this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane'); this.calendarButton = $element[0].querySelector('.md-datepicker-button'); this.inputMask = angular.element($element[0].querySelector('.md-datepicker-input-mask-opaque')); this.$element = $element; this.$attrs = $attrs; this.$scope = $scope; this.date = null; this.isFocused = false; this.isDisabled; this.setDisabled($element[0].disabled || angular.isString($attrs.disabled)); this.isCalendarOpen = false; this.openOnFocus = $attrs.hasOwnProperty('mdOpenOnFocus'); this.mdInputContainer = null; this.calendarPaneOpenedFrom = null; this.calendarPaneId = 'md-date-pane-' + $mdUtil.nextUid(); this.bodyClickHandler = angular.bind(this, this.handleBodyClick); this.windowEventName = IS_MOBILE_REGEX.test(navigator.userAgent || navigator.vendor || window.opera) ? 'orientationchange' : 'resize'; this.windowEventHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100); this.windowBlurHandler = angular.bind(this, this.handleWindowBlur); this.ngDateFilter = $filter('date'); this.leftMargin = 20; this.topMargin = null; if ($attrs.tabindex) {this.ngInputElement.attr('tabindex', $attrs.tabindex); $attrs.$set('tabindex', null);}else {$attrs.$set('tabindex', '-1');}$attrs.$set('aria-owns', this.calendarPaneId); $mdTheming($element); $mdTheming(angular.element(this.calendarPane)); var self = this; $scope.$on('$destroy', function () {self.detachCalendarPane();}); if ($attrs.mdIsOpen) {$scope.$watch('ctrl.isOpen', function (shouldBeOpen) {if (shouldBeOpen) {self.openCalendarPane({target: self.inputElement, });}else {self.closeCalendarPane();}});}if (angular.version.major === 1 && angular.version.minor <= 4) {this.$onInit();}}DatePickerCtrl.prototype.$onInit = function () {this.locale = this.dateLocale ? angular.extend({}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale; this.installPropertyInterceptors(); this.attachChangeListeners(); this.attachInteractionListeners();}; DatePickerCtrl.prototype.configureNgModel = function (ngModelCtrl, mdInputContainer, inputDirective) {this.ngModelCtrl = ngModelCtrl; this.mdInputContainer = mdInputContainer; this.$attrs.$set('type', 'date'); inputDirective[0].link.pre( this.$scope, {on: angular.noop, val: angular.noop, 0: {}, }, this.$attrs, [ngModelCtrl], ); var self = this; self.ngModelCtrl.$formatters.push(function (value) {var parsedValue = angular.isDefined(value) ? Date.parse(value) : null; if (!isNaN(parsedValue) && angular.isNumber(parsedValue)) {value = new Date(parsedValue);}if (value && !(value instanceof Date)) {throw Error( 'The ng-model for md-datepicker must be a Date instance or a value ' + 'that can be parsed into a date. Currently the model is of type: ' + typeof value, );}self.onExternalChange(value); return value;}); ngModelCtrl.$viewChangeListeners.unshift(angular.bind(this, this.updateErrorState)); var updateOn = self.$mdUtil.getModelOption(ngModelCtrl, 'updateOn'); if (updateOn) {this.ngInputElement.on(updateOn, angular.bind(this.$element, this.$element.triggerHandler, updateOn));}}; DatePickerCtrl.prototype.attachChangeListeners = function () {var self = this; self.$scope.$on('md-calendar-change', function (event, date) {self.setModelValue(date); self.onExternalChange(date); self.closeCalendarPane();}); self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement)); var debounceInterval = angular.isDefined(this.debounceInterval) ? this.debounceInterval : DEFAULT_DEBOUNCE_INTERVAL; self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent, debounceInterval, self));}; DatePickerCtrl.prototype.attachInteractionListeners = function () {var self = this; var $scope = this.$scope; var keyCodes = this.$mdConstant.KEY_CODE; self.ngInputElement.on('keydown', function (event) {if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {self.openCalendarPane(event); $scope.$digest();}}); if (self.openOnFocus) {self.ngInputElement.on('focus', angular.bind(self, self.openCalendarPane)); angular.element(self.$window).on('blur', self.windowBlurHandler); $scope.$on('$destroy', function () {angular.element(self.$window).off('blur', self.windowBlurHandler);});}$scope.$on('md-calendar-close', function () {self.closeCalendarPane();});}; DatePickerCtrl.prototype.installPropertyInterceptors = function () {var self = this; if (this.$attrs.ngDisabled) {var scope = this.$scope.$parent; if (scope) {scope.$watch(this.$attrs.ngDisabled, function (isDisabled) {self.setDisabled(isDisabled);});}}Object.defineProperty(this, 'placeholder', {get: function () {return self.inputElement.placeholder;}, set: function (value) {self.inputElement.placeholder = value || '';}, });}; DatePickerCtrl.prototype.setDisabled = function (isDisabled) {this.isDisabled = isDisabled; this.inputElement.disabled = isDisabled; if (this.calendarButton) {this.calendarButton.disabled = isDisabled;}}; DatePickerCtrl.prototype.updateErrorState = function (opt_date) {var date = opt_date || this.date; this.clearErrorState(); if (this.dateUtil.isValidDate(date)) {date = this.dateUtil.createDateAtMidnight(date); if (this.dateUtil.isValidDate(this.minDate)) {var minDate = this.dateUtil.createDateAtMidnight(this.minDate); this.ngModelCtrl.$setValidity('mindate', date >= minDate);}if (this.dateUtil.isValidDate(this.maxDate)) {var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate); this.ngModelCtrl.$setValidity('maxdate', date <= maxDate);}if (angular.isFunction(this.dateFilter)) {this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));}}else {this.ngModelCtrl.$setValidity('valid', date == null);}angular.element(this.inputContainer).toggleClass(INVALID_CLASS, !this.ngModelCtrl.$valid);}; DatePickerCtrl.prototype.clearErrorState = function () {this.inputContainer.classList.remove(INVALID_CLASS); ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function (field) {this.ngModelCtrl.$setValidity(field, true);}, this);}; DatePickerCtrl.prototype.resizeInputElement = function () {this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;}; DatePickerCtrl.prototype.handleInputEvent = function () {var inputString = this.inputElement.value; var parsedDate = inputString ? this.locale.parseDate(inputString) : null; this.dateUtil.setDateTimeToMidnight(parsedDate); var isValidInput = inputString == '' || (this.dateUtil.isValidDate(parsedDate) && this.locale.isDateComplete(inputString) && this.isDateEnabled(parsedDate)); if (isValidInput) {this.setModelValue(parsedDate); this.date = parsedDate;}this.updateErrorState(parsedDate);}; DatePickerCtrl.prototype.isDateEnabled = function (opt_date) {return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));}; DatePickerCtrl.prototype.attachCalendarPane = function () {var calendarPane = this.calendarPane; var body = document.body; calendarPane.style.transform = ''; this.$element.addClass(OPEN_CLASS); this.mdInputContainer && this.mdInputContainer.element.addClass(OPEN_CLASS); angular.element(body).addClass('md-datepicker-is-showing'); var elementRect = this.inputContainer.getBoundingClientRect(); var bodyRect = body.getBoundingClientRect(); if (!this.topMargin || this.topMargin < 0) {this.topMargin = (this.inputMask.parent().prop('clientHeight') - this.ngInputElement.prop('clientHeight')) / 2;}var paneTop = elementRect.top - bodyRect.top - this.topMargin; var paneLeft = elementRect.left - bodyRect.left - this.leftMargin; var viewportTop = bodyRect.top < 0 && document.body.scrollTop == 0 ? -bodyRect.top : document.body.scrollTop; var viewportLeft = bodyRect.left < 0 && document.body.scrollLeft == 0 ? -bodyRect.left : document.body.scrollLeft; var viewportBottom = viewportTop + this.$window.innerHeight; var viewportRight = viewportLeft + this.$window.innerWidth; this.inputMask.css({position: 'absolute', left: this.leftMargin + 'px', top: this.topMargin + 'px', width: elementRect.width - 1 + 'px', height: elementRect.height - 2 + 'px', }); if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {if (viewportRight - CALENDAR_PANE_WIDTH > 0) {paneLeft = viewportRight - CALENDAR_PANE_WIDTH;}else {paneLeft = viewportLeft; var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH; calendarPane.style.transform = 'scale(' + scale + ')';}calendarPane.classList.add('md-datepicker-pos-adjusted');}if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {paneTop = viewportBottom - CALENDAR_PANE_HEIGHT; calendarPane.classList.add('md-datepicker-pos-adjusted');}calendarPane.style.left = paneLeft + 'px'; calendarPane.style.top = paneTop + 'px'; document.body.appendChild(calendarPane); this.$$rAF(function () {calendarPane.classList.add('md-pane-open');});}; DatePickerCtrl.prototype.detachCalendarPane = function () {this.$element.removeClass(OPEN_CLASS); this.mdInputContainer && this.mdInputContainer.element.removeClass(OPEN_CLASS); angular.element(document.body).removeClass('md-datepicker-is-showing'); this.calendarPane.classList.remove('md-pane-open'); this.calendarPane.classList.remove('md-datepicker-pos-adjusted'); if (this.isCalendarOpen) {this.$mdUtil.enableScrolling();}if (this.calendarPane.parentNode) {this.calendarPane.parentNode.removeChild(this.calendarPane);}}; DatePickerCtrl.prototype.openCalendarPane = function (event) {if (!this.isCalendarOpen && !this.isDisabled && !this.inputFocusedOnWindowBlur) {this.isCalendarOpen = this.isOpen = true; this.calendarPaneOpenedFrom = event.target; this.$mdUtil.disableScrollAround(this.calendarPane); this.attachCalendarPane(); this.focusCalendar(); this.evalAttr('ngFocus'); var self = this; this.$mdUtil.nextTick(function () {self.documentElement.on('click touchstart', self.bodyClickHandler);}, false); window.addEventListener(this.windowEventName, this.windowEventHandler);}}; DatePickerCtrl.prototype.closeCalendarPane = function () {if (this.isCalendarOpen) {var self = this; self.detachCalendarPane(); self.ngModelCtrl.$setTouched(); self.evalAttr('ngBlur'); self.documentElement.off('click touchstart', self.bodyClickHandler); window.removeEventListener(self.windowEventName, self.windowEventHandler); self.calendarPaneOpenedFrom.focus(); self.calendarPaneOpenedFrom = null; if (self.openOnFocus) {self.$mdUtil.nextTick(reset);}else {reset();}}function reset() {self.isCalendarOpen = self.isOpen = false;}}; DatePickerCtrl.prototype.getCalendarCtrl = function () {return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');}; DatePickerCtrl.prototype.focusCalendar = function () {var self = this; this.$mdUtil.nextTick(function () {self.getCalendarCtrl().focus();}, false);}; DatePickerCtrl.prototype.setFocused = function (isFocused) {if (!isFocused) {this.ngModelCtrl.$setTouched();}if (!this.openOnFocus) {this.evalAttr(isFocused ? 'ngFocus' : 'ngBlur');}this.isFocused = isFocused;}; DatePickerCtrl.prototype.handleBodyClick = function (event) {if (this.isCalendarOpen) {var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar'); if (!isInCalendar) {this.closeCalendarPane();}this.$scope.$digest();}}; DatePickerCtrl.prototype.handleWindowBlur = function () {this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement;}; DatePickerCtrl.prototype.evalAttr = function (attr) {if (this.$attrs[attr]) {this.$scope.$parent.$eval(this.$attrs[attr]);}}; DatePickerCtrl.prototype.setModelValue = function (value) {var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, 'timezone'); this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, 'yyyy-MM-dd', timezone));}; DatePickerCtrl.prototype.onExternalChange = function (value) {var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, 'timezone'); this.date = value; this.inputElement.value = this.locale.formatDate(value, timezone); this.mdInputContainer && this.mdInputContainer.setHasValue(!!value); this.resizeInputElement(); this.updateErrorState();};})();})(); (function () {'use strict'; angular.module('material.components.icon').directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', '$sce', mdIconDirective]); function mdIconDirective($mdIcon, $mdTheming, $mdAria, $sce) {return {restrict: 'E', link: postLink, }; function postLink(scope, element, attr) {$mdTheming(element); var lastFontIcon = attr.mdFontIcon; var lastFontSet = $mdIcon.fontSet(attr.mdFontSet); prepareForFontIcon(); attr.$observe('mdFontIcon', fontIconChanged); attr.$observe('mdFontSet', fontIconChanged); var originalSvgSrc = element[0].getAttribute(attr.$attr.mdSvgSrc); var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || ''); if (!attr.role) {$mdAria.expect(element, 'role', 'img'); attr.role = 'img';}if (attr.role === 'img' && !attr.ariaHidden && !$mdAria.hasAriaLabel(element)) {var iconName; if (attr.alt) {$mdAria.expect(element, 'aria-label', attr.alt);}else if ($mdAria.parentHasAriaLabel(element, 2)) {$mdAria.expect(element, 'aria-hidden', 'true');}else if ((iconName = attr.mdFontIcon || attr.mdSvgIcon || element.text())) {$mdAria.expect(element, 'aria-label', iconName);}else {$mdAria.expect(element, 'aria-hidden', 'true');}}if (attrName) {attr.$observe(attrName, function (attrVal) {element.empty(); if (attrVal) {$mdIcon(attrVal).then(function (svg) {element.empty(); element.append(svg);});}});}function prepareForFontIcon() {if (!attr.mdSvgIcon && !attr.mdSvgSrc) {if (attr.mdFontIcon) {element.addClass('md-font ' + attr.mdFontIcon);}element.addClass(lastFontSet);}}function fontIconChanged() {if (!attr.mdSvgIcon && !attr.mdSvgSrc) {if (attr.mdFontIcon) {element.removeClass(lastFontIcon); element.addClass(attr.mdFontIcon); lastFontIcon = attr.mdFontIcon;}var fontSet = $mdIcon.fontSet(attr.mdFontSet); if (lastFontSet !== fontSet) {element.removeClass(lastFontSet); element.addClass(fontSet); lastFontSet = fontSet;}}}}}})(); (function () {'use strict'; MdIconService.$inject = ['config', '$templateRequest', '$q', '$log', '$mdUtil', '$sce']; angular .module('material.components.icon') .constant('$$mdSvgRegistry', {mdTabsArrow: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=', mdClose: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=', mdCancel: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==', mdMenu: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+', mdToggleArrow: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==', mdCalendar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==', mdChecked: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+', }) .provider('$mdIcon', MdIconProvider); var config = {defaultViewBoxSize: 24, defaultFontSet: 'material-icons', fontSets: [], }; function MdIconProvider() {}MdIconProvider.prototype = {icon: function (id, url, viewBoxSize) {if (id.indexOf(':') == -1) id = '$default:' + id; config[id] = new ConfigurationItem(url, viewBoxSize); return this;}, iconSet: function (id, url, viewBoxSize) {config[id] = new ConfigurationItem(url, viewBoxSize); return this;}, defaultIconSet: function (url, viewBoxSize) {var setName = '$default'; if (!config[setName]) {config[setName] = new ConfigurationItem(url, viewBoxSize);}config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize; return this;}, defaultViewBoxSize: function (viewBoxSize) {config.defaultViewBoxSize = viewBoxSize; return this;}, fontSet: function fontSet(alias, className) {config.fontSets.push({alias: alias, fontSet: className || alias, }); return this;}, defaultFontSet: function defaultFontSet(className) {config.defaultFontSet = !className ? '' : className; return this;}, defaultIconSize: function defaultIconSize(iconSize) {config.defaultIconSize = iconSize; return this;}, $get: [ '$templateRequest', '$q', '$log', '$mdUtil', '$sce', function ($templateRequest, $q, $log, $mdUtil, $sce) {return MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce);}, ], }; function ConfigurationItem(url, viewBoxSize) {this.url = url; this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;}function MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce) {var iconCache = {}; var svgCache = {}; var urlRegex = /[-\w@:%\+.~#?& var dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i; Icon.prototype = {clone: cloneSVG, prepare: prepareAndStyle }; getIcon.fontSet = findRegisteredFontSet; return getIcon; function getIcon(id) {id = id || ''; if (!angular.isString(id)) {id = $sce.getTrustedUrl(id);}if (iconCache[id]) {return $q.when(transformClone(iconCache[id]));}if (urlRegex.test(id) || dataUrlRegex.test(id)) {return loadByURL(id).then(cacheIcon(id));}if (id.indexOf(':') == -1) {id = '$default:' + id;}var load = config[id] ? loadByID : loadFromIconSet; return load(id).then(cacheIcon(id));}function findRegisteredFontSet(alias) {var useDefault = angular.isUndefined(alias) || !(alias && alias.length); if (useDefault) return config.defaultFontSet; var result = alias; angular.forEach(config.fontSets, function (it) {if (it.alias == alias) result = it.fontSet || result;}); return result;}function transformClone(cacheElement) {var clone = cacheElement.clone(); var cacheSuffix = '_cache' + $mdUtil.nextUid(); if (clone.id) clone.id += cacheSuffix; angular.forEach(clone.querySelectorAll('[id]'), function (item) {item.id += cacheSuffix;}); return clone;}function cacheIcon(id) {return function updateCache(icon) {iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]); return iconCache[id].clone();};}function loadByID(id) {var iconConfig = config[id]; return loadByURL(iconConfig.url).then(function (icon) {return new Icon(icon, iconConfig);});}function loadFromIconSet(id) {var setName = id.substring(0, id.lastIndexOf(':')) || '$default'; var iconSetConfig = config[setName]; return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet); function extractFromSet(set) {var iconName = id.slice(id.lastIndexOf(':') + 1); var icon = set.querySelector('#' + iconName); return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);}function announceIdNotFound(id) {var msg = 'icon ' + id + ' not found'; $log.warn(msg); return $q.reject(msg || id);}}function loadByURL(url) {function loadByDataUrl(url) {var results = dataUrlRegex.exec(url); var isBase64 = /base64/i.test(url); var data = isBase64 ? window.atob(results[2]) : results[2]; return $q.when(angular.element(data)[0]);}function loadByHttpUrl(url) {return $q(function (resolve, reject) {var announceAndReject = function (err) {var msg = angular.isString(err) ? err : err.message || err.data || err.statusText; $log.warn(msg); reject(err);}, extractSvg = function (response) {if (!svgCache[url]) {svgCache[url] = angular.element('<div>').append(response)[0].querySelector('svg');}resolve(svgCache[url]);}; $templateRequest(url, true).then(extractSvg, announceAndReject);});}return dataUrlRegex.test(url) ? loadByDataUrl(url) : loadByHttpUrl(url);}function isIcon(target) {return angular.isDefined(target.element) && angular.isDefined(target.config);}function Icon(el, config) {if (el && el.tagName != 'svg') {el = angular.element('<svg xmlns="http: }if (!el.getAttribute('xmlns')) {el.setAttribute('xmlns', 'http: }this.element = el; this.config = config; this.prepare();}function prepareAndStyle() {var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize; angular.forEach( {fit: '', height: '100%', width: '100%', preserveAspectRatio: 'xMidYMid meet', viewBox: this.element.getAttribute('viewBox') || '0 0 ' + viewBoxSize + ' ' + viewBoxSize, focusable: false, }, function (val, attr) {this.element.setAttribute(attr, val);}, this, );}function cloneSVG() {return this.element.cloneNode(true);}}})(); (function () {'use strict'; MenuController.$inject = ['$mdMenu', '$attrs', '$element', '$scope', '$mdUtil', '$timeout', '$rootScope', '$q', '$log']; angular.module('material.components.menu').controller('mdMenuCtrl', MenuController); function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q, $log) {var prefixer = $mdUtil.prefixer(); var menuContainer; var self = this; var triggerElement; this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0; this.init = function init(setMenuContainer, opts) {opts = opts || {}; menuContainer = setMenuContainer; triggerElement = $element[0].querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter'])); triggerElement.setAttribute('aria-expanded', 'false'); this.isInMenuBar = opts.isInMenuBar; this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu')); menuContainer.on('$mdInterimElementRemove', function () {self.isOpen = false; $mdUtil.nextTick(function () {self.onIsOpenChanged(self.isOpen);});}); $mdUtil.nextTick(function () {self.onIsOpenChanged(self.isOpen);}); var menuContainerId = 'menu_container_' + $mdUtil.nextUid(); menuContainer.attr('id', menuContainerId); angular.element(triggerElement).attr({'aria-owns': menuContainerId, 'aria-haspopup': 'true', }); $scope.$on( '$destroy', angular.bind(this, function () {this.disableHoverListener(); $mdMenu.destroy();}), ); menuContainer.on('$destroy', function () {$mdMenu.destroy();});}; var openMenuTimeout, menuItems, deregisterScopeListeners = []; this.enableHoverListener = function () {deregisterScopeListeners.push( $rootScope.$on('$mdMenuOpen', function (event, el) {if (menuContainer[0].contains(el[0])) {self.currentlyOpenMenu = el.controller('mdMenu'); self.isAlreadyOpening = false; self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));}}), ); deregisterScopeListeners.push( $rootScope.$on('$mdMenuClose', function (event, el) {if (menuContainer[0].contains(el[0])) {self.currentlyOpenMenu = undefined;}}), ); menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children)); menuItems.on('mouseenter', self.handleMenuItemHover); menuItems.on('mouseleave', self.handleMenuItemMouseLeave);}; this.disableHoverListener = function () {while (deregisterScopeListeners.length) {deregisterScopeListeners.shift()();}menuItems && menuItems.off('mouseenter', self.handleMenuItemHover); menuItems && menuItems.off('mouseleave', self.handleMenuItemMouseLeave);}; this.handleMenuItemHover = function (event) {if (self.isAlreadyOpening) return; var nestedMenu = event.target.querySelector('md-menu') || $mdUtil.getClosest(event.target, 'MD-MENU'); openMenuTimeout = $timeout( function () {if (nestedMenu) {nestedMenu = angular.element(nestedMenu).controller('mdMenu');}if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {var closeTo = self.nestLevel + 1; self.currentlyOpenMenu.close(true, {closeTo: closeTo }); self.isAlreadyOpening = !!nestedMenu; nestedMenu && nestedMenu.open();}else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {self.isAlreadyOpening = !!nestedMenu; nestedMenu && nestedMenu.open();}}, nestedMenu ? 100 : 250, ); var focusableTarget = event.currentTarget.querySelector('.md-button:not([disabled])'); focusableTarget && focusableTarget.focus();}; this.handleMenuItemMouseLeave = function () {if (openMenuTimeout) {$timeout.cancel(openMenuTimeout); openMenuTimeout = undefined;}}; this.open = function openMenu(ev) {ev && ev.stopPropagation(); ev && ev.preventDefault(); if (self.isOpen) return; self.enableHoverListener(); self.isOpen = true; $mdUtil.nextTick(function () {self.onIsOpenChanged(self.isOpen);}); triggerElement = triggerElement || (ev ? ev.target : $element[0]); triggerElement.setAttribute('aria-expanded', 'true'); $scope.$emit('$mdMenuOpen', $element); $mdMenu .show({scope: $scope, mdMenuCtrl: self, nestLevel: self.nestLevel, element: menuContainer, target: triggerElement, preserveElement: true, parent: 'body', }) .finally(function () {triggerElement.setAttribute('aria-expanded', 'false'); self.disableHoverListener();});}; this.onIsOpenChanged = function (isOpen) {if (isOpen) {menuContainer.attr('aria-hidden', 'false'); $element[0].classList.add('md-open'); angular.forEach(self.nestedMenus, function (el) {el.classList.remove('md-open');});}else {menuContainer.attr('aria-hidden', 'true'); $element[0].classList.remove('md-open');}$scope.$mdMenuIsOpen = self.isOpen;}; this.focusMenuContainer = function focusMenuContainer() {var focusTarget = menuContainer[0].querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus'])); if (!focusTarget) focusTarget = menuContainer[0].querySelector('.md-button:not([disabled])'); focusTarget.focus();}; this.registerContainerProxy = function registerContainerProxy(handler) {this.containerProxy = handler;}; this.triggerContainerProxy = function triggerContainerProxy(ev) {this.containerProxy && this.containerProxy(ev);}; this.destroy = function () {return self.isOpen ? $mdMenu.destroy() : $q.when(false);}; this.close = function closeMenu(skipFocus, closeOpts) {if (!self.isOpen) return; self.isOpen = false; $mdUtil.nextTick(function () {self.onIsOpenChanged(self.isOpen);}); var eventDetails = angular.extend({}, closeOpts, {skipFocus: skipFocus }); $scope.$emit('$mdMenuClose', $element, eventDetails); $mdMenu.hide(null, closeOpts); if (!skipFocus) {var el = self.restoreFocusTo || $element.find('button')[0]; if (el instanceof angular.element) el = el[0]; if (el) el.focus();}}; this.positionMode = function positionMode() {var attachment = ($attrs.mdPositionMode || 'target').split(' '); if (attachment.length == 1) {attachment.push(attachment[0]);}return {left: attachment[0], top: attachment[1], };}; this.offsets = function offsets() {var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat); if (position.length == 2) {return {left: position[0], top: position[1], };}else if (position.length == 1) {return {top: position[0], left: position[0], };}else {throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');}}; $scope.$mdMenu = {open: this.open, close: this.close, }; $scope.$mdOpenMenu = angular.bind(this, function () {$log.warn('mdMenu: The $mdOpenMenu method is deprecated. Please use `$mdMenu.open`.'); return this.open.apply(this, arguments);});}})(); (function () {'use strict'; MenuDirective.$inject = ['$mdUtil']; angular.module('material.components.menu').directive('mdMenu', MenuDirective); function MenuDirective($mdUtil) {var INVALID_PREFIX = 'Invalid HTML for md-menu: '; return {restrict: 'E', require: ['mdMenu', '?^mdMenuBar'], controller: 'mdMenuCtrl', scope: true, compile: compile, }; function compile(templateElement) {templateElement.addClass('md-menu'); var triggerEl = templateElement.children()[0]; var contentEl = templateElement.children()[1]; var prefixer = $mdUtil.prefixer(); if (!prefixer.hasAttribute(triggerEl, 'ng-click')) {triggerEl = triggerEl.querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter'])) || triggerEl;}var isButtonTrigger = triggerEl.nodeName === 'MD-BUTTON' || triggerEl.nodeName === 'BUTTON'; if (triggerEl && isButtonTrigger && !triggerEl.hasAttribute('type')) {triggerEl.setAttribute('type', 'button');}if (!triggerEl) {throw Error(INVALID_PREFIX + 'Expected the menu to have a trigger element.');}if (!contentEl || contentEl.nodeName !== 'MD-MENU-CONTENT') {throw Error(INVALID_PREFIX + 'Expected the menu to contain a `md-menu-content` element.');}triggerEl && triggerEl.setAttribute('aria-haspopup', 'true'); var nestedMenus = templateElement[0].querySelectorAll('md-menu'); var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0; if (nestedMenus) {angular.forEach($mdUtil.nodesToArray(nestedMenus), function (menuEl) {if (!menuEl.hasAttribute('md-position-mode')) {menuEl.setAttribute('md-position-mode', 'cascade');}menuEl.classList.add('_md-nested-menu'); menuEl.setAttribute('md-nest-level', nestingDepth + 1);});}return link;}function link(scope, element, attr, ctrls) {var mdMenuCtrl = ctrls[0]; var isInMenuBar = !!ctrls[1]; var menuContainer = angular.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>'); var menuContents = element.children()[1]; element.addClass('_md'); if (!menuContents.hasAttribute('role')) {menuContents.setAttribute('role', 'menu');}menuContainer.append(menuContents); element.on('$destroy', function () {menuContainer.remove();}); element.append(menuContainer); menuContainer[0].style.display = 'none'; mdMenuCtrl.init(menuContainer, {isInMenuBar: isInMenuBar });}}})(); (function () {'use strict'; MenuProvider.$inject = ['$$interimElementProvider']; angular.module('material.components.menu').provider('$mdMenu', MenuProvider); function MenuProvider($$interimElementProvider) {menuDefaultOptions.$inject = ['$mdUtil', '$mdTheming', '$mdConstant', '$document', '$window', '$q', '$$rAF', '$animateCss', '$animate', '$log']; var MENU_EDGE_MARGIN = 8; return $$interimElementProvider('$mdMenu').setDefaults({methods: ['target'], options: menuDefaultOptions, }); function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate, $log) {var prefixer = $mdUtil.prefixer(); var animator = $mdUtil.dom.animator; return {parent: 'body', onShow: onShow, onRemove: onRemove, hasBackdrop: true, disableParentScroll: true, skipCompile: true, preserveScope: true, multiple: true, themable: true, }; function showBackdrop(scope, element, options) {if (options.nestLevel) return angular.noop; if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);}else {options.disableParentScroll = false;}if (options.hasBackdrop) {options.backdrop = $mdUtil.createBackdrop(scope, 'md-menu-backdrop md-click-catcher'); $animate.enter(options.backdrop, $document[0].body);}return function hideBackdrop() {if (options.backdrop) options.backdrop.remove(); if (options.disableParentScroll) options.restoreScroll();};}function onRemove(scope, element, opts) {opts.cleanupInteraction(); opts.cleanupBackdrop(); opts.cleanupResizing(); opts.hideBackdrop(); element.removeClass('md-clickable'); return opts.$destroy === true ? detachAndClean() : animateRemoval().then(detachAndClean); function animateRemoval() {return $animateCss(element, {addClass: 'md-leave' }).start();}function detachAndClean() {element.removeClass('md-active'); detachElement(element, opts); opts.alreadyOpen = false;}}function onShow(scope, element, opts) {sanitizeAndConfigure(opts); if (opts.menuContentEl[0]) {$mdTheming.inherit(opts.menuContentEl, opts.target);}else {$log.warn( '$mdMenu: Menu elements should always contain a `md-menu-content` element,' + 'otherwise interactivity features will not work properly.', element, );}opts.cleanupResizing = startRepositioningOnResize(); opts.hideBackdrop = showBackdrop(scope, element, opts); return showMenu().then(function (response) {opts.alreadyOpen = true; opts.cleanupInteraction = activateInteraction(); opts.cleanupBackdrop = setupBackdrop(); element.addClass('md-clickable'); return response;}); function showMenu() {opts.parent.append(element); element[0].style.display = ''; return $q(function (resolve) {var position = calculateMenuPosition(element, opts); element.removeClass('md-leave'); $animateCss(element, {addClass: 'md-active', from: animator.toCss(position), to: animator.toCss({transform: '' }), }) .start() .then(resolve);});}function sanitizeAndConfigure() {if (!opts.target) {throw Error('$mdMenu.show() expected a target to animate from in options.target');}angular.extend(opts, {alreadyOpen: false, isRemoved: false, target: angular.element(opts.target), parent: angular.element(opts.parent), menuContentEl: angular.element(element[0].querySelector('md-menu-content')), });}function startRepositioningOnResize() {var repositionMenu = (function (target, options) {return $$rAF.throttle(function () {if (opts.isRemoved) return; var position = calculateMenuPosition(target, options); target.css(animator.toCss(position));});})(element, opts); $window.addEventListener('resize', repositionMenu); $window.addEventListener('orientationchange', repositionMenu); return function stopRepositioningOnResize() {$window.removeEventListener('resize', repositionMenu); $window.removeEventListener('orientationchange', repositionMenu);};}function setupBackdrop() {if (!opts.backdrop) return angular.noop; opts.backdrop.on('click', onBackdropClick); return function () {opts.backdrop.off('click', onBackdropClick);};}function onBackdropClick(event) {event.preventDefault(); event.stopPropagation(); scope.$apply(function () {opts.mdMenuCtrl.close(true, {closeAll: true });});}function activateInteraction() {if (!opts.menuContentEl[0]) return angular.noop; opts.menuContentEl.on('keydown', onMenuKeyDown); opts.menuContentEl[0].addEventListener('click', captureClickListener, true); var focusTarget = opts.menuContentEl[0].querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus'])); if (!focusTarget) {var childrenLen = opts.menuContentEl[0].children.length; for (var childIndex = 0; childIndex < childrenLen; childIndex++) {var child = opts.menuContentEl[0].children[childIndex]; focusTarget = child.querySelector('.md-button:not([disabled])'); if (focusTarget) {break;}if (child.firstElementChild && !child.firstElementChild.disabled) {focusTarget = child.firstElementChild; break;}}}focusTarget && focusTarget.focus(); return function cleanupInteraction() {opts.menuContentEl.off('keydown', onMenuKeyDown); opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);}; function onMenuKeyDown(ev) {var handled; switch (ev.keyCode) {case $mdConstant.KEY_CODE.ESCAPE: opts.mdMenuCtrl.close(false, {closeAll: true }); handled = true; break; case $mdConstant.KEY_CODE.UP_ARROW: if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {opts.mdMenuCtrl.triggerContainerProxy(ev);}handled = true; break; case $mdConstant.KEY_CODE.DOWN_ARROW: if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {opts.mdMenuCtrl.triggerContainerProxy(ev);}handled = true; break; case $mdConstant.KEY_CODE.LEFT_ARROW: if (opts.nestLevel) {opts.mdMenuCtrl.close();}else {opts.mdMenuCtrl.triggerContainerProxy(ev);}handled = true; break; case $mdConstant.KEY_CODE.RIGHT_ARROW: var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU'); if (parentMenu && parentMenu != opts.parent[0]) {ev.target.click();}else {opts.mdMenuCtrl.triggerContainerProxy(ev);}handled = true; break;}if (handled) {ev.preventDefault(); ev.stopImmediatePropagation();}}function onBackdropClick(e) {e.preventDefault(); e.stopPropagation(); scope.$apply(function () {opts.mdMenuCtrl.close(true, {closeAll: true });});}function captureClickListener(e) {var target = e.target; do {if (target == opts.menuContentEl[0]) return; if ( (hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) || target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close']) ) {var closestMenu = $mdUtil.getClosest(target, 'MD-MENU'); if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {close();}break;}}while ((target = target.parentNode)); function close() {scope.$apply(function () {opts.mdMenuCtrl.close(true, {closeAll: true });});}function hasAnyAttribute(target, attrs) {if (!target) return false; for (var i = 0, attr; (attr = attrs[i]); ++i) {if (prefixer.hasAttribute(target, attr)) {return true;}}return false;}}}}function focusMenuItem(e, menuEl, opts, direction) {var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM'); var items = $mdUtil.nodesToArray(menuEl[0].children); var currentIndex = items.indexOf(currentItem); var didFocus; for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {var focusTarget = items[i].querySelector('.md-button'); didFocus = attemptFocus(focusTarget); if (didFocus) {break;}}return didFocus;}function attemptFocus(el) {if (el && el.getAttribute('tabindex') != -1) {el.focus(); return $document[0].activeElement == el;}}function detachElement(element, opts) {if (!opts.preserveElement) {if (toNode(element).parentNode === toNode(opts.parent)) {toNode(opts.parent).removeChild(toNode(element));}}else {toNode(element).style.display = 'none';}}function calculateMenuPosition(el, opts) {var containerNode = el[0], openMenuNode = el[0].firstElementChild, openMenuNodeRect = openMenuNode.getBoundingClientRect(), boundryNode = $document[0].body, boundryNodeRect = boundryNode.getBoundingClientRect(); var menuStyle = $window.getComputedStyle(openMenuNode); var originNode = opts.target[0].querySelector(prefixer.buildSelector('md-menu-origin')) || opts.target[0], originNodeRect = originNode.getBoundingClientRect(); var bounds = {left: boundryNodeRect.left + MENU_EDGE_MARGIN, top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN, bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN, right: boundryNodeRect.right - MENU_EDGE_MARGIN, }; var alignTarget, alignTargetRect = {top: 0, left: 0, right: 0, bottom: 0 }, existingOffsets = {top: 0, left: 0, right: 0, bottom: 0 }; var positionMode = opts.mdMenuCtrl.positionMode(); if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {alignTarget = firstVisibleChild(); if (alignTarget) {alignTarget = alignTarget.firstElementChild || alignTarget; alignTarget = alignTarget.querySelector(prefixer.buildSelector('md-menu-align-target')) || alignTarget; alignTargetRect = alignTarget.getBoundingClientRect(); existingOffsets = {top: parseFloat(containerNode.style.top || 0), left: parseFloat(containerNode.style.left || 0), };}}var position = {}; var transformOrigin = 'top '; switch (positionMode.top) {case 'target': position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top; break; case 'cascade': position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top; break; case 'bottom': position.top = originNodeRect.top + originNodeRect.height; break; default: throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');}var rtl = $mdUtil.bidi() == 'rtl'; switch (positionMode.left) {case 'target': position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left; transformOrigin += rtl ? 'right' : 'left'; break; case 'target-left': position.left = originNodeRect.left; transformOrigin += 'left'; break; case 'target-right': position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right); transformOrigin += 'right'; break; case 'cascade': var willFitRight = rtl ? originNodeRect.left - openMenuNodeRect.width < bounds.left : originNodeRect.right + openMenuNodeRect.width < bounds.right; position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width; transformOrigin += willFitRight ? 'left' : 'right'; break; case 'right': if (rtl) {position.left = originNodeRect.right - originNodeRect.width; transformOrigin += 'left';}else {position.left = originNodeRect.right - openMenuNodeRect.width; transformOrigin += 'right';}break; case 'left': if (rtl) {position.left = originNodeRect.right - openMenuNodeRect.width; transformOrigin += 'right';}else {position.left = originNodeRect.left; transformOrigin += 'left';}break; default: throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');}var offsets = opts.mdMenuCtrl.offsets(); position.top += offsets.top; position.left += offsets.left; clamp(position); var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100; var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100; return {top: Math.round(position.top), left: Math.round(position.left), transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined, transformOrigin: transformOrigin, }; function clamp(pos) {pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top); pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);}function firstVisibleChild() {for (var i = 0; i < openMenuNode.children.length; ++i) {if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {return openMenuNode.children[i];}}}}}function toNode(el) {if (el instanceof angular.element) {el = el[0];}return el;}}})(); (function () {'use strict'; MenuBarController.$inject = ['$scope', '$rootScope', '$element', '$attrs', '$mdConstant', '$document', '$mdUtil', '$timeout']; angular.module('material.components.menuBar').controller('MenuBarController', MenuBarController); var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen']; function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {this.$element = $element; this.$attrs = $attrs; this.$mdConstant = $mdConstant; this.$mdUtil = $mdUtil; this.$document = $document; this.$scope = $scope; this.$rootScope = $rootScope; this.$timeout = $timeout; var self = this; angular.forEach(BOUND_MENU_METHODS, function (methodName) {self[methodName] = angular.bind(self, self[methodName]);});}MenuBarController.prototype.init = function () {var $element = this.$element; var $mdUtil = this.$mdUtil; var $scope = this.$scope; var self = this; var deregisterFns = []; $element.on('keydown', this.handleKeyDown); this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR'); deregisterFns.push( this.$rootScope.$on('$mdMenuOpen', function (event, el) {if (self.getMenus().indexOf(el[0]) != -1) {$element[0].classList.add('md-open'); el[0].classList.add('md-open'); self.currentlyOpenMenu = el.controller('mdMenu'); self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown); self.enableOpenOnHover();}}), ); deregisterFns.push( this.$rootScope.$on('$mdMenuClose', function (event, el, opts) {var rootMenus = self.getMenus(); if (rootMenus.indexOf(el[0]) != -1) {$element[0].classList.remove('md-open'); el[0].classList.remove('md-open');}if ($element[0].contains(el[0])) {var parentMenu = el[0]; while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);}if (parentMenu) {if (!opts.skipFocus) parentMenu.querySelector('button:not([disabled])').focus(); self.currentlyOpenMenu = undefined; self.disableOpenOnHover(); self.setKeyboardMode(true);}}}), ); $scope.$on('$destroy', function () {self.disableOpenOnHover(); while (deregisterFns.length) {deregisterFns.shift()();}}); this.setKeyboardMode(true);}; MenuBarController.prototype.setKeyboardMode = function (enabled) {if (enabled) this.$element[0].classList.add('md-keyboard-mode'); else this.$element[0].classList.remove('md-keyboard-mode');}; MenuBarController.prototype.enableOpenOnHover = function () {if (this.openOnHoverEnabled) return; var self = this; self.openOnHoverEnabled = true; if (self.parentToolbar) {self.parentToolbar.classList.add('md-has-open-menu'); self.$mdUtil.nextTick(function () {angular.element(self.parentToolbar).on('click', self.handleParentClick);}, false);}angular.element(self.getMenus()).on('mouseenter', self.handleMenuHover);}; MenuBarController.prototype.handleMenuHover = function (e) {this.setKeyboardMode(false); if (this.openOnHoverEnabled) {this.scheduleOpenHoveredMenu(e);}}; MenuBarController.prototype.disableOpenOnHover = function () {if (!this.openOnHoverEnabled) return; this.openOnHoverEnabled = false; if (this.parentToolbar) {this.parentToolbar.classList.remove('md-has-open-menu'); angular.element(this.parentToolbar).off('click', this.handleParentClick);}angular.element(this.getMenus()).off('mouseenter', this.handleMenuHover);}; MenuBarController.prototype.scheduleOpenHoveredMenu = function (e) {var menuEl = angular.element(e.currentTarget); var menuCtrl = menuEl.controller('mdMenu'); this.setKeyboardMode(false); this.scheduleOpenMenu(menuCtrl);}; MenuBarController.prototype.scheduleOpenMenu = function (menuCtrl) {var self = this; var $timeout = this.$timeout; if (menuCtrl != self.currentlyOpenMenu) {$timeout.cancel(self.pendingMenuOpen); self.pendingMenuOpen = $timeout( function () {self.pendingMenuOpen = undefined; if (self.currentlyOpenMenu) {self.currentlyOpenMenu.close(true, {closeAll: true });}menuCtrl.open();}, 200, false, );}}; MenuBarController.prototype.handleKeyDown = function (e) {var keyCodes = this.$mdConstant.KEY_CODE; var currentMenu = this.currentlyOpenMenu; var wasOpen = currentMenu && currentMenu.isOpen; this.setKeyboardMode(true); var handled, newMenu, newMenuCtrl; switch (e.keyCode) {case keyCodes.DOWN_ARROW: if (currentMenu) {currentMenu.focusMenuContainer();}else {this.openFocusedMenu();}handled = true; break; case keyCodes.UP_ARROW: currentMenu && currentMenu.close(); handled = true; break; case keyCodes.LEFT_ARROW: newMenu = this.focusMenu(-1); if (wasOpen) {newMenuCtrl = angular.element(newMenu).controller('mdMenu'); this.scheduleOpenMenu(newMenuCtrl);}handled = true; break; case keyCodes.RIGHT_ARROW: newMenu = this.focusMenu(+1); if (wasOpen) {newMenuCtrl = angular.element(newMenu).controller('mdMenu'); this.scheduleOpenMenu(newMenuCtrl);}handled = true; break;}if (handled) {e && e.preventDefault && e.preventDefault(); e && e.stopImmediatePropagation && e.stopImmediatePropagation();}}; MenuBarController.prototype.focusMenu = function (direction) {var menus = this.getMenus(); var focusedIndex = this.getFocusedMenuIndex(); if (focusedIndex == -1) {focusedIndex = this.getOpenMenuIndex();}var changed = false; if (focusedIndex == -1) {focusedIndex = 0; changed = true;}else if ((direction < 0 && focusedIndex > 0) || (direction > 0 && focusedIndex < menus.length - direction)) {focusedIndex += direction; changed = true;}if (changed) {menus[focusedIndex].querySelector('button').focus(); return menus[focusedIndex];}}; MenuBarController.prototype.openFocusedMenu = function () {var menu = this.getFocusedMenu(); menu && angular.element(menu).controller('mdMenu').open();}; MenuBarController.prototype.getMenus = function () {var $element = this.$element; return this.$mdUtil.nodesToArray($element[0].children).filter(function (el) {return el.nodeName == 'MD-MENU';});}; MenuBarController.prototype.getFocusedMenu = function () {return this.getMenus()[this.getFocusedMenuIndex()];}; MenuBarController.prototype.getFocusedMenuIndex = function () {var $mdUtil = this.$mdUtil; var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, 'MD-MENU'); if (!focusedEl) return -1; var focusedIndex = this.getMenus().indexOf(focusedEl); return focusedIndex;}; MenuBarController.prototype.getOpenMenuIndex = function () {var menus = this.getMenus(); for (var i = 0; i < menus.length; ++i) {if (menus[i].classList.contains('md-open')) return i;}return -1;}; MenuBarController.prototype.handleParentClick = function (event) {var openMenu = this.querySelector('md-menu.md-open'); if (openMenu && !openMenu.contains(event.target)) {angular.element(openMenu).controller('mdMenu').close(true, {closeAll: true, });}};})(); (function () {'use strict'; MenuBarDirective.$inject = ['$mdUtil', '$mdTheming']; angular.module('material.components.menuBar').directive('mdMenuBar', MenuBarDirective); function MenuBarDirective($mdUtil, $mdTheming) {return {restrict: 'E', require: 'mdMenuBar', controller: 'MenuBarController', compile: function compile(templateEl, templateAttrs) {if (!templateAttrs.ariaRole) {templateEl[0].setAttribute('role', 'menubar');}angular.forEach(templateEl[0].children, function (menuEl) {if (menuEl.nodeName == 'MD-MENU') {if (!menuEl.hasAttribute('md-position-mode')) {menuEl.setAttribute('md-position-mode', 'left bottom'); menuEl.querySelector('button, a, md-button').setAttribute('role', 'menuitem');}var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content')); angular.forEach(contentEls, function (contentEl) {contentEl.classList.add('md-menu-bar-menu'); contentEl.classList.add('md-dense'); if (!contentEl.hasAttribute('width')) {contentEl.setAttribute('width', 5);}});}}); templateEl.find('md-menu-item').addClass('md-in-menu-bar'); return function postLink(scope, el, attr, ctrl) {el.addClass('_md'); $mdTheming(scope, el); ctrl.init();};}, };}})(); (function () {'use strict'; angular.module('material.components.menuBar').directive('mdMenuDivider', MenuDividerDirective); function MenuDividerDirective() {return {restrict: 'E', compile: function (templateEl, templateAttrs) {if (!templateAttrs.role) {templateEl[0].setAttribute('role', 'separator');}}, };}})(); (function () {'use strict'; MenuItemController.$inject = ['$scope', '$element', '$attrs']; angular.module('material.components.menuBar').controller('MenuItemController', MenuItemController); function MenuItemController($scope, $element, $attrs) {this.$element = $element; this.$attrs = $attrs; this.$scope = $scope;}MenuItemController.prototype.init = function (ngModel) {var $element = this.$element; var $attrs = this.$attrs; this.ngModel = ngModel; if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {this.mode = $attrs.type; this.iconEl = $element[0].children[0]; this.buttonEl = $element[0].children[1]; if (ngModel) {this.initClickListeners();}}}; MenuItemController.prototype.clearNgAria = function () {var el = this.$element[0]; var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked']; angular.forEach(clearAttrs, function (attr) {el.removeAttribute(attr);});}; MenuItemController.prototype.initClickListeners = function () {var self = this; var ngModel = this.ngModel; var $scope = this.$scope; var $attrs = this.$attrs; var $element = this.$element; var mode = this.mode; this.handleClick = angular.bind(this, this.handleClick); var icon = this.iconEl; var button = angular.element(this.buttonEl); var handleClick = this.handleClick; $attrs.$observe('disabled', setDisabled); setDisabled($attrs.disabled); ngModel.$render = function render() {self.clearNgAria(); if (isSelected()) {icon.style.display = ''; button.attr('aria-checked', 'true');}else {icon.style.display = 'none'; button.attr('aria-checked', 'false');}}; $scope.$$postDigest(ngModel.$render); function isSelected() {if (mode == 'radio') {var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value; return ngModel.$modelValue == val;}else {return ngModel.$modelValue;}}function setDisabled(disabled) {if (disabled) {button.off('click', handleClick);}else {button.on('click', handleClick);}}}; MenuItemController.prototype.handleClick = function (e) {var mode = this.mode; var ngModel = this.ngModel; var $attrs = this.$attrs; var newVal; if (mode == 'checkbox') {newVal = !ngModel.$modelValue;}else if (mode == 'radio') {newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;}ngModel.$setViewValue(newVal); ngModel.$render();};})(); (function () {'use strict'; MenuItemDirective.$inject = ['$mdUtil', '$mdConstant', '$$mdSvgRegistry']; angular.module('material.components.menuBar').directive('mdMenuItem', MenuItemDirective); function MenuItemDirective($mdUtil, $mdConstant, $$mdSvgRegistry) {return {controller: 'MenuItemController', require: ['mdMenuItem', '?ngModel'], priority: $mdConstant.BEFORE_NG_ARIA, compile: function (templateEl, templateAttrs) {var type = templateAttrs.type; var inMenuBarClass = 'md-in-menu-bar'; if ((type == 'checkbox' || type == 'radio') && templateEl.hasClass(inMenuBarClass)) {var text = templateEl[0].textContent; var buttonEl = angular.element('<md-button type="button"></md-button>'); var iconTemplate = '<md-icon md-svg-src="' + $$mdSvgRegistry.mdChecked + '"></md-icon>'; buttonEl.html(text); buttonEl.attr('tabindex', '0'); templateEl.html(''); templateEl.append(angular.element(iconTemplate)); templateEl.append(buttonEl); templateEl.addClass('md-indent').removeClass(inMenuBarClass); setDefault('role', type == 'checkbox' ? 'menuitemcheckbox' : 'menuitemradio', buttonEl); moveAttrToButton('ng-disabled');}else {setDefault('role', 'menuitem', templateEl[0].querySelector('md-button, button, a'));}return function (scope, el, attrs, ctrls) {var ctrl = ctrls[0]; var ngModel = ctrls[1]; ctrl.init(ngModel);}; function setDefault(attr, val, el) {el = el || templateEl; if (el instanceof angular.element) {el = el[0];}if (!el.hasAttribute(attr)) {el.setAttribute(attr, val);}}function moveAttrToButton(attribute) {var attributes = $mdUtil.prefixer(attribute); angular.forEach(attributes, function (attr) {if (templateEl[0].hasAttribute(attr)) {var val = templateEl[0].getAttribute(attr); buttonEl[0].setAttribute(attr, val); templateEl[0].removeAttribute(attr);}});}}, };}})(); (function () {'use strict'; MdProgressCircularDirective.$inject = ['$window', '$mdProgressCircular', '$mdTheming', '$mdUtil', '$interval', '$log']; angular.module('material.components.progressCircular').directive('mdProgressCircular', MdProgressCircularDirective); function MdProgressCircularDirective($window, $mdProgressCircular, $mdTheming, $mdUtil, $interval, $log) {var rAF = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || angular.noop; var cAF = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame || angular.noop; var MODE_DETERMINATE = 'determinate'; var MODE_INDETERMINATE = 'indeterminate'; var DISABLED_CLASS = '_md-progress-circular-disabled'; var INDETERMINATE_CLASS = 'md-mode-indeterminate'; return {restrict: 'E', scope: {value: '@', mdDiameter: '@', mdMode: '@', }, template: '<svg xmlns="http: compile: function (element, attrs) {element.attr({'aria-valuemin': 0, 'aria-valuemax': 100, role: 'progressbar', }); if (angular.isUndefined(attrs.mdMode)) {var mode = attrs.hasOwnProperty('value') ? MODE_DETERMINATE : MODE_INDETERMINATE; attrs.$set('mdMode', mode);}else {attrs.$set('mdMode', attrs.mdMode.trim());}return MdProgressCircularLink;}, }; function MdProgressCircularLink(scope, element, attrs) {var node = element[0]; var svg = angular.element(node.querySelector('svg')); var path = angular.element(node.querySelector('path')); var startIndeterminate = $mdProgressCircular.startIndeterminate; var endIndeterminate = $mdProgressCircular.endIndeterminate; var iterationCount = 0; var lastAnimationId = 0; var lastDrawFrame; var interval; $mdTheming(element); element.toggleClass(DISABLED_CLASS, attrs.hasOwnProperty('disabled')); if (scope.mdMode === MODE_INDETERMINATE) {startIndeterminateAnimation();}scope.$on('$destroy', function () {cleanupIndeterminateAnimation(); if (lastDrawFrame) {cAF(lastDrawFrame);}}); scope.$watchGroup( [ 'value', 'mdMode', function () {var isDisabled = node.disabled; if (isDisabled === true || isDisabled === false) {return isDisabled;}return angular.isDefined(element.attr('disabled'));}, ], function (newValues, oldValues) {var mode = newValues[1]; var isDisabled = newValues[2]; var wasDisabled = oldValues[2]; if (isDisabled !== wasDisabled) {element.toggleClass(DISABLED_CLASS, !!isDisabled);}if (isDisabled) {cleanupIndeterminateAnimation();}else {if (mode !== MODE_DETERMINATE && mode !== MODE_INDETERMINATE) {mode = MODE_INDETERMINATE; attrs.$set('mdMode', mode);}if (mode === MODE_INDETERMINATE) {startIndeterminateAnimation();}else {var newValue = clamp(newValues[0]); cleanupIndeterminateAnimation(); element.attr('aria-valuenow', newValue); renderCircle(clamp(oldValues[0]), newValue);}}}, ); scope.$watch('mdDiameter', function (newValue) {var diameter = getSize(newValue); var strokeWidth = getStroke(diameter); var value = clamp(scope.value); var transformOrigin = diameter / 2 + 'px'; var dimensions = {width: diameter + 'px', height: diameter + 'px', }; svg[0].setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter); svg.css(dimensions).css('transform-origin', transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin); element.css(dimensions); path.attr('stroke-width', strokeWidth); path.attr('stroke-linecap', 'square'); if (scope.mdMode == MODE_INDETERMINATE) {path.attr('d', getSvgArc(diameter, strokeWidth, true)); path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI * 0.75); path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, 1, 75));}else {path.attr('d', getSvgArc(diameter, strokeWidth, false)); path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI); path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, 0, 100)); renderCircle(value, value);}}); function renderCircle(animateFrom, animateTo, easing, duration, iterationCount, maxValue) {var id = ++lastAnimationId; var startTime = $mdUtil.now(); var changeInValue = animateTo - animateFrom; var diameter = getSize(scope.mdDiameter); var strokeWidth = getStroke(diameter); var ease = easing || $mdProgressCircular.easeFn; var animationDuration = duration || $mdProgressCircular.duration; var rotation = -90 * (iterationCount || 0); var dashLimit = maxValue || 100; if (animateTo === animateFrom) {renderFrame(animateTo);}else {lastDrawFrame = rAF(function animation() {var currentTime = $window.Math.max(0, $window.Math.min($mdUtil.now() - startTime, animationDuration)); renderFrame(ease(currentTime, animateFrom, changeInValue, animationDuration)); if (id === lastAnimationId && currentTime < animationDuration) {lastDrawFrame = rAF(animation);}});}function renderFrame(value) {path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, value, dashLimit)); path.attr('transform', 'rotate(' + rotation + ' ' + diameter / 2 + ' ' + diameter / 2 + ')');}}function animateIndeterminate() {renderCircle( startIndeterminate, endIndeterminate, $mdProgressCircular.easeFnIndeterminate, $mdProgressCircular.durationIndeterminate, iterationCount, 75, ); iterationCount = ++iterationCount % 4;}function startIndeterminateAnimation() {if (!interval) {interval = $interval(animateIndeterminate, $mdProgressCircular.durationIndeterminate, 0, false); animateIndeterminate(); element.addClass(INDETERMINATE_CLASS).removeAttr('aria-valuenow');}}function cleanupIndeterminateAnimation() {if (interval) {$interval.cancel(interval); interval = null; element.removeClass(INDETERMINATE_CLASS);}}}function getSvgArc(diameter, strokeWidth, indeterminate) {var radius = diameter / 2; var offset = strokeWidth / 2; var start = radius + ',' + offset; var end = offset + ',' + radius; var arcRadius = radius - offset; return ( 'M' + start + 'A' + arcRadius + ',' + arcRadius + ' 0 1 1 ' + end + (indeterminate ? '' : 'A' + arcRadius + ',' + arcRadius + ' 0 0 1 ' + start) );}function getDashLength(diameter, strokeWidth, value, limit) {return (diameter - strokeWidth) * $window.Math.PI * ((3 * (limit || 100)) / 100 - value / 100);}function clamp(value) {return $window.Math.max(0, $window.Math.min(value || 0, 100));}function getSize(value) {var defaultValue = $mdProgressCircular.progressSize; if (value) {var parsed = parseFloat(value); if (value.lastIndexOf('%') === value.length - 1) {parsed = (parsed / 100) * defaultValue;}return parsed;}return defaultValue;}function getStroke(diameter) {return ($mdProgressCircular.strokeWidth / 100) * diameter;}}})(); (function () {'use strict'; angular.module('material.components.progressCircular').provider('$mdProgressCircular', MdProgressCircularProvider); function MdProgressCircularProvider() {var progressConfig = {progressSize: 50, strokeWidth: 10, duration: 100, easeFn: linearEase, durationIndeterminate: 1333, startIndeterminate: 1, endIndeterminate: 149, easeFnIndeterminate: materialEase, easingPresets: {linearEase: linearEase, materialEase: materialEase, }, }; return {configure: function (options) {progressConfig = angular.extend(progressConfig, options || {}); return progressConfig;}, $get: function () {return progressConfig;}, }; function linearEase(t, b, c, d) {return (c * t) / d + b;}function materialEase(t, b, c, d) {var ts = (t /= d) * t; var tc = ts * t; return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc);}}})(); (function () {'use strict'; angular.module('material.components.tabs').directive('mdTab', MdTab); function MdTab() {return {require: '^?mdTabs', terminal: true, compile: function (element, attr) {var label = firstChild(element, 'md-tab-label'), body = firstChild(element, 'md-tab-body'); if (label.length === 0) {label = angular.element('<md-tab-label></md-tab-label>'); if (attr.label) label.text(attr.label); else label.append(element.contents()); if (body.length === 0) {var contents = element.contents().detach(); body = angular.element('<md-tab-body></md-tab-body>'); body.append(contents);}}element.append(label); if (body.html()) element.append(body); return postLink;}, scope: {active: '=?mdActive', disabled: '=?ngDisabled', select: '&?mdOnSelect', deselect: '&?mdOnDeselect', }, }; function postLink(scope, element, attr, ctrl) {if (!ctrl) return; var index = ctrl.getTabElementIndex(element), body = firstChild(element, 'md-tab-body').remove(), label = firstChild(element, 'md-tab-label').remove(), data = ctrl.insertTab( {scope: scope, parent: scope.$parent, index: index, element: element, template: body.html(), label: label.html(), }, index, ); scope.select = scope.select || angular.noop; scope.deselect = scope.deselect || angular.noop; scope.$watch('active', function (active) {if (active) ctrl.select(data.getIndex(), true);}); scope.$watch('disabled', function () {ctrl.refreshIndex();}); scope.$watch( function () {return ctrl.getTabElementIndex(element);}, function (newIndex) {data.index = newIndex; ctrl.updateTabOrder();}, ); scope.$on('$destroy', function () {ctrl.removeTab(data);});}function firstChild(element, tagName) {var children = element[0].children; for (var i = 0, len = children.length; i < len; i++) {var child = children[i]; if (child.tagName === tagName.toUpperCase()) return angular.element(child);}return angular.element();}}})(); (function () {'use strict'; angular.module('material.components.tabs').directive('mdTabItem', MdTabItem); function MdTabItem() {return {require: '^?mdTabs', link: function link(scope, element, attr, ctrl) {if (!ctrl) return; ctrl.attachRipple(scope, element);}, };}})(); (function () {'use strict'; angular.module('material.components.tabs').directive('mdTabLabel', MdTabLabel); function MdTabLabel() {return {terminal: true };}})(); (function () {'use strict'; MdTabScroll.$inject = ['$parse']; angular.module('material.components.tabs').directive('mdTabScroll', MdTabScroll); function MdTabScroll($parse) {return {restrict: 'A', compile: function ($element, attr) {var fn = $parse(attr.mdTabScroll, null, true); return function ngEventHandler(scope, element) {element.on('mousewheel', function (event) {scope.$apply(function () {fn(scope, {$event: event });});});};}, };}})(); (function () {'use strict'; MdTabsController.$inject = [ '$scope', '$element', '$window', '$mdConstant', '$mdTabInkRipple', '$mdUtil', '$animateCss', '$attrs', '$compile', '$mdTheming', '$mdInteraction', 'MdTabsPaginationService', ]; angular.module('material.components.tabs').controller('MdTabsController', MdTabsController); function MdTabsController( $scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming, $mdInteraction, MdTabsPaginationService, ) {var ctrl = this, locked = false, elements = getElements(), queue = [], destroyed = false, loaded = false; ctrl.$onInit = $onInit; ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100); ctrl.redirectFocus = redirectFocus; ctrl.attachRipple = attachRipple; ctrl.insertTab = insertTab; ctrl.removeTab = removeTab; ctrl.select = select; ctrl.scroll = scroll; ctrl.nextPage = nextPage; ctrl.previousPage = previousPage; ctrl.keydown = keydown; ctrl.canPageForward = canPageForward; ctrl.canPageBack = canPageBack; ctrl.refreshIndex = refreshIndex; ctrl.incrementIndex = incrementIndex; ctrl.getTabElementIndex = getTabElementIndex; ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100); ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100); ctrl.getFocusedTabId = getFocusedTabId; if (angular.version.major === 1 && angular.version.minor <= 4) {this.$onInit();}function $onInit() {defineOneWayBinding('stretchTabs', handleStretchTabs); defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0); defineProperty('offsetLeft', handleOffsetChange, 0); defineProperty('hasContent', handleHasContent, false); defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth()); defineProperty('shouldPaginate', handleShouldPaginate, false); defineBooleanAttribute('noInkBar', handleInkBar); defineBooleanAttribute('dynamicHeight', handleDynamicHeight); defineBooleanAttribute('noPagination'); defineBooleanAttribute('swipeContent'); defineBooleanAttribute('noDisconnect'); defineBooleanAttribute('autoselect'); defineBooleanAttribute('noSelectClick'); defineBooleanAttribute('centerTabs', handleCenterTabs, false); defineBooleanAttribute('enableDisconnect'); ctrl.scope = $scope; ctrl.parent = $scope.$parent; ctrl.tabs = []; ctrl.lastSelectedIndex = null; ctrl.hasFocus = false; ctrl.styleTabItemFocus = false; ctrl.shouldCenterTabs = shouldCenterTabs(); ctrl.tabContentPrefix = 'tab-content-'; setupTabsController();}function setupTabsController() {ctrl.selectedIndex = ctrl.selectedIndex || 0; compileTemplate(); configureWatchers(); bindEvents(); $mdTheming($element); $mdUtil.nextTick(function () {elements = getElements(); updateHeightFromContent(); adjustOffset(); updateInkBarStyles(); ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select(); loaded = true; updatePagination();});}function compileTemplate() {var template = $attrs.$mdTabsTemplate, element = angular.element($element[0].querySelector('md-tab-data')); element.html(template); $compile(element.contents())(ctrl.parent); delete $attrs.$mdTabsTemplate;}function bindEvents() {angular.element($window).on('resize', handleWindowResize); $scope.$on('$destroy', cleanup);}function configureWatchers() {$scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);}function defineOneWayBinding(key, handler) {var attr = $attrs.$normalize('md-' + key); if (handler) defineProperty(key, handler); $attrs.$observe(attr, function (newValue) {ctrl[key] = newValue;});}function defineBooleanAttribute(key, handler) {var attr = $attrs.$normalize('md-' + key); if (handler) defineProperty(key, handler); if ($attrs.hasOwnProperty(attr)) updateValue($attrs[attr]); $attrs.$observe(attr, updateValue); function updateValue(newValue) {ctrl[key] = newValue !== 'false';}}function cleanup() {destroyed = true; angular.element($window).off('resize', handleWindowResize);}function handleStretchTabs(stretchTabs) {var elements = getElements(); angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs()); updateInkBarStyles();}function handleCenterTabs(newValue) {ctrl.shouldCenterTabs = shouldCenterTabs();}function handleMaxTabWidth(newWidth, oldWidth) {if (newWidth !== oldWidth) {var elements = getElements(); angular.forEach(elements.tabs, function (tab) {tab.style.maxWidth = newWidth + 'px';}); angular.forEach(elements.dummies, function (tab) {tab.style.maxWidth = newWidth + 'px';}); $mdUtil.nextTick(ctrl.updateInkBarStyles);}}function handleShouldPaginate(newValue, oldValue) {if (newValue !== oldValue) {ctrl.maxTabWidth = getMaxTabWidth(); ctrl.shouldCenterTabs = shouldCenterTabs(); $mdUtil.nextTick(function () {ctrl.maxTabWidth = getMaxTabWidth(); adjustOffset(ctrl.selectedIndex);});}}function handleHasContent(hasContent) {$element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');}function handleOffsetChange(left) {var elements = getElements(); var newValue = (ctrl.shouldCenterTabs || isRtl() ? '' : '-') + left + 'px'; newValue = newValue.replace('--', ''); angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)'); $scope.$broadcast('$mdTabsPaginationChanged');}function handleFocusIndexChange(newIndex, oldIndex) {if (newIndex === oldIndex) return; if (!getElements().tabs[newIndex]) return; adjustOffset(); redirectFocus();}function handleSelectedIndexChange(newValue, oldValue) {if (newValue === oldValue) return; ctrl.selectedIndex = getNearestSafeIndex(newValue); ctrl.lastSelectedIndex = oldValue; ctrl.updateInkBarStyles(); updateHeightFromContent(); adjustOffset(newValue); $scope.$broadcast('$mdTabsChanged'); ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect(); ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();}function getTabElementIndex(tabEl) {var tabs = $element[0].getElementsByTagName('md-tab'); return Array.prototype.indexOf.call(tabs, tabEl[0]);}function handleResizeWhenVisible() {if (handleResizeWhenVisible.watcher) return; handleResizeWhenVisible.watcher = $scope.$watch(function () {$mdUtil.nextTick(function () {if (!handleResizeWhenVisible.watcher) return; if ($element.prop('offsetParent')) {handleResizeWhenVisible.watcher(); handleResizeWhenVisible.watcher = null; handleWindowResize();}}, false);});}function keydown(event) {switch (event.keyCode) {case $mdConstant.KEY_CODE.LEFT_ARROW: event.preventDefault(); incrementIndex(-1, true); break; case $mdConstant.KEY_CODE.RIGHT_ARROW: event.preventDefault(); incrementIndex(1, true); break; case $mdConstant.KEY_CODE.SPACE: case $mdConstant.KEY_CODE.ENTER: event.preventDefault(); if (!locked) select(ctrl.focusIndex); break; case $mdConstant.KEY_CODE.TAB: if (ctrl.focusIndex !== ctrl.selectedIndex) {ctrl.focusIndex = ctrl.selectedIndex;}break;}}function select(index, canSkipClick) {if (!locked) ctrl.focusIndex = ctrl.selectedIndex = index; if (canSkipClick && ctrl.noSelectClick) return; $mdUtil.nextTick(function () {ctrl.tabs[index].element.triggerHandler('click');}, false);}function scroll(event) {if (!ctrl.shouldPaginate) return; event.preventDefault(); ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);}function nextPage() {if (!ctrl.canPageForward()) {return;}var newOffset = MdTabsPaginationService.increasePageOffset(getElements(), ctrl.offsetLeft); ctrl.offsetLeft = fixOffset(newOffset);}function previousPage() {if (!ctrl.canPageBack()) {return;}var newOffset = MdTabsPaginationService.decreasePageOffset(getElements(), ctrl.offsetLeft); ctrl.offsetLeft = fixOffset(newOffset);}function handleWindowResize() {ctrl.lastSelectedIndex = ctrl.selectedIndex; ctrl.offsetLeft = fixOffset(ctrl.offsetLeft); $mdUtil.nextTick(function () {ctrl.updateInkBarStyles(); updatePagination();});}function handleInkBar(hide) {angular.element(getElements().inkBar).toggleClass('ng-hide', hide);}function handleDynamicHeight(value) {$element.toggleClass('md-dynamic-height', value);}function removeTab(tabData) {if (destroyed) return; var selectedIndex = ctrl.selectedIndex, tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0]; refreshIndex(); if (ctrl.selectedIndex === selectedIndex) {tab.scope.deselect(); ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();}$mdUtil.nextTick(function () {updatePagination(); ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);});}function insertTab(tabData, index) {var hasLoaded = loaded; var proto = {getIndex: function () {return ctrl.tabs.indexOf(tab);}, isActive: function () {return this.getIndex() === ctrl.selectedIndex;}, isLeft: function () {return this.getIndex() < ctrl.selectedIndex;}, isRight: function () {return this.getIndex() > ctrl.selectedIndex;}, shouldRender: function () {return !ctrl.noDisconnect || this.isActive();}, hasFocus: function () {return ctrl.styleTabItemFocus && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;}, id: $mdUtil.nextUid(), hasContent: !!(tabData.template && tabData.template.trim()), }, tab = angular.extend(proto, tabData); if (angular.isDefined(index)) {ctrl.tabs.splice(index, 0, tab);}else {ctrl.tabs.push(tab);}processQueue(); updateHasContent(); $mdUtil.nextTick(function () {updatePagination(); setAriaControls(tab); if (hasLoaded && ctrl.autoselect) $mdUtil.nextTick(function () {$mdUtil.nextTick(function () {select(ctrl.tabs.indexOf(tab));});});}); return tab;}function getElements() {var elements = {}; var node = $element[0]; elements.wrapper = node.querySelector('md-tabs-wrapper'); elements.canvas = elements.wrapper.querySelector('md-tabs-canvas'); elements.paging = elements.canvas.querySelector('md-pagination-wrapper'); elements.inkBar = elements.paging.querySelector('md-ink-bar'); elements.nextButton = node.querySelector('md-next-button'); elements.prevButton = node.querySelector('md-prev-button'); elements.contents = node.querySelectorAll('md-tabs-content-wrapper > md-tab-content'); elements.tabs = elements.paging.querySelectorAll('md-tab-item'); elements.dummies = elements.canvas.querySelectorAll('md-dummy-tab'); return elements;}function canPageBack() {return ctrl.offsetLeft > 0;}function canPageForward() {var elements = getElements(); var lastTab = elements.tabs[elements.tabs.length - 1]; if (isRtl()) {return ctrl.offsetLeft < elements.paging.offsetWidth - elements.canvas.offsetWidth;}return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;}function getFocusedTabId() {var focusedTab = ctrl.tabs[ctrl.focusIndex]; if (!focusedTab || !focusedTab.id) {return null;}return 'tab-item-' + focusedTab.id;}function shouldStretchTabs() {switch (ctrl.stretchTabs) {case 'always': return true; case 'never': return false; default: return !ctrl.shouldPaginate && $window.matchMedia('(max-width: 600px)').matches;}}function shouldCenterTabs() {return ctrl.centerTabs && !ctrl.shouldPaginate;}function shouldPaginate() {if (ctrl.noPagination || !loaded) return false; var canvasWidth = $element.prop('clientWidth'); angular.forEach(getElements().tabs, function (tab) {canvasWidth -= tab.offsetWidth;}); return canvasWidth < 0;}function getNearestSafeIndex(newIndex) {if (newIndex === -1) return -1; var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex), i, tab; for (i = 0; i <= maxOffset; i++) {tab = ctrl.tabs[newIndex + i]; if (tab && tab.scope.disabled !== true) return tab.getIndex(); tab = ctrl.tabs[newIndex - i]; if (tab && tab.scope.disabled !== true) return tab.getIndex();}return newIndex;}function defineProperty(key, handler, value) {Object.defineProperty(ctrl, key, {get: function () {return value;}, set: function (newValue) {var oldValue = value; value = newValue; handler && handler(newValue, oldValue);}, });}function updatePagination() {ctrl.maxTabWidth = getMaxTabWidth(); ctrl.shouldPaginate = shouldPaginate();}function calcPagingWidth() {return calcTabsWidth(getElements().tabs);}function calcTabsWidth(tabs) {var width = 0; angular.forEach(tabs, function (tab) {width += Math.max(tab.offsetWidth, tab.getBoundingClientRect().width);}); return Math.ceil(width);}function getMaxTabWidth() {var elements = getElements(), containerWidth = elements.canvas.clientWidth, specMax = 264; return Math.max(0, Math.min(containerWidth - 1, specMax));}function getMinTabWidth() {var elements = getElements(), containerWidth = elements.canvas.clientWidth, xsBreakpoint = 600, specMin = containerWidth > xsBreakpoint ? 160 : 72; return Math.max(0, Math.min(containerWidth - 1, specMin));}function updateTabOrder() {var selectedItem = ctrl.tabs[ctrl.selectedIndex], focusItem = ctrl.tabs[ctrl.focusIndex]; ctrl.tabs = ctrl.tabs.sort(function (a, b) {return a.index - b.index;}); ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem); ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);}function incrementIndex(inc, focus) {var newIndex, key = focus ? 'focusIndex' : 'selectedIndex', index = ctrl[key]; for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) {}newIndex = (index + inc + ctrl.tabs.length) % ctrl.tabs.length; if (ctrl.tabs[newIndex]) {ctrl[key] = newIndex;}}function redirectFocus() {ctrl.styleTabItemFocus = $mdInteraction.getLastInteractionType() === 'keyboard'; getElements().tabs[ctrl.focusIndex].focus();}function adjustOffset(index) {var elements = getElements(); if (!angular.isNumber(index)) index = ctrl.focusIndex; if (!elements.tabs[index]) return; if (ctrl.shouldCenterTabs) return; var tab = elements.tabs[index], left = tab.offsetLeft, right = tab.offsetWidth + left, extraOffset = 32; if (index == 0) {ctrl.offsetLeft = 0; return;}if (isRtl()) {var tabWidthsBefore = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index)); var tabWidthsIncluding = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index + 1)); ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(tabWidthsBefore)); ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(tabWidthsIncluding - elements.canvas.clientWidth));}else {ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + extraOffset)); ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));}}function processQueue() {queue.forEach(function (func) {$mdUtil.nextTick(func);}); queue = [];}function updateHasContent() {var hasContent = false; for (var i = 0; i < ctrl.tabs.length; i++) {if (ctrl.tabs[i].hasContent) {hasContent = true; break;}}ctrl.hasContent = hasContent;}function refreshIndex() {ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex); ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);}function updateHeightFromContent() {if (!ctrl.dynamicHeight) return $element.css('height', ''); if (!ctrl.tabs.length) return queue.push(updateHeightFromContent); var elements = getElements(); var tabContent = elements.contents[ctrl.selectedIndex], contentHeight = tabContent ? tabContent.offsetHeight : 0, tabsHeight = elements.wrapper.offsetHeight, newHeight = contentHeight + tabsHeight, currentHeight = $element.prop('clientHeight'); if (currentHeight === newHeight) return; if ($element.attr('md-align-tabs') === 'bottom') {currentHeight -= tabsHeight; newHeight -= tabsHeight; if ($element.attr('md-border-bottom') !== undefined) ++currentHeight;}locked = true; var fromHeight = {height: currentHeight + 'px' }, toHeight = {height: newHeight + 'px' }; $element.css(fromHeight); $animateCss($element, {from: fromHeight, to: toHeight, easing: 'cubic-bezier(0.35, 0, 0.25, 1)', duration: 0.5, }) .start() .done(function () {$element.css({transition: 'none', height: '', }); $mdUtil.nextTick(function () {$element.css('transition', '');}); locked = false;});}function updateInkBarStyles() {var elements = getElements(); if (!elements.tabs[ctrl.selectedIndex]) {angular.element(elements.inkBar).css({left: 'auto', right: 'auto' }); return;}if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles); if (!$element.prop('offsetParent')) return handleResizeWhenVisible(); var index = ctrl.selectedIndex, totalWidth = elements.paging.offsetWidth, tab = elements.tabs[index], left = tab.offsetLeft, right = totalWidth - left - tab.offsetWidth; if (ctrl.shouldCenterTabs) {var tabWidth = calcTabsWidth(elements.tabs); if (totalWidth > tabWidth) {$mdUtil.nextTick(updateInkBarStyles, false);}}updateInkBarClassName(); angular.element(elements.inkBar).css({left: left + 'px', right: right + 'px' });}function updateInkBarClassName() {var elements = getElements(); var newIndex = ctrl.selectedIndex, oldIndex = ctrl.lastSelectedIndex, ink = angular.element(elements.inkBar); if (!angular.isNumber(oldIndex)) return; ink.toggleClass('md-left', newIndex < oldIndex).toggleClass('md-right', newIndex > oldIndex);}function fixOffset(value) {var elements = getElements(); if (!elements.tabs.length || !ctrl.shouldPaginate) return 0; var lastTab = elements.tabs[elements.tabs.length - 1], totalWidth = lastTab.offsetLeft + lastTab.offsetWidth; if (isRtl()) {value = Math.min(elements.paging.offsetWidth - elements.canvas.clientWidth, value); value = Math.max(0, value);}else {value = Math.max(0, value); value = Math.min(totalWidth - elements.canvas.clientWidth, value);}return value;}function attachRipple(scope, element) {var elements = getElements(); var options = {colorElement: angular.element(elements.inkBar) }; $mdTabInkRipple.attach(scope, element, options);}function setAriaControls(tab) {if (tab.hasContent) {var nodes = $element[0].querySelectorAll('[md-tab-id="' + tab.id + '"]'); angular.element(nodes).attr('aria-controls', ctrl.tabContentPrefix + tab.id);}}function isRtl() {return $mdUtil.bidi() == 'rtl';}}})(); (function () {'use strict'; MdTabs.$inject = ['$$mdSvgRegistry']; angular.module('material.components.tabs').directive('mdTabs', MdTabs); function MdTabs($$mdSvgRegistry) {return {scope: {selectedIndex: '=?mdSelected', }, template: function (element, attr) {attr.$mdTabsTemplate = element.html(); return ( '' + '<md-tabs-wrapper> ' + '<md-tab-data></md-tab-data> ' + '<md-prev-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Previous Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' + 'ng-class="{\'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.previousPage()"> ' + '<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> ' + '</md-prev-button> ' + '<md-next-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Next Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' + 'ng-class="{\'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.nextPage()"> ' + '<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> ' + '</md-next-button> ' + '<md-tabs-canvas ' + 'ng-focus="$mdTabsCtrl.redirectFocus()" ' + 'ng-class="{' + "'md-paginated': $mdTabsCtrl.shouldPaginate, " + "'md-center-tabs': $mdTabsCtrl.shouldCenterTabs " + '}" ' + 'ng-keydown="$mdTabsCtrl.keydown($event)"> ' + '<md-pagination-wrapper ' + 'ng-class="{\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' + 'md-tab-scroll="$mdTabsCtrl.scroll($event)" ' + 'role="tablist"> ' + '<md-tab-item ' + 'tabindex="{{tab.isActive() ? 0 : -1 }}" ' + 'class="md-tab" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'role="tab" ' + 'id="tab-item-{{::tab.id}}" ' + 'md-tab-id="{{::tab.id}}"' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' + 'ng-focus="$mdTabsCtrl.hasFocus = true" ' + 'ng-blur="$mdTabsCtrl.hasFocus = false" ' + 'ng-class="{' + "'md-active': tab.isActive(), " + "'md-focused': tab.hasFocus(), " + "'md-disabled': tab.scope.disabled " + '}" ' + 'ng-disabled="tab.scope.disabled" ' + 'md-swipe-left="$mdTabsCtrl.nextPage()" ' + 'md-swipe-right="$mdTabsCtrl.previousPage()" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-tab-item> ' + '<md-ink-bar></md-ink-bar> ' + '</md-pagination-wrapper> ' + '<md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> ' + '<md-dummy-tab ' + 'class="md-tab" ' + 'tabindex="-1" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-dummy-tab> ' + '</md-tabs-dummy-wrapper> ' + '</md-tabs-canvas> ' + '</md-tabs-wrapper> ' + '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> ' + '<md-tab-content ' + 'id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" ' + 'class="_md" ' + 'role="tabpanel" ' + 'aria-labelledby="tab-item-{{::tab.id}}" ' + 'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' + 'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' + 'ng-if="tab.hasContent" ' + 'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' + 'ng-class="{' + "'md-no-transition': $mdTabsCtrl.lastSelectedIndex == null, " + "'md-active': tab.isActive(), " + "'md-left': tab.isLeft(), " + "'md-right': tab.isRight(), " + "'md-no-scroll': $mdTabsCtrl.dynamicHeight " + '}"> ' + '<div ' + 'md-tabs-template="::tab.template" ' + 'md-connected-if="tab.isActive()" ' + 'md-scope="::tab.parent" ' + 'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' + '</md-tab-content> ' + '</md-tabs-content-wrapper>' );}, controller: 'MdTabsController', controllerAs: '$mdTabsCtrl', bindToController: true, };}})(); (function () {'use strict'; MdTabsDummyWrapper.$inject = ['$mdUtil', '$window']; angular.module('material.components.tabs').directive('mdTabsDummyWrapper', MdTabsDummyWrapper); function MdTabsDummyWrapper($mdUtil, $window) {return {require: '^?mdTabs', link: function link(scope, element, attr, ctrl) {if (!ctrl) return; var observer; var disconnect; var mutationCallback = function () {ctrl.updatePagination(); ctrl.updateInkBarStyles();}; if ('MutationObserver' in $window) {var config = {childList: true, subtree: true, characterData: true, }; observer = new MutationObserver(mutationCallback); observer.observe(element[0], config); disconnect = observer.disconnect.bind(observer);}else {var debounced = $mdUtil.debounce(mutationCallback, 15, null, false); element.on('DOMSubtreeModified', debounced); disconnect = element.off.bind(element, 'DOMSubtreeModified', debounced);}scope.$on('$destroy', function () {disconnect();});}, };}})(); (function () {'use strict'; MdTabsTemplate.$inject = ['$compile', '$mdUtil']; angular.module('material.components.tabs').directive('mdTabsTemplate', MdTabsTemplate); function MdTabsTemplate($compile, $mdUtil) {return {restrict: 'A', link: link, scope: {template: '=mdTabsTemplate', connected: '=?mdConnectedIf', compileScope: '=mdScope', }, require: '^?mdTabs', }; function link(scope, element, attr, ctrl) {if (!ctrl) return; var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope; element.html(scope.template); $compile(element.contents())(compileScope); return $mdUtil.nextTick(handleScope); function handleScope() {scope.$watch('connected', function (value) {value === false ? disconnect() : reconnect();}); scope.$on('$destroy', reconnect);}function disconnect() {if (ctrl.enableDisconnect) $mdUtil.disconnectScope(compileScope);}function reconnect() {if (ctrl.enableDisconnect) $mdUtil.reconnectScope(compileScope);}}}})(); (function () {angular .module('material.core') .constant( '$MD_THEME_CSS', 'md-autocomplete.md-THEME_NAME-theme{background:"{{background-A100}}"}md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]){background:"{{background-100}}"}md-autocomplete.md-THEME_NAME-theme button md-icon path{fill:"{{background-600}}"}md-autocomplete.md-THEME_NAME-theme button:after{background:"{{background-600-0.3}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme{background:"{{background-A100}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme li{color:"{{background-900}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight{color:"{{background-600}}"}.md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected,.md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover{background:"{{background-200}}"}md-backdrop{background-color:"{{background-900-0.0}}"}md-backdrop.md-opaque.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-bottom-sheet.md-THEME_NAME-theme{background-color:"{{background-50}}";border-top-color:"{{background-300}}"}md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item{color:"{{foreground-1}}"}md-bottom-sheet.md-THEME_NAME-theme .md-subheader{background-color:"{{background-50}}";color:"{{foreground-1}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]):hover{background-color:"{{background-500-0.2}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover{background-color:transparent}.md-button.md-THEME_NAME-theme.md-fab md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab,.md-button.md-THEME_NAME-theme.md-primary.md-raised{color:"{{primary-contrast}}";background-color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon{color:"{{primary-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover{background-color:"{{primary-600}}"}.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-fab{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-raised{color:"{{background-900}}";background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon{color:"{{background-900}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover{background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused{background-color:"{{background-200}}"}.md-button.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab,.md-button.md-THEME_NAME-theme.md-warn.md-raised{color:"{{warn-contrast}}";background-color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon{color:"{{warn-contrast}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover{background-color:"{{warn-600}}"}.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab,.md-button.md-THEME_NAME-theme.md-accent.md-raised{color:"{{accent-contrast}}";background-color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}";cursor:default}.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,.md-button.md-THEME_NAME-theme[disabled] md-icon{color:"{{foreground-3}}"}.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled]{background-color:"{{foreground-4}}"}.md-button.md-THEME_NAME-theme[disabled]{background-color:transparent}._md a.md-THEME_NAME-theme:not(.md-button).md-primary{color:"{{primary-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover{color:"{{primary-700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent{color:"{{accent-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover{color:"{{accent-A700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn{color:"{{warn-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover{color:"{{warn-700}}"}md-card.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-hue-1}}";border-radius:2px}md-card.md-THEME_NAME-theme .md-card-image{border-radius:2px 2px 0 0}md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon{color:"{{background-color}}";background-color:"{{foreground-3}}"}md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead,md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead{color:"{{foreground-2}}"}md-chips.md-THEME_NAME-theme .md-chips{box-shadow:0 1px "{{foreground-4}}"}md-chips.md-THEME_NAME-theme .md-chips.md-focused{box-shadow:0 2px "{{primary-color}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input{color:"{{foreground-1}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-moz-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-moz-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-ms-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme md-chip{background:"{{background-300}}";color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip md-icon{color:"{{background-700}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused{background:"{{primary-color}}";color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon{color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip._md-chip-editing{background:transparent;color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path{fill:"{{background-500}}"}.md-contact-suggestion span.md-contact-email{color:"{{background-400}}"}md-checkbox.md-THEME_NAME-theme .md-ripple{color:"{{accent-A700}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before{background-color:"{{accent-color-0.26}}"}md-checkbox.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon{background-color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after{border-color:"{{accent-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple{color:"{{primary-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon{background-color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after{border-color:"{{primary-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple{color:"{{warn-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon{background-color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before{background-color:"{{warn-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled]:not(.md-checked) .md-icon{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon{background-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after{border-color:"{{background-200}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-icon:after{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-label{color:"{{foreground-3}}"}md-content.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-default}}"}.md-calendar.md-THEME_NAME-theme{background:"{{background-A100}}";color:"{{background-A200-0.87}}"}.md-calendar.md-THEME_NAME-theme tr:last-child td{border-bottom-color:"{{background-200}}"}.md-THEME_NAME-theme .md-calendar-day-header{background:"{{background-300}}";color:"{{background-A200-0.87}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator{border:1px solid "{{primary-500}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled{color:"{{primary-500-0.6}}"}.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover{background:"{{background-300}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator{background:"{{primary-500}}";color:"{{primary-500-contrast}}";border-color:transparent}.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled{color:"{{background-A200-0.435}}"}.md-THEME_NAME-theme .md-datepicker-input{color:"{{foreground-1}}"}.md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input-container{border-bottom-color:"{{foreground-4}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid,.md-warn .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar-pane{border-color:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle{border-top-color:"{{foreground-2}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon,.md-THEME_NAME-theme .md-datepicker-open.md-accent .md-datepicker-calendar-icon{color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-open.md-warn .md-datepicker-calendar-icon,.md-warn .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar{background:"{{background-A100}}"}.md-THEME_NAME-theme .md-datepicker-input-mask-opaque{box-shadow:0 0 0 9999px "{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container{background:"{{background-hue-1}}"}md-dialog.md-THEME_NAME-theme{border-radius:4px;background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions,md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions,md-divider.md-THEME_NAME-theme{border-top-color:"{{foreground-4}}"}.layout-gt-lg-row>md-divider.md-THEME_NAME-theme,.layout-gt-md-row>md-divider.md-THEME_NAME-theme,.layout-gt-sm-row>md-divider.md-THEME_NAME-theme,.layout-gt-xs-row>md-divider.md-THEME_NAME-theme,.layout-lg-row>md-divider.md-THEME_NAME-theme,.layout-md-row>md-divider.md-THEME_NAME-theme,.layout-row>md-divider.md-THEME_NAME-theme,.layout-sm-row>md-divider.md-THEME_NAME-theme,.layout-xl-row>md-divider.md-THEME_NAME-theme,.layout-xs-row>md-divider.md-THEME_NAME-theme{border-right-color:"{{foreground-4}}"}md-icon.md-THEME_NAME-theme{color:"{{foreground-2}}"}md-icon.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}md-icon.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}md-icon.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-input-container.md-THEME_NAME-theme .md-input{color:"{{foreground-1}}";border-color:"{{foreground-4}}"}md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme>md-icon{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme .md-placeholder,md-input-container.md-THEME_NAME-theme label{color:"{{foreground-3}}"}md-input-container.md-THEME_NAME-theme label.md-required:after{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation,md-input-container.md-THEME_NAME-theme .md-input-messages-animation{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter,md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter{color:"{{foreground-1}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-moz-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-ms-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-webkit-input-placeholder{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label{color:"{{foreground-2}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon{color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent md-icon{color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn md-icon{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter,md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation,md-input-container.md-THEME_NAME-theme.md-input-invalid label{color:"{{warn-A700}}"}[disabled] md-input-container.md-THEME_NAME-theme .md-input,md-input-container.md-THEME_NAME-theme .md-input[disabled]{border-bottom-color:transparent;color:"{{foreground-3}}";background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4{color:"{{foreground-1}}"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style{background-color:"{{background-100}}"}md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon{background-color:"{{foreground-3}}";color:"{{background-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight{color:"{{primary-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight.md-accent{color:"{{accent-color}}"}md-menu-content.md-THEME_NAME-theme{background-color:"{{background-A100}}"}md-menu-content.md-THEME_NAME-theme md-menu-item{color:"{{background-A200-0.87}}"}md-menu-content.md-THEME_NAME-theme md-menu-item md-icon{color:"{{background-A200-0.54}}"}md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled],md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon{color:"{{background-A200-0.25}}"}md-menu-content.md-THEME_NAME-theme md-menu-divider{background-color:"{{background-A200-0.11}}"}md-menu-bar.md-THEME_NAME-theme>button.md-button{color:"{{foreground-2}}";border-radius:2px}md-menu-bar.md-THEME_NAME-theme md-menu.md-open>button,md-menu-bar.md-THEME_NAME-theme md-menu>button:focus{outline:none;background:"{{background-200}}"}md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover>button{background-color:"{{background-500-0.2}}"}md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover{background:transparent}md-menu-content.md-THEME_NAME-theme .md-menu>.md-button:after{color:"{{background-A200-0.54}}"}md-menu-content.md-THEME_NAME-theme .md-menu.md-open>.md-button{background-color:"{{background-500-0.2}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar{background-color:"{{background-A100}}";color:"{{background-A200}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler{background-color:"{{primary-color}}";color:"{{background-A100-0.87}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon{color:"{{background-A100-0.87}}"}md-nav-bar.md-THEME_NAME-theme .md-nav-bar{background-color:transparent;border-color:"{{foreground-4}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected{color:"{{foreground-2}}"}md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar{background-color:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar{background-color:"{{warn-color}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar{background-color:"{{primary-color}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{primary-color}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar md-nav-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}._md-panel-backdrop.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-progress-circular.md-THEME_NAME-theme path{stroke:"{{primary-color}}"}md-progress-circular.md-THEME_NAME-theme.md-warn path{stroke:"{{warn-color}}"}md-progress-circular.md-THEME_NAME-theme.md-accent path{stroke:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme .md-container{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme .md-bar{background-color:"{{primary-color}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-container{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar{background-color:"{{warn-color}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-container{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar{background-color:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-bar1{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-dashed:before{background:radial-gradient("{{primary-100}}" 0,"{{primary-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before{background:radial-gradient("{{warn-100}}" 0,"{{warn-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before{background:radial-gradient("{{accent-100}}" 0,"{{accent-100}}" 16%,transparent 42%)}md-radio-button.md-THEME_NAME-theme .md-off{border-color:"{{foreground-2}}"}md-radio-button.md-THEME_NAME-theme .md-on{background-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-off{border-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme .md-container .md-ripple{color:"{{accent-A700}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on{background-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off{border-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple{color:"{{primary-600}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on{background-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off{border-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple{color:"{{warn-600}}"}md-radio-button.md-THEME_NAME-theme[disabled],md-radio-group.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}"}md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on{border-color:"{{foreground-3}}"}md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple{color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple,md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple{color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple{color:"{{warn-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before{background-color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before{background-color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before{background-color:"{{warn-color-0.26}}"}md-input-container md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-input-container:not(.md-input-focused):not(.md-input-invalid) md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{foreground-3}}"}md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value,md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{primary-color}}"}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme[disabled] .md-select-value{border-bottom-color:transparent;background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%)}md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:"{{foreground-4}}"}md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched .md-select-value{color:"{{warn-A700}}"!important;border-bottom-color:"{{warn-A700}}"!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value{border-bottom-color:"{{primary-color}}";color:"{{foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder{color:"{{foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value{border-bottom-color:"{{accent-color}}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value{border-bottom-color:"{{warn-color}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-icon,md-select.md-THEME_NAME-theme[disabled] .md-select-value,md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-icon{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content{background:"{{background-A100}}"}md-select-menu.md-THEME_NAME-theme md-content md-optgroup{color:"{{background-600-0.87}}"}md-select-menu.md-THEME_NAME-theme md-content md-option{color:"{{background-900-0.87}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] .md-text{color:"{{background-400-0.87}}"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus,md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover{background:"{{background-200}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]{color:"{{primary-500}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus{color:"{{primary-600}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent{color:"{{accent-color}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus{color:"{{accent-A700}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple{color:"{{primary-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple{color:"{{background-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple{color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon{background-color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after{border-color:"{{primary-contrast-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text{color:"{{background-900-0.87}}"}md-sidenav.md-THEME_NAME-theme,md-sidenav.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-slider.md-THEME_NAME-theme .md-track{background-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme .md-track-ticks{color:"{{background-contrast}}"}md-slider.md-THEME_NAME-theme .md-focus-ring{background-color:"{{accent-A200-0.2}}"}md-slider.md-THEME_NAME-theme .md-disabled-thumb{border-color:"{{background-color}}";background-color:"{{background-color}}"}md-slider.md-THEME_NAME-theme.md-min .md-thumb:after{background-color:"{{background-color}}";border-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme.md-min .md-focus-ring{background-color:"{{foreground-3-0.38}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-thumb:after{background-color:"{{background-contrast}}";border-color:transparent}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme .md-track.md-track-fill{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb:after{border-color:"{{accent-color}}";background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign:after{border-top-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb-text{color:"{{accent-contrast}}"}md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring{background-color:"{{warn-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after{border-color:"{{warn-color}}";background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign:after{border-top-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text{color:"{{warn-contrast}}"}md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring{background-color:"{{primary-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after{border-color:"{{primary-color}}";background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign:after{border-top-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text{color:"{{primary-contrast}}"}md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after{border-color:transparent}md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after,md-slider.md-THEME_NAME-theme[disabled][md-discrete] .md-thumb:after{background-color:"{{foreground-3}}";border-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-disabled-thumb{border-color:transparent;background-color:transparent}md-slider-container[disabled]>:first-child:not(md-slider),md-slider-container[disabled]>:last-child:not(md-slider){color:"{{foreground-3}}"}.md-subheader.md-THEME_NAME-theme{color:"{{foreground-2-0.23 }}";background-color:"{{background-default}}"}.md-subheader.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-subheader.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-subheader.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme .md-ink-ripple{color:"{{background-500}}"}md-switch.md-THEME_NAME-theme .md-thumb{background-color:"{{background-50}}"}md-switch.md-THEME_NAME-theme .md-bar{background-color:"{{background-500}}"}md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked .md-thumb{background-color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked .md-bar{background-color:"{{accent-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before{background-color:"{{accent-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple{color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb{background-color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar{background-color:"{{primary-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before{background-color:"{{primary-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb{background-color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar{background-color:"{{warn-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before{background-color:"{{warn-color-0.26}}"}md-switch.md-THEME_NAME-theme[disabled] .md-thumb{background-color:"{{background-400}}"}md-switch.md-THEME_NAME-theme[disabled] .md-bar{background-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme md-tabs-wrapper{background-color:transparent;border-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme .md-paginator md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme md-ink-bar{color:"{{accent-color}}";background:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme .md-tab{color:"{{foreground-2}}"}md-tabs.md-THEME_NAME-theme .md-tab[disabled],md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon{color:"{{foreground-3}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-active,md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon,md-tabs.md-THEME_NAME-theme .md-tab.md-focused,md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon{color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-focused{background:"{{primary-color-0.1}}"}md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper{background-color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper{background-color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper{background-color:"{{warn-color}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{primary-color}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-100}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{accent-A100}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:"{{primary-600-1}}";background:"{{primary-600-1}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-100}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-contrast-0.1}}"}md-toast.md-THEME_NAME-theme .md-toast-content{background-color:#323232;color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button{color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight{color:"{{accent-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary{color:"{{primary-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn{color:"{{warn-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar){background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon{color:"{{primary-contrast}}";fill:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon{color:"{{primary-contrast-0.26}}";fill:"{{primary-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple{color:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon{color:"{{accent-contrast}}";fill:"{{accent-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon{color:"{{accent-contrast-0.26}}";fill:"{{accent-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn{background-color:"{{warn-color}}";color:"{{warn-contrast}}"}.md-panel.md-tooltip.md-THEME_NAME-theme{color:"{{background-700-contrast}}";background-color:"{{background-700}}"}body.md-THEME_NAME-theme,html.md-THEME_NAME-theme{color:"{{foreground-1}}";background-color:"{{background-color}}"}', );})();})(window, window.angular); window.ngMaterial = {version: {full: '1.1.5' }}; ('use strict'); angular.module( 'ngLocale', [], [ '$provide', function ($provide) {var PLURAL_CATEGORY = {ZERO: 'zero', ONE: 'one', TWO: 'two', FEW: 'few', MANY: 'many', OTHER: 'other' }; function getDecimals(n) {n = n + ''; var i = n.indexOf('.'); return i == -1 ? 0 : n.length - i - 1;}function getVF(n, opt_precision) {var v = opt_precision; if (undefined === v) {v = Math.min(getDecimals(n), 3);}var base = Math.pow(10, v); var f = ((n * base) | 0) % base; return {v: v, f: f };}$provide.value('$locale', {DATETIME_FORMATS: {AMPMS: ['vorm.', 'nachm.'], DAY: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'], ERANAMES: ['v. Chr.', 'n. Chr.'], ERAS: ['v. Chr.', 'n. Chr.'], FIRSTDAYOFWEEK: 0, MONTH: ['Januar', 'Februar', 'M\u00e4rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'], SHORTDAY: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'], SHORTMONTH: ['Jan.', 'Feb.', 'M\u00e4rz', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'], STANDALONEMONTH: ['Januar', 'Februar', 'M\u00e4rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'], WEEKENDRANGE: [5, 6], fullDate: 'EEEE, d. MMMM y', longDate: 'd. MMMM y', medium: 'dd.MM.y HH:mm:ss', mediumDate: 'dd.MM.y', mediumTime: 'HH:mm:ss', short: 'dd.MM.yy HH:mm', shortDate: 'dd.MM.yy', shortTime: 'HH:mm', }, NUMBER_FORMATS: {CURRENCY_SYM: '\u20ac', DECIMAL_SEP: ',', GROUP_SEP: '.', PATTERNS: [ {gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: '-', negSuf: '', posPre: '', posSuf: '', }, {gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: '-', negSuf: '\u00a0\u00a4', posPre: '', posSuf: '\u00a0\u00a4', }, ], }, id: 'de-de', localeID: 'de_DE', pluralCat: function (n, opt_precision) {var i = n | 0; var vf = getVF(n, opt_precision); if (i == 1 && vf.v == 0) {return PLURAL_CATEGORY.ONE;}return PLURAL_CATEGORY.OTHER;}, });}, ], ); (function () {var COUNT_FRAMERATE, COUNT_MS_PER_FRAME, DIGIT_FORMAT, DIGIT_HTML, DIGIT_SPEEDBOOST, DURATION, FORMAT_MARK_HTML, FORMAT_PARSER, FRAMERATE, FRAMES_PER_VALUE, MS_PER_FRAME, MutationObserver, Odometer, RIBBON_HTML, TRANSITION_END_EVENTS, TRANSITION_SUPPORT, VALUE_HTML, addClass, createFromHTML, fractionalPart, now, removeClass, requestAnimationFrame, round, transitionCheckStyles, trigger, truncate, wrapJQuery, _jQueryWrapped, _old, _ref, _ref1, __slice = [].slice; VALUE_HTML = '<span class="odometer-value"></span>'; RIBBON_HTML = '<span class="odometer-ribbon"><span class="odometer-ribbon-inner">' + VALUE_HTML + '</span></span>'; DIGIT_HTML = '<span class="odometer-digit"><span class="odometer-digit-spacer">8</span><span class="odometer-digit-inner">' + RIBBON_HTML + '</span></span>'; FORMAT_MARK_HTML = '<span class="odometer-formatting-mark"></span>'; DIGIT_FORMAT = '(,ddd).dd'; FORMAT_PARSER = /^\(?([^)]*)\)?(?:(.)(d+))?$/; FRAMERATE = 30; DURATION = 2000; COUNT_FRAMERATE = 20; FRAMES_PER_VALUE = 2; DIGIT_SPEEDBOOST = 0.5; MS_PER_FRAME = 1000 / FRAMERATE; COUNT_MS_PER_FRAME = 1000 / COUNT_FRAMERATE; TRANSITION_END_EVENTS = 'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd'; transitionCheckStyles = document.createElement('div').style; TRANSITION_SUPPORT = transitionCheckStyles.transition != null || transitionCheckStyles.webkitTransition != null || transitionCheckStyles.mozTransition != null || transitionCheckStyles.oTransition != null; requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver; createFromHTML = function (html) {var el; el = document.createElement('div'); el.innerHTML = html; return el.children[0];}; removeClass = function (el, name) {return (el.className = el.className.replace(new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi'), ' '));}; addClass = function (el, name) {removeClass(el, name); return (el.className += ' ' + name);}; trigger = function (el, name) {var evt; if (document.createEvent != null) {evt = document.createEvent('HTMLEvents'); evt.initEvent(name, true, true); return el.dispatchEvent(evt);}}; now = function () {var _ref, _ref1; return (_ref = (_ref1 = window.performance) != null ? (typeof _ref1.now === 'function' ? _ref1.now() : void 0) : void 0) != null ? _ref : +new Date();}; round = function (val, precision) {if (precision == null) {precision = 0;}if (!precision) {return Math.round(val);}val *= Math.pow(10, precision); val += 0.5; val = Math.floor(val); return (val /= Math.pow(10, precision));}; truncate = function (val) {if (val < 0) {return Math.ceil(val);}else {return Math.floor(val);}}; fractionalPart = function (val) {return val - round(val);}; _jQueryWrapped = false; (wrapJQuery = function () {var property, _i, _len, _ref, _results; if (_jQueryWrapped) {return;}if (window.jQuery != null) {_jQueryWrapped = true; _ref = ['html', 'text']; _results = []; for (_i = 0, _len = _ref.length; _i < _len; _i++) {property = _ref[_i]; _results.push( (function (property) {var old; old = window.jQuery.fn[property]; return (window.jQuery.fn[property] = function (val) {var _ref1; if (val == null || ((_ref1 = this[0]) != null ? _ref1.odometer : void 0) == null) {return old.apply(this, arguments);}return this[0].odometer.update(val);});})(property), );}return _results;}})(); setTimeout(wrapJQuery, 0); Odometer = (function () {function Odometer(options) {var e, k, property, v, _base, _i, _len, _ref, _ref1, _ref2, _this = this; this.options = options; this.el = this.options.el; if (this.el.odometer != null) {return this.el.odometer;}this.el.odometer = this; _ref = Odometer.options; for (k in _ref) {v = _ref[k]; if (this.options[k] == null) {this.options[k] = v;}}if ((_base = this.options).duration == null) {_base.duration = DURATION;}this.MAX_VALUES = (this.options.duration / MS_PER_FRAME / FRAMES_PER_VALUE) | 0; this.resetFormat(); this.value = this.cleanValue((_ref1 = this.options.value) != null ? _ref1 : ''); this.renderInside(); this.render(); try {_ref2 = ['innerHTML', 'innerText', 'textContent']; for (_i = 0, _len = _ref2.length; _i < _len; _i++) {property = _ref2[_i]; if (this.el[property] != null) {(function (property) {return Object.defineProperty(_this.el, property, {get: function () {var _ref3; if (property === 'innerHTML') {return _this.inside.outerHTML;}else {return (_ref3 = _this.inside.innerText) != null ? _ref3 : _this.inside.textContent;}}, set: function (val) {return _this.update(val);}, });})(property);}}}catch (_error) {e = _error; this.watchForMutations();}this;}Odometer.prototype.renderInside = function () {this.inside = document.createElement('div'); this.inside.className = 'odometer-inside'; this.el.innerHTML = ''; return this.el.appendChild(this.inside);}; Odometer.prototype.watchForMutations = function () {var e, _this = this; if (MutationObserver == null) {return;}try {if (this.observer == null) {this.observer = new MutationObserver(function (mutations) {var newVal; newVal = _this.el.innerText; _this.renderInside(); _this.render(_this.value); return _this.update(newVal);});}this.watchMutations = true; return this.startWatchingMutations();}catch (_error) {e = _error;}}; Odometer.prototype.startWatchingMutations = function () {if (this.watchMutations) {return this.observer.observe(this.el, {childList: true, });}}; Odometer.prototype.stopWatchingMutations = function () {var _ref; return (_ref = this.observer) != null ? _ref.disconnect() : void 0;}; Odometer.prototype.cleanValue = function (val) {var _ref; if (typeof val === 'string') {val = val.replace((_ref = this.format.radix) != null ? _ref : '.', '<radix>'); val = val.replace(/[.,]/g, ''); val = val.replace('<radix>', '.'); val = parseFloat(val, 10) || 0;}return round(val, this.format.precision);}; Odometer.prototype.bindTransitionEnd = function () {var event, renderEnqueued, _i, _len, _ref, _results, _this = this; if (this.transitionEndBound) {return;}this.transitionEndBound = true; renderEnqueued = false; _ref = TRANSITION_END_EVENTS.split(' '); _results = []; for (_i = 0, _len = _ref.length; _i < _len; _i++) {event = _ref[_i]; _results.push( this.el.addEventListener( event, function () {if (renderEnqueued) {return true;}renderEnqueued = true; setTimeout(function () {_this.render(); renderEnqueued = false; return trigger(_this.el, 'odometerdone');}, 0); return true;}, false, ), );}return _results;}; Odometer.prototype.resetFormat = function () {var format, fractional, parsed, precision, radix, repeating, _ref, _ref1; format = (_ref = this.options.format) != null ? _ref : DIGIT_FORMAT; format || (format = 'd'); parsed = FORMAT_PARSER.exec(format); if (!parsed) {throw new Error('Odometer: Unparsable digit format');}(_ref1 = parsed.slice(1, 4)), (repeating = _ref1[0]), (radix = _ref1[1]), (fractional = _ref1[2]); precision = (fractional != null ? fractional.length : void 0) || 0; return (this.format = {repeating: repeating, radix: radix, precision: precision, });}; Odometer.prototype.render = function (value) {var classes, cls, match, newClasses, theme, _i, _len; if (value == null) {value = this.value;}this.stopWatchingMutations(); this.resetFormat(); this.inside.innerHTML = ''; theme = this.options.theme; classes = this.el.className.split(' '); newClasses = []; for (_i = 0, _len = classes.length; _i < _len; _i++) {cls = classes[_i]; if (!cls.length) {continue;}if ((match = /^odometer-theme-(.+)$/.exec(cls))) {theme = match[1]; continue;}if (/^odometer(-|$)/.test(cls)) {continue;}newClasses.push(cls);}newClasses.push('odometer'); if (!TRANSITION_SUPPORT) {newClasses.push('odometer-no-transitions');}if (theme) {newClasses.push('odometer-theme-' + theme);}else {newClasses.push('odometer-auto-theme');}this.el.className = newClasses.join(' '); this.ribbons = {}; this.formatDigits(value); return this.startWatchingMutations();}; Odometer.prototype.formatDigits = function (value) {var digit, valueDigit, valueString, wholePart, _i, _j, _len, _len1, _ref, _ref1; this.digits = []; if (this.options.formatFunction) {valueString = this.options.formatFunction(value); _ref = valueString.split('').reverse(); for (_i = 0, _len = _ref.length; _i < _len; _i++) {valueDigit = _ref[_i]; if (valueDigit.match(/0-9/)) {digit = this.renderDigit(); digit.querySelector('.odometer-value').innerHTML = valueDigit; this.digits.push(digit); this.insertDigit(digit);}else {this.addSpacer(valueDigit);}}}else {wholePart = !this.format.precision || !fractionalPart(value) || false; _ref1 = value.toString().split('').reverse(); for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {digit = _ref1[_j]; if (digit === '.') {wholePart = true;}this.addDigit(digit, wholePart);}}}; Odometer.prototype.update = function (newValue) {var diff, _this = this; newValue = this.cleanValue(newValue); if (!(diff = newValue - this.value)) {return;}removeClass(this.el, 'odometer-animating-up odometer-animating-down odometer-animating'); if (diff > 0) {addClass(this.el, 'odometer-animating-up');}else {addClass(this.el, 'odometer-animating-down');}this.stopWatchingMutations(); this.animate(newValue); this.startWatchingMutations(); setTimeout(function () {_this.el.offsetHeight; return addClass(_this.el, 'odometer-animating');}, 0); return (this.value = newValue);}; Odometer.prototype.renderDigit = function () {return createFromHTML(DIGIT_HTML);}; Odometer.prototype.insertDigit = function (digit, before) {if (before != null) {return this.inside.insertBefore(digit, before);}else if (!this.inside.children.length) {return this.inside.appendChild(digit);}else {return this.inside.insertBefore(digit, this.inside.children[0]);}}; Odometer.prototype.addSpacer = function (chr, before, extraClasses) {var spacer; spacer = createFromHTML(FORMAT_MARK_HTML); spacer.innerHTML = chr; if (extraClasses) {addClass(spacer, extraClasses);}return this.insertDigit(spacer, before);}; Odometer.prototype.addDigit = function (value, repeating) {var chr, digit, resetted, _ref; if (repeating == null) {repeating = true;}if (value === '-') {return this.addSpacer(value, null, 'odometer-negation-mark');}if (value === '.') {return this.addSpacer((_ref = this.format.radix) != null ? _ref : '.', null, 'odometer-radix-mark');}if (repeating) {resetted = false; while (true) {if (!this.format.repeating.length) {if (resetted) {throw new Error('Bad odometer format without digits');}this.resetFormat(); resetted = true;}chr = this.format.repeating[this.format.repeating.length - 1]; this.format.repeating = this.format.repeating.substring(0, this.format.repeating.length - 1); if (chr === 'd') {break;}this.addSpacer(chr);}}digit = this.renderDigit(); digit.querySelector('.odometer-value').innerHTML = value; this.digits.push(digit); return this.insertDigit(digit);}; Odometer.prototype.animate = function (newValue) {if (!TRANSITION_SUPPORT || this.options.animation === 'count') {return this.animateCount(newValue);}else {return this.animateSlide(newValue);}}; Odometer.prototype.animateCount = function (newValue) {var cur, diff, last, start, tick, _this = this; if (!(diff = +newValue - this.value)) {return;}start = last = now(); cur = this.value; return (tick = function () {var delta, dist, fraction; if (now() - start > _this.options.duration) {_this.value = newValue; _this.render(); trigger(_this.el, 'odometerdone'); return;}delta = now() - last; if (delta > COUNT_MS_PER_FRAME) {last = now(); fraction = delta / _this.options.duration; dist = diff * fraction; cur += dist; _this.render(Math.round(cur));}if (requestAnimationFrame != null) {return requestAnimationFrame(tick);}else {return setTimeout(tick, COUNT_MS_PER_FRAME);}})();}; Odometer.prototype.getDigitCount = function () {var i, max, value, values, _i, _len; values = 1 <= arguments.length ? __slice.call(arguments, 0) : []; for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {value = values[i]; values[i] = Math.abs(value);}max = Math.max.apply(Math, values); return Math.ceil(Math.log(max + 1) / Math.log(10));}; Odometer.prototype.getFractionalDigitCount = function () {var i, parser, parts, value, values, _i, _len; values = 1 <= arguments.length ? __slice.call(arguments, 0) : []; parser = /^\-?\d*\.(\d*?)0*$/; for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {value = values[i]; values[i] = value.toString(); parts = parser.exec(values[i]); if (parts == null) {values[i] = 0;}else {values[i] = parts[1].length;}}return Math.max.apply(Math, values);}; Odometer.prototype.resetDigits = function () {this.digits = []; this.ribbons = []; this.inside.innerHTML = ''; return this.resetFormat();}; Odometer.prototype.animateSlide = function (newValue) {var boosted, cur, diff, digitCount, digits, dist, end, fractionalCount, frame, frames, i, incr, j, mark, numEl, oldValue, start, _base, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _results; oldValue = this.value; fractionalCount = this.getFractionalDigitCount(oldValue, newValue); if (fractionalCount) {newValue = newValue * Math.pow(10, fractionalCount); oldValue = oldValue * Math.pow(10, fractionalCount);}if (!(diff = newValue - oldValue)) {return;}this.bindTransitionEnd(); digitCount = this.getDigitCount(oldValue, newValue); digits = []; boosted = 0; for (i = _i = 0; 0 <= digitCount ? _i < digitCount : _i > digitCount; i = 0 <= digitCount ? ++_i : --_i) {start = truncate(oldValue / Math.pow(10, digitCount - i - 1)); end = truncate(newValue / Math.pow(10, digitCount - i - 1)); dist = end - start; if (Math.abs(dist) > this.MAX_VALUES) {frames = []; incr = dist / (this.MAX_VALUES + this.MAX_VALUES * boosted * DIGIT_SPEEDBOOST); cur = start; while ((dist > 0 && cur < end) || (dist < 0 && cur > end)) {frames.push(Math.round(cur)); cur += incr;}if (frames[frames.length - 1] !== end) {frames.push(end);}boosted++;}else {frames = function () {_results = []; for (var _j = start; start <= end ? _j <= end : _j >= end; start <= end ? _j++ : _j--) {_results.push(_j);}return _results;}.apply(this);}for (i = _k = 0, _len = frames.length; _k < _len; i = ++_k) {frame = frames[i]; frames[i] = Math.abs(frame % 10);}digits.push(frames);}this.resetDigits(); _ref = digits.reverse(); for (i = _l = 0, _len1 = _ref.length; _l < _len1; i = ++_l) {frames = _ref[i]; if (!this.digits[i]) {this.addDigit(' ', i >= fractionalCount);}if ((_base = this.ribbons)[i] == null) {_base[i] = this.digits[i].querySelector('.odometer-ribbon-inner');}this.ribbons[i].innerHTML = ''; if (diff < 0) {frames = frames.reverse();}for (j = _m = 0, _len2 = frames.length; _m < _len2; j = ++_m) {frame = frames[j]; numEl = document.createElement('div'); numEl.className = 'odometer-value'; numEl.innerHTML = frame; this.ribbons[i].appendChild(numEl); if (j === frames.length - 1) {addClass(numEl, 'odometer-last-value');}if (j === 0) {addClass(numEl, 'odometer-first-value');}}}if (start < 0) {this.addDigit('-');}mark = this.inside.querySelector('.odometer-radix-mark'); if (mark != null) {mark.parent.removeChild(mark);}if (fractionalCount) {return this.addSpacer(this.format.radix, this.digits[fractionalCount - 1], 'odometer-radix-mark');}}; return Odometer;})(); Odometer.options = (_ref = window.odometerOptions) != null ? _ref : {}; setTimeout(function () {var k, v, _base, _ref1, _results; if (window.odometerOptions) {_ref1 = window.odometerOptions; _results = []; for (k in _ref1) {v = _ref1[k]; _results.push((_base = Odometer.options)[k] != null ? (_base = Odometer.options)[k] : (_base[k] = v));}return _results;}}, 0); Odometer.init = function () {var el, elements, _i, _len, _ref1, _results; if (document.querySelectorAll == null) {return;}elements = document.querySelectorAll(Odometer.options.selector || '.odometer'); _results = []; for (_i = 0, _len = elements.length; _i < _len; _i++) {el = elements[_i]; _results.push( (el.odometer = new Odometer({el: el, value: (_ref1 = el.innerText) != null ? _ref1 : el.textContent, })), );}return _results;}; if (((_ref1 = document.documentElement) != null ? _ref1.doScroll : void 0) != null && document.createEventObject != null) {_old = document.onreadystatechange; document.onreadystatechange = function () {if (document.readyState === 'complete' && Odometer.options.auto !== false) {Odometer.init();}return _old != null ? _old.apply(this, arguments) : void 0;};}else {document.addEventListener( 'DOMContentLoaded', function () {if (Odometer.options.auto !== false) {return Odometer.init();}}, false, );}if (typeof define === 'function' && define.amd) {define([], function () {return Odometer;});}else if (typeof exports !== 'undefined' && exports !== null) {module.exports = Odometer;}else {window.Odometer = Odometer;}}.call(this)); (function ($) {$.fn.flowtype = function (options) {var settings = $.extend( {maximum: 9999, minimum: 1, maxFont: 9999, minFont: 1, fontRatio: 35, }, options, ), changes = function (el) {var $el = $(el), elw = $el.width(), width = elw > settings.maximum ? settings.maximum : elw < settings.minimum ? settings.minimum : elw, fontBase = width / settings.fontRatio, fontSize = fontBase > settings.maxFont ? settings.maxFont : fontBase < settings.minFont ? settings.minFont : fontBase; $el.css('font-size', fontSize + 'px');}; return this.each(function () {var that = this; $(window).resize(function () {changes(that);}); changes(this);});};})(jQuery); (function () {'use strict'; angular.module('ngFlowtype', []); angular.module('ngFlowtype').directive('flowtype', flowtype); flowtype.$inject = []; function flowtype() {return {restrict: 'A', link: link, }; function link(scope, element, attrs) {var options = {}; options.maximum = attrs.maximum || 9999; options.minimum = attrs.minimum || 1; options.minFont = attrs.minFont || 1; options.maxFont = attrs.maxFont || 9999; options.fontRatio = attrs.fontRatio || 35; options.lineRatio = attrs.lineRatio || 1.45; element.flowtype(options);}}})(); (function () {'use strict'; angular.module('ps', ['ps.sync', 'ps.storage', 'ps.presentation', 'ngAnimate']); angular.module('ps').run(function (SyncService, StorageService) {SyncService.updatePresentationScope(); StorageService.onChange(SyncService.updatePresentationScope);});})(); (function () {'use strict'; angular.module('ps.sync', []);})(); (function () {'use strict'; angular.module('ps.sync').service('SyncService', function ($rootScope, StorageService) {this.updatePresentationScope = function () {return StorageService.getItem('presentation') .then(function (presentation) {if (presentation) {$rootScope.presentation = presentation;}else {$rootScope.presentation = {};}}) .catch(function (e) {console.trace(e.stack); console.error('failed to get presentation from storage');});}; this.updateEventScope = function () {return StorageService.getItem('event') .then(function (event) {if (event) {$rootScope.event = event;}else {$rootScope.event = {participants: [], competitions: [], view: {}, };}}) .catch(function (e) {console.trace(e.stack); console.error('failed to get event from storage');});}; this.persistScope = function (event) {if (event) {StorageService.setItem('event', event) .then(function () {}) .catch(function (e) {console.trace(e.stack); console.error('failed to set event in storage');});}}; return this;});})(); (function () {'use strict'; angular.module('ps.storage', []).constant('env', {runtime: window.chrome && chrome.runtime && chrome.runtime.id ? 'chrome' : 'web', });})(); (function (angular) {'use strict'; angular .module('ps.storage') .service('StorageService', function (env, ChromeStorageService, LocalStorageService) {var storage = null; if (env.runtime == 'chrome') {storage = ChromeStorageService;}else if (env.runtime == 'web') {storage = LocalStorageService;}else {throw new Error('unkown storage type found. is not chrome or web. please add in StorageService.js');}return storage;}) .service('ChromeStorageService', function ($q) {var getStore = function () {return chrome.storage.local;}; this.getAll = function () {return $q(function (resolve) {getStore().get(null, function (values) {resolve(values);});});}; this.getItem = function (key) {return $q(function (resolve) {getStore().get(key, function (value) {resolve(value[key]);});});}; this.setItem = function (key, value) {return $q(function (resolve) {var obj = {}; obj[key] = value; getStore().set(obj, function () {resolve();});});}; this.removeItem = function (key) {return $q(function (resolve) {getStore().remove(key, function () {resolve();});});}; this.clear = function () {return $q(function (resolve, reject) {getStore().clear(function () {getStore().get(function (result) {if (Object.keys(result) > 0) {reject();}else {resolve();}});});});}; this.onChange = function (callback) {chrome.storage.onChanged.addListener(callback);};}) .service('LocalStorageService', function ($window, $q) {this.getItem = function (key) {return $q(function (resolve) {resolve(angular.fromJson($window.localStorage.getItem(key)));});}; this.getAll = function () {return $q(function (resolve) {var arrayToReturn = []; for (var i = 0, len = localStorage.length; i < len; ++i) {arrayToReturn.push(localStorage.getItem(localStorage.key(i)));}resolve(arrayToReturn);});}; this.setItem = function (key, value) {return $q(function (resolve) {$window.localStorage.setItem(key, angular.toJson(value)); resolve();});}; this.removeItem = function (key) {return $q(function (resolve) {$window.localStorage.removeItem(key); resolve();});}; this.clear = function () {return $q(function (resolve) {$window.localStorage.clear(); resolve();});}; this.onChange = function (callback) {$window.addEventListener('storage', callback);};});})(angular); (function () {'use strict'; angular.module('ps.presentation', ['ngMaterial']);})(); (function () {'use strict'; angular.module('ps.presentation').directive('intro', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/intro.html', };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('participant', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/participant.html', };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('group', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/group.html', };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('groupRatings', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/groupRatings.html', };});})(); (function () {'use strict'; angular.module('ps').directive('odometer', function ($timeout, $filter) {Odometer.prototype.getFractionalDigitCount = function () {return 1;}; return {restrict: 'E', template: '<span><span class="odometer" ng-show="valueSet"></span><span ng-hide="valueSet" class="hide-instant">?</span></span>', link: function (scope, element, attrs) {scope.valueSet = false; var odometer = new Odometer({el: element[0].querySelector('.odometer'), duration: 10000, format: '( ddd),d', formatFunction: function (value) {return $filter('number')(value, 1);}, value: 0, }); var updateDelay = attrs.delay || 1000; scope.$watch(attrs.value, function (newValue) {$timeout(function () {scope.valueSet = true; odometer.update(newValue);}, updateDelay);});}, };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('ratingParticipant', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/ratingParticipant.html', };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('competitionRatings', function ($timeout) {return {restrict: 'E', templateUrl: './modules/presentation/partials/competitionRatings.html', controller: function ($scope) {$scope.isWinnerRowVisible = function (index) {var number = $scope.presentation.winnerList.length - index; if ($scope.presentation.showWinnersInReverseOrder) {number = index + 1;}return number <= $scope.presentation.winnersToShow;};}, };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('customText', function () {return {restrict: 'E', templateUrl: './modules/presentation/partials/customText.html', };});})(); (function (window, document, exports, global, define, undefined) {(function () {function r(a, b) {n[l] = a; n[l + 1] = b; l += 2; 2 === l && A();}function s(a) {return 'function' === typeof a;}function F() {return function () {process.nextTick(t);};}function G() {var a = 0, b = new B(t), c = document.createTextNode(''); b.observe(c, {characterData: !0 }); return function () {c.data = a = ++a % 2;};}function H() {var a = new MessageChannel(); a.port1.onmessage = t; return function () {a.port2.postMessage(0);};}function I() {return function () {setTimeout(t, 1);};}function t() {for (var a = 0; a < l; a += 2) (0, n[a])(n[a + 1]), (n[a] = void 0), (n[a + 1] = void 0); l = 0;}function p() {}function J(a, b, c, d) {try {a.call(b, c, d);}catch (e) {return e;}}function K(a, b, c) {r(function (a) {var e = !1, f = J( c, b, function (c) {e || ((e = !0), b !== c ? q(a, c) : m(a, c));}, function (b) {e || ((e = !0), g(a, b));}, ); !e && f && ((e = !0), g(a, f));}, a);}function L(a, b) {1 === b.a ? m(a, b.b) : 2 === a.a ? g(a, b.b) : u( b, void 0, function (b) {q(a, b);}, function (b) {g(a, b);}, );}function q(a, b) {if (a === b) g(a, new TypeError('You cannot resolve a promise with itself')); else if ('function' === typeof b || ('object' === typeof b && null !== b)) if (b.constructor === a.constructor) L(a, b); else {var c; try {c = b.then;}catch (d) {(v.error = d), (c = v);}c === v ? g(a, v.error) : void 0 === c ? m(a, b) : s(c) ? K(a, b, c) : m(a, b);}else m(a, b);}function M(a) {a.f && a.f(a.b); x(a);}function m(a, b) {void 0 === a.a && ((a.b = b), (a.a = 1), 0 !== a.e.length && r(x, a));}function g(a, b) {void 0 === a.a && ((a.a = 2), (a.b = b), r(M, a));}function u(a, b, c, d) {var e = a.e, f = e.length; a.f = null; e[f] = b; e[f + 1] = c; e[f + 2] = d; 0 === f && a.a && r(x, a);}function x(a) {var b = a.e, c = a.a; if (0 !== b.length) {for (var d, e, f = a.b, g = 0; g < b.length; g += 3) (d = b[g]), (e = b[g + c]), d ? C(c, d, e, f) : e(f); a.e.length = 0;}}function D() {this.error = null;}function C(a, b, c, d) {var e = s(c), f, k, h, l; if (e) {try {f = c(d);}catch (n) {(y.error = n), (f = y);}f === y ? ((l = !0), (k = f.error), (f = null)) : (h = !0); if (b === f) {g(b, new TypeError('A promises callback cannot return that same promise.')); return;}}else (f = d), (h = !0); void 0 === b.a && (e && h ? q(b, f) : l ? g(b, k) : 1 === a ? m(b, f) : 2 === a && g(b, f));}function N(a, b) {try {b( function (b) {q(a, b);}, function (b) {g(a, b);}, );}catch (c) {g(a, c);}}function k(a, b, c, d) {this.n = a; this.c = new a(p, d); this.i = c; this.o(b) ? ((this.m = b), (this.d = this.length = b.length), this.l(), 0 === this.length ? m(this.c, this.b) : ((this.length = this.length || 0), this.k(), 0 === this.d && m(this.c, this.b))) : g(this.c, this.p());}function h(a) {O++; this.b = this.a = void 0; this.e = []; if (p !== a) {if (!s(a)) throw new TypeError('You must pass a resolver function as the first argument to the promise constructor'); if (!(this instanceof h)) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."); N(this, a);}}var E = Array.isArray ? Array.isArray : function (a) {return '[object Array]' === Object.prototype.toString.call(a);}, l = 0, w = 'undefined' !== typeof window ? window : {}, B = w.MutationObserver || w.WebKitMutationObserver, w = 'undefined' !== typeof Uint8ClampedArray && 'undefined' !== typeof importScripts && 'undefined' !== typeof MessageChannel, n = Array(1e3), A; A = 'undefined' !== typeof process && '[object process]' === {}.toString.call(process) ? F() : B ? G() : w ? H() : I(); var v = new D(), y = new D(); k.prototype.o = function (a) {return E(a);}; k.prototype.p = function () {return Error('Array Methods must be provided an Array');}; k.prototype.l = function () {this.b = Array(this.length);}; k.prototype.k = function () {for (var a = this.length, b = this.c, c = this.m, d = 0; void 0 === b.a && d < a; d++) this.j(c[d], d);}; k.prototype.j = function (a, b) {var c = this.n; 'object' === typeof a && null !== a ? a.constructor === c && void 0 !== a.a ? ((a.f = null), this.g(a.a, b, a.b)) : this.q(c.resolve(a), b) : (this.d--, (this.b[b] = this.h(a)));}; k.prototype.g = function (a, b, c) {var d = this.c; void 0 === d.a && (this.d--, this.i && 2 === a ? g(d, c) : (this.b[b] = this.h(c))); 0 === this.d && m(d, this.b);}; k.prototype.h = function (a) {return a;}; k.prototype.q = function (a, b) {var c = this; u( a, void 0, function (a) {c.g(1, b, a);}, function (a) {c.g(2, b, a);}, );}; var O = 0; h.all = function (a, b) {return new k(this, a, !0, b).c;}; h.race = function (a, b) {function c(a) {q(e, a);}function d(a) {g(e, a);}var e = new this(p, b); if (!E(a)) return g(e, new TypeError('You must pass an array to race.')), e; for (var f = a.length, h = 0; void 0 === e.a && h < f; h++) u(this.resolve(a[h]), void 0, c, d); return e;}; h.resolve = function (a, b) {if (a && 'object' === typeof a && a.constructor === this) return a; var c = new this(p, b); q(c, a); return c;}; h.reject = function (a, b) {var c = new this(p, b); g(c, a); return c;}; h.prototype = {constructor: h, then: function (a, b) {var c = this.a; if ((1 === c && !a) || (2 === c && !b)) return this; var d = new this.constructor(p), e = this.b; if (c) {var f = arguments[c - 1]; r(function () {C(c, d, f, e);});}else u(this, d, a, b); return d;}, catch: function (a) {return this.then(null, a);}, }; var z = {Promise: h, polyfill: function () {var a; a = 'undefined' !== typeof global ? global : 'undefined' !== typeof window && window.document ? window : self; ('Promise' in a && 'resolve' in a.Promise && 'reject' in a.Promise && 'all' in a.Promise && 'race' in a.Promise && (function () {var b; new a.Promise(function (a) {b = a;}); return s(b);})()) || (a.Promise = h);}, }; 'function' === typeof define && define.amd ? define(function () {return z;}) : 'undefined' !== typeof module && module.exports ? (module.exports = z) : 'undefined' !== typeof this && (this.ES6Promise = z);}.call(window)); if (window) {window.ES6Promise.polyfill();}if (typeof document === 'undefined' || typeof Object.create !== 'function' || typeof document.createElement('canvas').getContext !== 'function') {(window || module.exports).html2canvas = function () {return Promise.reject('No canvas support');}; return;}(function (root) {var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; var freeModule = typeof module == 'object' && module && !module.nodeType && module; var freeGlobal = typeof global == 'object' && global; if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {root = freeGlobal;}var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = '-', regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {overflow: 'Overflow: input needs wider integers to process', 'not-basic': 'Illegal input >= 0x80 (not a basic code point)', 'invalid-input': 'Invalid input', }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key; function error(type) {throw RangeError(errors[type]);}function map(array, fn) {var length = array.length; var result = []; while (length--) {result[length] = fn(array[length]);}return result;}function mapDomain(string, fn) {var parts = string.split('@'); var result = ''; if (parts.length > 1) {result = parts[0] + '@'; string = parts[1];}var labels = string.split(regexSeparators); var encoded = map(labels, fn).join('.'); return result + encoded;}function ucs2decode(string) {var output = [], counter = 0, length = string.length, value, extra; while (counter < length) {value = string.charCodeAt(counter++); if (value >= 0xd800 && value <= 0xdbff && counter < length) {extra = string.charCodeAt(counter++); if ((extra & 0xfc00) == 0xdc00) {output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);}else {output.push(value); counter--;}}else {output.push(value);}}return output;}function ucs2encode(array) {return map(array, function (value) {var output = ''; if (value > 0xffff) {value -= 0x10000; output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800); value = 0xdc00 | (value & 0x3ff);}output += stringFromCharCode(value); return output;}).join('');}function basicToDigit(codePoint) {if (codePoint - 48 < 10) {return codePoint - 22;}if (codePoint - 65 < 26) {return codePoint - 65;}if (codePoint - 97 < 26) {return codePoint - 97;}return base;}function digitToBasic(digit, flag) {return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);}function adapt(delta, numPoints, firstTime) {var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta += floor(delta / numPoints); for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {delta = floor(delta / baseMinusTMin);}return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));}function decode(input) {var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT; basic = input.lastIndexOf(delimiter); if (basic < 0) {basic = 0;}for (j = 0; j < basic; ++j) {if (input.charCodeAt(j) >= 0x80) {error('not-basic');}output.push(input.charCodeAt(j));}for (index = basic > 0 ? basic + 1 : 0; index < inputLength ; ) {for (oldi = i, w = 1, k = base ; ; k += base) {if (index >= inputLength) {error('invalid-input');}digit = basicToDigit(input.charCodeAt(index++)); if (digit >= base || digit > floor((maxInt - i) / w)) {error('overflow');}i += digit * w; t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias; if (digit < t) {break;}baseMinusT = base - t; if (w > floor(maxInt / baseMinusT)) {error('overflow');}w *= baseMinusT;}out = output.length + 1; bias = adapt(i - oldi, out, oldi == 0); if (floor(i / out) > maxInt - n) {error('overflow');}n += floor(i / out); i %= out; output.splice(i++, 0, n);}return ucs2encode(output);}function encode(input) {var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT; input = ucs2decode(input); inputLength = input.length; n = initialN; delta = 0; bias = initialBias; for (j = 0; j < inputLength; ++j) {currentValue = input[j]; if (currentValue < 0x80) {output.push(stringFromCharCode(currentValue));}}handledCPCount = basicLength = output.length; if (basicLength) {output.push(delimiter);}while (handledCPCount < inputLength) {for (m = maxInt, j = 0; j < inputLength; ++j) {currentValue = input[j]; if (currentValue >= n && currentValue < m) {m = currentValue;}}handledCPCountPlusOne = handledCPCount + 1; if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {error('overflow');}delta += (m - n) * handledCPCountPlusOne; n = m; for (j = 0; j < inputLength; ++j) {currentValue = input[j]; if (currentValue < n && ++delta > maxInt) {error('overflow');}if (currentValue == n) {for (q = delta, k = base ; ; k += base) {t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias; if (q < t) {break;}qMinusT = q - t; baseMinusT = base - t; output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0))); q = floor(qMinusT / baseMinusT);}output.push(stringFromCharCode(digitToBasic(q, 0))); bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength); delta = 0; ++handledCPCount;}}++delta; ++n;}return output.join('');}function toUnicode(input) {return mapDomain(input, function (string) {return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;});}function toASCII(input) {return mapDomain(input, function (string) {return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;});}punycode = {version: '1.3.1', ucs2: {decode: ucs2decode, encode: ucs2encode, }, decode: decode, encode: encode, toASCII: toASCII, toUnicode: toUnicode, }; if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {define('punycode', function () {return punycode;});}else if (freeExports && freeModule) {if (module.exports == freeExports) {freeModule.exports = punycode;}else {for (key in punycode) {punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);}}}else {root.punycode = punycode;}})(this); var html2canvasNodeAttribute = 'data-html2canvas-node'; var html2canvasCanvasCloneAttribute = 'data-html2canvas-canvas-clone'; var html2canvasCanvasCloneIndex = 0; var html2canvasCloneIndex = 0; window.html2canvas = function (nodeList, options) {var index = html2canvasCloneIndex++; options = options || {}; if (options.logging) {window.html2canvas.logging = true; window.html2canvas.start = Date.now();}options.async = typeof options.async === 'undefined' ? true : options.async; options.allowTaint = typeof options.allowTaint === 'undefined' ? false : options.allowTaint; options.removeContainer = typeof options.removeContainer === 'undefined' ? true : options.removeContainer; options.javascriptEnabled = typeof options.javascriptEnabled === 'undefined' ? false : options.javascriptEnabled; options.imageTimeout = typeof options.imageTimeout === 'undefined' ? 10000 : options.imageTimeout; options.renderer = typeof options.renderer === 'function' ? options.renderer : CanvasRenderer; options.strict = !!options.strict; if (typeof nodeList === 'string') {if (typeof options.proxy !== 'string') {return Promise.reject('Proxy must be used when rendering url');}var width = options.width != null ? options.width : window.innerWidth; var height = options.height != null ? options.height : window.innerHeight; return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function (container) {return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);});}var node = (nodeList === undefined ? [document.documentElement] : nodeList.length ? nodeList : [nodeList])[0]; node.setAttribute(html2canvasNodeAttribute + index, index); return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then( function (canvas) {if (typeof options.onrendered === 'function') {log('options.onrendered is deprecated, html2canvas returns a Promise containing the canvas'); options.onrendered(canvas);}return canvas;}, );}; window.html2canvas.punycode = this.punycode; window.html2canvas.proxy = {}; function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then( function (container) {log('Document cloned'); var attributeName = html2canvasNodeAttribute + html2canvasIndex; var selector = '[' + attributeName + "='" + html2canvasIndex + "']"; document.querySelector(selector).removeAttribute(attributeName); var clonedWindow = container.contentWindow; var node = clonedWindow.document.querySelector(selector); var oncloneHandler = typeof options.onclone === 'function' ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true); return oncloneHandler.then(function () {return renderWindow(node, container, options, windowWidth, windowHeight);});}, );}function renderWindow(node, container, options, windowWidth, windowHeight) {var clonedWindow = container.contentWindow; var support = new Support(clonedWindow.document); var imageLoader = new ImageLoader(options, support); var bounds = getBounds(node); var width = options.type === 'view' ? windowWidth : documentWidth(clonedWindow.document); var height = options.type === 'view' ? windowHeight : documentHeight(clonedWindow.document); var renderer = new options.renderer(width, height, imageLoader, options, document); var parser = new NodeParser(node, renderer, support, imageLoader, options); return parser.ready.then(function () {log('Finished rendering'); var canvas; if (options.type === 'view') {canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0 });}else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {canvas = renderer.canvas;}else {canvas = crop(renderer.canvas, {width: options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: clonedWindow.pageXOffset, y: clonedWindow.pageYOffset, });}cleanupContainer(container, options); return canvas;});}function cleanupContainer(container, options) {if (options.removeContainer) {container.parentNode.removeChild(container); log('Cleaned up container');}}function crop(canvas, bounds) {var croppedCanvas = document.createElement('canvas'); var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left)); var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width)); var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top)); var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height)); croppedCanvas.width = bounds.width; croppedCanvas.height = bounds.height; log('Cropping canvas at:', 'left:', bounds.left, 'top:', bounds.top, 'width:', x2 - x1, 'height:', y2 - y1); log('Resulting crop with width', bounds.width, 'and height', bounds.height, ' with x', x1, 'and y', y1); croppedCanvas.getContext('2d').drawImage(canvas, x1, y1, x2 - x1, y2 - y1, bounds.x, bounds.y, x2 - x1, y2 - y1); return croppedCanvas;}function documentWidth(doc) {return Math.max( Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth), Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth), Math.max(doc.body.clientWidth, doc.documentElement.clientWidth), );}function documentHeight(doc) {return Math.max( Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight), Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight), Math.max(doc.body.clientHeight, doc.documentElement.clientHeight), );}function smallImage() {return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP }function isIE9() {return document.documentMode && document.documentMode <= 9;}function cloneNodeIE9(node, javascriptEnabled) {var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); var child = node.firstChild; while (child) {if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {clone.appendChild(cloneNodeIE9(child, javascriptEnabled));}child = child.nextSibling;}return clone;}function createWindowClone(ownerDocument, containerDocument, width, height, options, x, y) {labelCanvasElements(ownerDocument); var documentElement = isIE9() ? cloneNodeIE9(ownerDocument.documentElement, options.javascriptEnabled) : ownerDocument.documentElement.cloneNode(true); var container = containerDocument.createElement('iframe'); container.className = 'html2canvas-container'; container.style.visibility = 'hidden'; container.style.position = 'fixed'; container.style.left = '-10000px'; container.style.top = '0px'; container.style.border = '0'; container.width = width; container.height = height; container.scrolling = 'no'; containerDocument.body.appendChild(container); return new Promise(function (resolve) {var documentClone = container.contentWindow.document; cloneNodeValues(ownerDocument.documentElement, documentElement, 'textarea'); cloneNodeValues(ownerDocument.documentElement, documentElement, 'select'); container.contentWindow.onload = container.onload = function () {var interval = setInterval(function () {if (documentClone.body.childNodes.length > 0) {cloneCanvasContents(ownerDocument, documentClone); clearInterval(interval); if (options.type === 'view') {container.contentWindow.scrollTo(x, y);}resolve(container);}}, 50);}; documentClone.open(); documentClone.write('<!DOCTYPE html><html></html>'); restoreOwnerScroll(ownerDocument, x, y); documentClone.replaceChild( options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement, ); documentClone.close();});}function cloneNodeValues(document, clone, nodeName) {var originalNodes = document.getElementsByTagName(nodeName); var clonedNodes = clone.getElementsByTagName(nodeName); var count = originalNodes.length; for (var i = 0; i < count; i++) {clonedNodes[i].value = originalNodes[i].value;}}function restoreOwnerScroll(ownerDocument, x, y) {if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {ownerDocument.defaultView.scrollTo(x, y);}}function loadUrlDocument(src, proxy, document, width, height, options) {return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function (doc) {return createWindowClone(doc, document, width, height, options, 0, 0);});}function documentFromHTML(src) {return function (html) {var parser = new DOMParser(), doc; try {doc = parser.parseFromString(html, 'text/html');}catch (e) {log('DOMParser not supported, falling back to createHTMLDocument'); doc = document.implementation.createHTMLDocument(''); try {doc.open(); doc.write(html); doc.close();}catch (ee) {log('createHTMLDocument write not supported, falling back to document.body.innerHTML'); doc.body.innerHTML = html;}}var b = doc.querySelector('base'); if (!b || !b.href.host) {var base = doc.createElement('base'); base.href = src; doc.head.insertBefore(base, doc.head.firstChild);}return doc;};}function labelCanvasElements(ownerDocument) {[].slice.call(ownerDocument.querySelectorAll('canvas'), 0).forEach(function (canvas) {canvas.setAttribute(html2canvasCanvasCloneAttribute, 'canvas-' + html2canvasCanvasCloneIndex++);});}function cloneCanvasContents(ownerDocument, documentClone) {[].slice.call(ownerDocument.querySelectorAll('[' + html2canvasCanvasCloneAttribute + ']'), 0).forEach(function (canvas) {try {var clonedCanvas = documentClone.querySelector( '[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]', ); if (clonedCanvas) {clonedCanvas.width = canvas.width; clonedCanvas.height = canvas.height; clonedCanvas.getContext('2d').putImageData(canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height), 0, 0);}}catch (e) {log('Unable to copy canvas content from', canvas, e);}canvas.removeAttribute(html2canvasCanvasCloneAttribute);});}function removeScriptNodes(parent) {[].slice .call(parent.childNodes, 0) .filter(isElementNode) .forEach(function (node) {if (node.tagName === 'SCRIPT') {parent.removeChild(node);}else {removeScriptNodes(node);}}); return parent;}function isElementNode(node) {return node.nodeType === Node.ELEMENT_NODE;}function absoluteUrl(url) {var link = document.createElement('a'); link.href = url; link.href = link.href; return link;}function Color(value) {this.r = 0; this.g = 0; this.b = 0; this.a = null; var result = this.fromArray(value) || this.namedColor(value) || this.rgb(value) || this.rgba(value) || this.hex6(value) || this.hex3(value);}Color.prototype.darken = function (amount) {var a = 1 - amount; return new Color([Math.round(this.r * a), Math.round(this.g * a), Math.round(this.b * a), this.a]);}; Color.prototype.isTransparent = function () {return this.a === 0;}; Color.prototype.isBlack = function () {return this.r === 0 && this.g === 0 && this.b === 0;}; Color.prototype.fromArray = function (array) {if (Array.isArray(array)) {this.r = Math.min(array[0], 255); this.g = Math.min(array[1], 255); this.b = Math.min(array[2], 255); if (array.length > 3) {this.a = array[3];}}return Array.isArray(array);}; var _hex3 = /^#([a-f0-9]{3})$/i; Color.prototype.hex3 = function (value) {var match = null; if ((match = value.match(_hex3)) !== null) {this.r = parseInt(match[1][0] + match[1][0], 16); this.g = parseInt(match[1][1] + match[1][1], 16); this.b = parseInt(match[1][2] + match[1][2], 16);}return match !== null;}; var _hex6 = /^#([a-f0-9]{6})$/i; Color.prototype.hex6 = function (value) {var match = null; if ((match = value.match(_hex6)) !== null) {this.r = parseInt(match[1].substring(0, 2), 16); this.g = parseInt(match[1].substring(2, 4), 16); this.b = parseInt(match[1].substring(4, 6), 16);}return match !== null;}; var _rgb = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/; Color.prototype.rgb = function (value) {var match = null; if ((match = value.match(_rgb)) !== null) {this.r = Number(match[1]); this.g = Number(match[2]); this.b = Number(match[3]);}return match !== null;}; var _rgba = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/; Color.prototype.rgba = function (value) {var match = null; if ((match = value.match(_rgba)) !== null) {this.r = Number(match[1]); this.g = Number(match[2]); this.b = Number(match[3]); this.a = Number(match[4]);}return match !== null;}; Color.prototype.toString = function () {return this.a !== null && this.a !== 1 ? 'rgba(' + [this.r, this.g, this.b, this.a].join(',') + ')' : 'rgb(' + [this.r, this.g, this.b].join(',') + ')';}; Color.prototype.namedColor = function (value) {var color = colors[value.toLowerCase()]; if (color) {this.r = color[0]; this.g = color[1]; this.b = color[2];}else if (value.toLowerCase() === 'transparent') {this.r = this.g = this.b = this.a = 0; return true;}return !!color;}; Color.prototype.isColor = true; var colors = {aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50], }; function DummyImageContainer(src) {this.src = src; log('DummyImageContainer for', src); if (!this.promise || !this.image) {log('Initiating DummyImageContainer'); DummyImageContainer.prototype.image = new Image(); var image = this.image; DummyImageContainer.prototype.promise = new Promise(function (resolve, reject) {image.onload = resolve; image.onerror = reject; image.src = smallImage(); if (image.complete === true) {resolve(image);}});}}function Font(family, size) {var container = document.createElement('div'), img = document.createElement('img'), span = document.createElement('span'), sampleText = 'Hidden Text', baseline, middle; container.style.visibility = 'hidden'; container.style.fontFamily = family; container.style.fontSize = size; container.style.margin = 0; container.style.padding = 0; document.body.appendChild(container); img.src = smallImage(); img.width = 1; img.height = 1; img.style.margin = 0; img.style.padding = 0; img.style.verticalAlign = 'baseline'; span.style.fontFamily = family; span.style.fontSize = size; span.style.margin = 0; span.style.padding = 0; span.appendChild(document.createTextNode(sampleText)); container.appendChild(span); container.appendChild(img); baseline = img.offsetTop - span.offsetTop + 1; container.removeChild(span); container.appendChild(document.createTextNode(sampleText)); container.style.lineHeight = 'normal'; img.style.verticalAlign = 'super'; middle = img.offsetTop - container.offsetTop + 1; document.body.removeChild(container); this.baseline = baseline; this.lineWidth = 1; this.middle = middle;}function FontMetrics() {this.data = {};}FontMetrics.prototype.getMetrics = function (family, size) {if (this.data[family + '-' + size] === undefined) {this.data[family + '-' + size] = new Font(family, size);}return this.data[family + '-' + size];}; function FrameContainer(container, sameOrigin, options) {this.image = null; this.src = container; var self = this; var bounds = getBounds(container); this.promise = ( !sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function (resolve) {if (container.contentWindow.document.URL === 'about:blank' || container.contentWindow.document.documentElement == null) {container.contentWindow.onload = container.onload = function () {resolve(container);};}else {resolve(container);}}) ) .then(function (container) {return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2, });}) .then(function (canvas) {return (self.image = canvas);});}FrameContainer.prototype.proxyLoad = function (proxy, bounds, options) {var container = this.src; return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);}; function GradientContainer(imageData) {this.src = imageData.value; this.colorStops = []; this.type = null; this.x0 = 0.5; this.y0 = 0.5; this.x1 = 0.5; this.y1 = 0.5; this.promise = Promise.resolve(true);}GradientContainer.prototype.TYPES = {LINEAR: 1, RADIAL: 2, }; function ImageContainer(src, cors) {this.src = src; this.image = new Image(); var self = this; this.tainted = null; this.promise = new Promise(function (resolve, reject) {self.image.onload = resolve; self.image.onerror = reject; if (cors) {self.image.crossOrigin = 'anonymous';}self.image.src = src; if (self.image.complete === true) {resolve(self.image);}});}function ImageLoader(options, support) {this.link = null; this.options = options; this.support = support; this.origin = this.getOrigin(window.location.href);}ImageLoader.prototype.findImages = function (nodes) {var images = []; nodes .reduce(function (imageNodes, container) {switch (container.node.nodeName) {case 'IMG': return imageNodes.concat([ {args: [container.node.src], method: 'url', }, ]); case 'svg': case 'IFRAME': return imageNodes.concat([ {args: [container.node], method: container.node.nodeName, }, ]);}return imageNodes;}, []) .forEach(this.addImage(images, this.loadImage), this); return images;}; ImageLoader.prototype.findBackgroundImage = function (images, container) {container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this); return images;}; ImageLoader.prototype.addImage = function (images, callback) {return function (newImage) {newImage.args.forEach(function (image) {if (!this.imageExists(images, image)) {images.splice(0, 0, callback.call(this, newImage)); log('Added image #' + images.length, typeof image === 'string' ? image.substring(0, 100) : image);}}, this);};}; ImageLoader.prototype.hasImageBackground = function (imageData) {return imageData.method !== 'none';}; ImageLoader.prototype.loadImage = function (imageData) {if (imageData.method === 'url') {var src = imageData.args[0]; if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {return new SVGContainer(src);}else if (src.match(/data:image\/.*;base64,/i)) {return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ''), false);}else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {return new ImageContainer(src, false);}else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {return new ImageContainer(src, true);}else if (this.options.proxy) {return new ProxyImageContainer(src, this.options.proxy);}else {return new DummyImageContainer(src);}}else if (imageData.method === 'linear-gradient') {return new LinearGradientContainer(imageData);}else if (imageData.method === 'gradient') {return new WebkitGradientContainer(imageData);}else if (imageData.method === 'svg') {return new SVGNodeContainer(imageData.args[0], this.support.svg);}else if (imageData.method === 'IFRAME') {return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);}else {return new DummyImageContainer(imageData);}}; ImageLoader.prototype.isSVG = function (src) {return src.substring(src.length - 3).toLowerCase() === 'svg' || SVGContainer.prototype.isInline(src);}; ImageLoader.prototype.imageExists = function (images, src) {return images.some(function (image) {return image.src === src;});}; ImageLoader.prototype.isSameOrigin = function (url) {return this.getOrigin(url) === this.origin;}; ImageLoader.prototype.getOrigin = function (url) {var link = this.link || (this.link = document.createElement('a')); link.href = url; link.href = link.href; return link.protocol + link.hostname + link.port;}; ImageLoader.prototype.getPromise = function (container) {return this.timeout(container, this.options.imageTimeout)['catch'](function () {var dummy = new DummyImageContainer(container.src); return dummy.promise.then(function (image) {container.image = image;});});}; ImageLoader.prototype.get = function (src) {var found = null; return this.images.some(function (img) {return (found = img).src === src;}) ? found : null;}; ImageLoader.prototype.fetch = function (nodes) {this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes)); this.images.forEach(function (image, index) {image.promise.then( function () {log('Succesfully loaded image #' + (index + 1), image);}, function (e) {log('Failed loading image #' + (index + 1), image, e);}, );}); this.ready = Promise.all(this.images.map(this.getPromise, this)); log('Finished searching images'); return this;}; ImageLoader.prototype.timeout = function (container, timeout) {var timer; var promise = Promise.race([ container.promise, new Promise(function (res, reject) {timer = setTimeout(function () {log('Timed out loading image', container); reject(container);}, timeout);}), ]).then(function (container) {clearTimeout(timer); return container;}); promise['catch'](function () {clearTimeout(timer);}); return promise;}; function LinearGradientContainer(imageData) {GradientContainer.apply(this, arguments); this.type = this.TYPES.LINEAR; var hasDirection = imageData.args[0].match(this.stepRegExp) === null; if (hasDirection) {imageData.args[0] .split(' ') .reverse() .forEach(function (position) {switch (position) {case 'left': this.x0 = 0; this.x1 = 1; break; case 'top': this.y0 = 0; this.y1 = 1; break; case 'right': this.x0 = 1; this.x1 = 0; break; case 'bottom': this.y0 = 1; this.y1 = 0; break; case 'to': var y0 = this.y0; var x0 = this.x0; this.y0 = this.y1; this.x0 = this.x1; this.x1 = x0; this.y1 = y0; break;}}, this);}else {this.y0 = 0; this.y1 = 1;}this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function (colorStop) {var colorStopMatch = colorStop.match(this.stepRegExp); return {color: new Color(colorStopMatch[1]), stop: colorStopMatch[3] === '%' ? colorStopMatch[2] / 100 : null, };}, this); if (this.colorStops[0].stop === null) {this.colorStops[0].stop = 0;}if (this.colorStops[this.colorStops.length - 1].stop === null) {this.colorStops[this.colorStops.length - 1].stop = 1;}this.colorStops.forEach(function (colorStop, index) {if (colorStop.stop === null) {this.colorStops.slice(index).some(function (find, count) {if (find.stop !== null) {colorStop.stop = (find.stop - this.colorStops[index - 1].stop) / (count + 1) + this.colorStops[index - 1].stop; return true;}else {return false;}}, this);}}, this);}LinearGradientContainer.prototype = Object.create(GradientContainer.prototype); LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/; function log() {if (window.html2canvas.logging && window.console && window.console.log) {Function.prototype.bind .call(window.console.log, window.console) .apply(window.console, [Date.now() - window.html2canvas.start + 'ms', 'html2canvas:'].concat([].slice.call(arguments, 0)));}}function NodeContainer(node, parent) {this.node = node; this.parent = parent; this.stack = null; this.bounds = null; this.borders = null; this.clip = []; this.backgroundClip = []; this.offsetBounds = null; this.visible = null; this.computedStyles = null; this.colors = {}; this.styles = {}; this.backgroundImages = null; this.transformData = null; this.transformMatrix = null; this.isPseudoElement = false; this.opacity = null;}NodeContainer.prototype.cloneTo = function (stack) {stack.visible = this.visible; stack.borders = this.borders; stack.bounds = this.bounds; stack.clip = this.clip; stack.backgroundClip = this.backgroundClip; stack.computedStyles = this.computedStyles; stack.styles = this.styles; stack.backgroundImages = this.backgroundImages; stack.opacity = this.opacity;}; NodeContainer.prototype.getOpacity = function () {return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;}; NodeContainer.prototype.assignStack = function (stack) {this.stack = stack; stack.children.push(this);}; NodeContainer.prototype.isElementVisible = function () {return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css('display') !== 'none' && this.css('visibility') !== 'hidden' && !this.node.hasAttribute('data-html2canvas-ignore') && (this.node.nodeName !== 'INPUT' || this.node.getAttribute('type') !== 'hidden');}; NodeContainer.prototype.css = function (attribute) {if (!this.computedStyles) {this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ':before' : ':after') : this.computedStyle(null);}return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);}; NodeContainer.prototype.prefixedCss = function (attribute) {var prefixes = ['webkit', 'moz', 'ms', 'o']; var value = this.css(attribute); if (value === undefined) {prefixes.some(function (prefix) {value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1)); return value !== undefined;}, this);}return value === undefined ? null : value;}; NodeContainer.prototype.computedStyle = function (type) {return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);}; NodeContainer.prototype.cssInt = function (attribute) {var value = parseInt(this.css(attribute), 10); return isNaN(value) ? 0 : value;}; NodeContainer.prototype.color = function (attribute) {return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));}; NodeContainer.prototype.cssFloat = function (attribute) {var value = parseFloat(this.css(attribute)); return isNaN(value) ? 0 : value;}; NodeContainer.prototype.fontWeight = function () {var weight = this.css('fontWeight'); switch (parseInt(weight, 10)) {case 401: weight = 'bold'; break; case 400: weight = 'normal'; break;}return weight;}; NodeContainer.prototype.parseClip = function () {var matches = this.css('clip').match(this.CLIP); if (matches) {return {top: parseInt(matches[1], 10), right: parseInt(matches[2], 10), bottom: parseInt(matches[3], 10), left: parseInt(matches[4], 10), };}return null;}; NodeContainer.prototype.parseBackgroundImages = function () {return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css('backgroundImage')));}; NodeContainer.prototype.cssList = function (property, index) {var value = (this.css(property) || '').split(','); value = value[index || 0] || value[0] || 'auto'; value = value.trim().split(' '); if (value.length === 1) {value = [value[0], value[0]];}return value;}; NodeContainer.prototype.parseBackgroundSize = function (bounds, image, index) {var size = this.cssList('backgroundSize', index); var width, height; if (isPercentage(size[0])) {width = (bounds.width * parseFloat(size[0])) / 100;}else if (/contain|cover/.test(size[0])) {var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height; return (targetRatio < currentRatio) ^ (size[0] === 'contain') ? {width: bounds.height * currentRatio, height: bounds.height }: {width: bounds.width, height: bounds.width / currentRatio };}else {width = parseInt(size[0], 10);}if (size[0] === 'auto' && size[1] === 'auto') {height = image.height;}else if (size[1] === 'auto') {height = (width / image.width) * image.height;}else if (isPercentage(size[1])) {height = (bounds.height * parseFloat(size[1])) / 100;}else {height = parseInt(size[1], 10);}if (size[0] === 'auto') {width = (height / image.height) * image.width;}return {width: width, height: height };}; NodeContainer.prototype.parseBackgroundPosition = function (bounds, image, index, backgroundSize) {var position = this.cssList('backgroundPosition', index); var left, top; if (isPercentage(position[0])) {left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);}else {left = parseInt(position[0], 10);}if (position[1] === 'auto') {top = (left / image.width) * image.height;}else if (isPercentage(position[1])) {top = ((bounds.height - (backgroundSize || image).height) * parseFloat(position[1])) / 100;}else {top = parseInt(position[1], 10);}if (position[0] === 'auto') {left = (top / image.height) * image.width;}return {left: left, top: top };}; NodeContainer.prototype.parseBackgroundRepeat = function (index) {return this.cssList('backgroundRepeat', index)[0];}; NodeContainer.prototype.parseTextShadows = function () {var textShadow = this.css('textShadow'); var results = []; if (textShadow && textShadow !== 'none') {var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY); for (var i = 0; shadows && i < shadows.length; i++) {var s = shadows[i].match(this.TEXT_SHADOW_VALUES); results.push({color: new Color(s[0]), offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0, offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0, blur: s[3] ? s[3].replace('px', '') : 0, });}}return results;}; NodeContainer.prototype.parseTransform = function () {if (!this.transformData) {if (this.hasTransform()) {var offset = this.parseBounds(); var origin = this.prefixedCss('transformOrigin').split(' ').map(removePx).map(asFloat); origin[0] += offset.left; origin[1] += offset.top; this.transformData = {origin: origin, matrix: this.parseTransformMatrix(), };}else {this.transformData = {origin: [0, 0], matrix: [1, 0, 0, 1, 0, 0], };}}return this.transformData;}; NodeContainer.prototype.parseTransformMatrix = function () {if (!this.transformMatrix) {var transform = this.prefixedCss('transform'); var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null; this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];}return this.transformMatrix;}; NodeContainer.prototype.parseBounds = function () {return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));}; NodeContainer.prototype.hasTransform = function () {return this.parseTransformMatrix().join(',') !== '1,0,0,1,0,0' || (this.parent && this.parent.hasTransform());}; NodeContainer.prototype.getValue = function () {var value = this.node.value || ''; if (this.node.tagName === 'SELECT') {value = selectionValue(this.node);}else if (this.node.type === 'password') {value = Array(value.length + 1).join('\u2022');}return value.length === 0 ? this.node.placeholder || '' : value;}; NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/; NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g; NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g; NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/; function selectionValue(node) {var option = node.options[node.selectedIndex || 0]; return option ? option.text || '' : '';}function parseMatrix(match) {if (match && match[1] === 'matrix') {return match[2].split(',').map(function (s) {return parseFloat(s.trim());});}}function isPercentage(value) {return value.toString().indexOf('%') !== -1;}function parseBackgrounds(backgroundImage) {var whitespace = ' \r\n\t', method, definition, prefix, prefix_i, block, results = [], mode = 0, numParen = 0, quote, args; var appendResult = function () {if (method) {if (definition.substr(0, 1) === '"') {definition = definition.substr(1, definition.length - 2);}if (definition) {args.push(definition);}if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {prefix = method.substr(0, prefix_i); method = method.substr(prefix_i);}results.push({prefix: prefix, method: method.toLowerCase(), value: block, args: args, image: null, });}args = []; method = prefix = definition = block = '';}; args = []; method = prefix = definition = block = ''; backgroundImage.split('').forEach(function (c) {if (mode === 0 && whitespace.indexOf(c) > -1) {return;}switch (c) {case '"': if (!quote) {quote = c;}else if (quote === c) {quote = null;}break; case '(': if (quote) {break;}else if (mode === 0) {mode = 1; block += c; return;}else {numParen++;}break; case ')': if (quote) {break;}else if (mode === 1) {if (numParen === 0) {mode = 0; block += c; appendResult(); return;}else {numParen--;}}break; case ',': if (quote) {break;}else if (mode === 0) {appendResult(); return;}else if (mode === 1) {if (numParen === 0 && !method.match(/^url$/i)) {args.push(definition); definition = ''; block += c; return;}}break;}block += c; if (mode === 0) {method += c;}else {definition += c;}}); appendResult(); return results;}function removePx(str) {return str.replace('px', '');}function asFloat(str) {return parseFloat(str);}function getBounds(node) {if (node.getBoundingClientRect) {var clientRect = node.getBoundingClientRect(); var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth; return {top: clientRect.top, bottom: clientRect.bottom || clientRect.top + clientRect.height, right: clientRect.left + width, left: clientRect.left, width: width, height: node.offsetHeight == null ? clientRect.height : node.offsetHeight, };}return {};}function offsetBounds(node) {var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {top: 0, left: 0 }; return {top: node.offsetTop + parent.top, bottom: node.offsetTop + node.offsetHeight + parent.top, right: node.offsetLeft + parent.left + node.offsetWidth, left: node.offsetLeft + parent.left, width: node.offsetWidth, height: node.offsetHeight, };}function NodeParser(element, renderer, support, imageLoader, options) {log('Starting NodeParser'); this.renderer = renderer; this.options = options; this.range = null; this.support = support; this.renderQueue = []; this.stack = new StackingContext(true, 1, element.ownerDocument, null); var parent = new NodeContainer(element, null); if (options.background) {renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));}if (element === element.ownerDocument.documentElement) {var canvasBackground = new NodeContainer( parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null, ); renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));}parent.visibile = parent.isElementVisible(); this.createPseudoHideStyles(element.ownerDocument); this.disableAnimations(element.ownerDocument); this.nodes = flatten( [parent] .concat(this.getChildren(parent)) .filter(function (container) {return (container.visible = container.isElementVisible());}) .map(this.getPseudoElements, this), ); this.fontMetrics = new FontMetrics(); log('Fetched nodes, total:', this.nodes.length); log('Calculate overflow clips'); this.calculateOverflowClips(); log('Start fetching images'); this.images = imageLoader.fetch(this.nodes.filter(isElement)); this.ready = this.images.ready.then( bind(function () {log('Images loaded, starting parsing'); log('Creating stacking contexts'); this.createStackingContexts(); log('Sorting stacking contexts'); this.sortStackingContexts(this.stack); this.parse(this.stack); log('Render queue created with ' + this.renderQueue.length + ' items'); return new Promise( bind(function (resolve) {if (!options.async) {this.renderQueue.forEach(this.paint, this); resolve();}else if (typeof options.async === 'function') {options.async.call(this, this.renderQueue, resolve);}else if (this.renderQueue.length > 0) {this.renderIndex = 0; this.asyncRenderer(this.renderQueue, resolve);}else {resolve();}}, this), );}, this), );}NodeParser.prototype.calculateOverflowClips = function () {this.nodes.forEach(function (container) {if (isElement(container)) {if (isPseudoElement(container)) {container.appendToDOM();}container.borders = this.parseBorders(container); var clip = container.css('overflow') === 'hidden' ? [container.borders.clip] : []; var cssClip = container.parseClip(); if (cssClip && ['absolute', 'fixed'].indexOf(container.css('position')) !== -1) {clip.push([ ['rect', container.bounds.left + cssClip.left, container.bounds.top + cssClip.top, cssClip.right - cssClip.left, cssClip.bottom - cssClip.top], ]);}container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip; container.backgroundClip = container.css('overflow') !== 'hidden' ? container.clip.concat([container.borders.clip]) : container.clip; if (isPseudoElement(container)) {container.cleanDOM();}}else if (isTextNode(container)) {container.clip = hasParentClip(container) ? container.parent.clip : [];}if (!isPseudoElement(container)) {container.bounds = null;}}, this);}; function hasParentClip(container) {return container.parent && container.parent.clip.length;}NodeParser.prototype.asyncRenderer = function (queue, resolve, asyncTimer) {asyncTimer = asyncTimer || Date.now(); this.paint(queue[this.renderIndex++]); if (queue.length === this.renderIndex) {resolve();}else if (asyncTimer + 20 > Date.now()) {this.asyncRenderer(queue, resolve, asyncTimer);}else {setTimeout( bind(function () {this.asyncRenderer(queue, resolve);}, this), 0, );}}; NodeParser.prototype.createPseudoHideStyles = function (document) {this.createStyles( document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before {content: "" !important; display: none !important;}' + '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after {content: "" !important; display: none !important;}', );}; NodeParser.prototype.disableAnimations = function (document) {this.createStyles( document, '* {-webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' + '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}', );}; NodeParser.prototype.createStyles = function (document, styles) {var hidePseudoElements = document.createElement('style'); hidePseudoElements.innerHTML = styles; document.body.appendChild(hidePseudoElements);}; NodeParser.prototype.getPseudoElements = function (container) {var nodes = [[container]]; if (container.node.nodeType === Node.ELEMENT_NODE) {var before = this.getPseudoElement(container, ':before'); var after = this.getPseudoElement(container, ':after'); if (before) {nodes.push(before);}if (after) {nodes.push(after);}}return flatten(nodes);}; function toCamelCase(str) {return str.replace(/(\-[a-z])/g, function (match) {return match.toUpperCase().replace('-', '');});}NodeParser.prototype.getPseudoElement = function (container, type) {var style = container.computedStyle(type); if (!style || !style.content || style.content === 'none' || style.content === '-moz-alt-content' || style.display === 'none') {return null;}var content = stripQuotes(style.content); var isImage = content.substr(0, 3) === 'url'; var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement'); var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type); for (var i = style.length - 1; i >= 0; i--) {var property = toCamelCase(style.item(i)); pseudoNode.style[property] = style[property];}pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER; if (isImage) {pseudoNode.src = parseBackgrounds(content)[0].args[0]; return [pseudoContainer];}else {var text = document.createTextNode(content); pseudoNode.appendChild(text); return [pseudoContainer, new TextContainer(text, pseudoContainer)];}}; NodeParser.prototype.getChildren = function (parentContainer) {return flatten( [].filter.call(parentContainer.node.childNodes, renderableNode).map(function (node) {var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter( nonIgnoredElement, ); return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== 'TEXTAREA' ? container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : [] : container;}, this), );}; NodeParser.prototype.newStackingContext = function (container, hasOwnStacking) {var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent); container.cloneTo(stack); var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack; parentStack.contexts.push(stack); container.stack = stack;}; NodeParser.prototype.createStackingContexts = function () {this.nodes.forEach(function (container) {if ( isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform()) ) {this.newStackingContext(container, true);}else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {this.newStackingContext(container, false);}else {container.assignStack(container.parent.stack);}}, this);}; NodeParser.prototype.isBodyWithTransparentRoot = function (container) {return container.node.nodeName === 'BODY' && container.parent.color('backgroundColor').isTransparent();}; NodeParser.prototype.isRootElement = function (container) {return container.parent === null;}; NodeParser.prototype.sortStackingContexts = function (stack) {stack.contexts.sort(zIndexSort(stack.contexts.slice(0))); stack.contexts.forEach(this.sortStackingContexts, this);}; NodeParser.prototype.parseTextBounds = function (container) {return function (text, index, textList) {if (container.parent.css('textDecoration').substr(0, 4) !== 'none' || text.trim().length !== 0) {if (this.support.rangeBounds && !container.parent.hasTransform()) {var offset = textList.slice(0, index).join('').length; return this.getRangeBounds(container.node, offset, text.length);}else if (container.node && typeof container.node.data === 'string') {var replacementNode = container.node.splitText(text.length); var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform()); container.node = replacementNode; return bounds;}}else if (!this.support.rangeBounds || container.parent.hasTransform()) {container.node = container.node.splitText(text.length);}return {};};}; NodeParser.prototype.getWrapperBounds = function (node, transform) {var wrapper = node.ownerDocument.createElement('html2canvaswrapper'); var parent = node.parentNode, backupText = node.cloneNode(true); wrapper.appendChild(node.cloneNode(true)); parent.replaceChild(wrapper, node); var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper); parent.replaceChild(backupText, wrapper); return bounds;}; NodeParser.prototype.getRangeBounds = function (node, offset, length) {var range = this.range || (this.range = node.ownerDocument.createRange()); range.setStart(node, offset); range.setEnd(node, offset + length); return range.getBoundingClientRect();}; function ClearTransform() {}NodeParser.prototype.parse = function (stack) {var negativeZindex = stack.contexts.filter(negativeZIndex); var descendantElements = stack.children.filter(isElement); var descendantNonFloats = descendantElements.filter(not(isFloating)); var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); var text = stack.children.filter(isTextNode).filter(hasText); var positiveZindex = stack.contexts.filter(positiveZIndex); negativeZindex .concat(nonInlineNonPositionedDescendants) .concat(nonPositionedFloats) .concat(inFlow) .concat(stackLevel0) .concat(text) .concat(positiveZindex) .forEach(function (container) {this.renderQueue.push(container); if (isStackingContext(container)) {this.parse(container); this.renderQueue.push(new ClearTransform());}}, this);}; NodeParser.prototype.paint = function (container) {try {if (container instanceof ClearTransform) {this.renderer.ctx.restore();}else if (isTextNode(container)) {if (isPseudoElement(container.parent)) {container.parent.appendToDOM();}this.paintText(container); if (isPseudoElement(container.parent)) {container.parent.cleanDOM();}}else {this.paintNode(container);}}catch (e) {log(e); if (this.options.strict) {throw e;}}}; NodeParser.prototype.paintNode = function (container) {if (isStackingContext(container)) {this.renderer.setOpacity(container.opacity); this.renderer.ctx.save(); if (container.hasTransform()) {this.renderer.setTransform(container.parseTransform());}}if (container.node.nodeName === 'INPUT' && container.node.type === 'checkbox') {this.paintCheckbox(container);}else if (container.node.nodeName === 'INPUT' && container.node.type === 'radio') {this.paintRadio(container);}else {this.paintElement(container);}}; NodeParser.prototype.paintElement = function (container) {var bounds = container.parseBounds(); this.renderer.clip( container.backgroundClip, function () {this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));}, this, ); this.renderer.clip( container.clip, function () {this.renderer.renderBorders(container.borders.borders);}, this, ); this.renderer.clip( container.backgroundClip, function () {switch (container.node.nodeName) {case 'svg': case 'IFRAME': var imgContainer = this.images.get(container.node); if (imgContainer) {this.renderer.renderImage(container, bounds, container.borders, imgContainer);}else {log('Error loading <' + container.node.nodeName + '>', container.node);}break; case 'IMG': var imageContainer = this.images.get(container.node.src); if (imageContainer) {this.renderer.renderImage(container, bounds, container.borders, imageContainer);}else {log('Error loading <img>', container.node.src);}break; case 'CANVAS': this.renderer.renderImage(container, bounds, container.borders, {image: container.node }); break; case 'SELECT': case 'INPUT': case 'TEXTAREA': this.paintFormValue(container); break;}}, this, );}; NodeParser.prototype.paintCheckbox = function (container) {var b = container.parseBounds(); var size = Math.min(b.width, b.height); var bounds = {width: size - 1, height: size - 1, top: b.top, left: b.left }; var r = [3, 3]; var radius = [r, r, r, r]; var borders = [1, 1, 1, 1].map(function (w) {return {color: new Color('#A5A5A5'), width: w };}); var borderPoints = calculateCurvePoints(bounds, radius, borders); this.renderer.clip( container.backgroundClip, function () {this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color('#DEDEDE')); this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius)); if (container.node.checked) {this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', size - 3 + 'px', 'arial'); this.renderer.text('\u2714', bounds.left + size / 6, bounds.top + size - 1);}}, this, );}; NodeParser.prototype.paintRadio = function (container) {var bounds = container.parseBounds(); var size = Math.min(bounds.width, bounds.height) - 2; this.renderer.clip( container.backgroundClip, function () {this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5')); if (container.node.checked) {this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));}}, this, );}; NodeParser.prototype.paintFormValue = function (container) {var value = container.getValue(); if (value.length > 0) {var document = container.node.ownerDocument; var wrapper = document.createElement('html2canvaswrapper'); var properties = [ 'lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth', 'boxSizing', 'whiteSpace', 'wordWrap', ]; properties.forEach(function (property) {try {wrapper.style[property] = container.css(property);}catch (e) {log('html2canvas: Parse: Exception caught in renderFormValue: ' + e.message);}}); var bounds = container.parseBounds(); wrapper.style.position = 'fixed'; wrapper.style.left = bounds.left + 'px'; wrapper.style.top = bounds.top + 'px'; wrapper.textContent = value; document.body.appendChild(wrapper); this.paintText(new TextContainer(wrapper.firstChild, container)); document.body.removeChild(wrapper);}}; NodeParser.prototype.paintText = function (container) {container.applyTextTransform(); var characters = window.html2canvas.punycode.ucs2.decode(container.node.data); var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function (character) {return window.html2canvas.punycode.ucs2.encode([character]);}); var weight = container.parent.fontWeight(); var size = container.parent.css('fontSize'); var family = container.parent.css('fontFamily'); var shadows = container.parent.parseTextShadows(); this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family); if (shadows.length) {this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);}else {this.renderer.clearShadow();}this.renderer.clip( container.parent.clip, function () {textList.map(this.parseTextBounds(container), this).forEach(function (bounds, index) {if (bounds) {this.renderer.text(textList[index], bounds.left, bounds.bottom); this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));}}, this);}, this, );}; NodeParser.prototype.renderTextDecoration = function (container, bounds, metrics) {switch (container.css('textDecoration').split(' ')[0]) {case 'underline': this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color('color')); break; case 'overline': this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color('color')); break; case 'line-through': this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color('color')); break;}}; var borderColorTransforms = {inset: [ ['darken', 0.6], ['darken', 0.1], ['darken', 0.1], ['darken', 0.6], ], }; NodeParser.prototype.parseBorders = function (container) {var nodeBounds = container.parseBounds(); var radius = getBorderRadiusData(container); var borders = ['Top', 'Right', 'Bottom', 'Left'].map(function (side, index) {var style = container.css('border' + side + 'Style'); var color = container.color('border' + side + 'Color'); if (style === 'inset' && color.isBlack()) {color = new Color([255, 255, 255, color.a]);}var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null; return {width: container.cssInt('border' + side + 'Width'), color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color, args: null, };}); var borderPoints = calculateCurvePoints(nodeBounds, radius, borders); return {clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds), borders: calculateBorders(borders, nodeBounds, borderPoints, radius), };}; function calculateBorders(borders, nodeBounds, borderPoints, radius) {return borders.map(function (border, borderSide) {if (border.width > 0) {var bx = nodeBounds.left; var by = nodeBounds.top; var bw = nodeBounds.width; var bh = nodeBounds.height - borders[2].width; switch (borderSide) {case 0: bh = borders[0].width; border.args = drawSide( {c1: [bx, by], c2: [bx + bw, by], c3: [bx + bw - borders[1].width, by + bh], c4: [bx + borders[3].width, by + bh], }, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner, ); break; case 1: bx = nodeBounds.left + nodeBounds.width - borders[1].width; bw = borders[1].width; border.args = drawSide( {c1: [bx + bw, by], c2: [bx + bw, by + bh + borders[2].width], c3: [bx, by + bh], c4: [bx, by + borders[0].width], }, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner, ); break; case 2: by = by + nodeBounds.height - borders[2].width; bh = borders[2].width; border.args = drawSide( {c1: [bx + bw, by + bh], c2: [bx, by + bh], c3: [bx + borders[3].width, by], c4: [bx + bw - borders[3].width, by], }, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, ); break; case 3: bw = borders[3].width; border.args = drawSide( {c1: [bx, by + bh + borders[2].width], c2: [bx, by], c3: [bx + bw, by + borders[0].width], c4: [bx + bw, by + bh], }, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner, ); break;}}return border;});}NodeParser.prototype.parseBackgroundClip = function (container, borderPoints, borders, radius, bounds) {var backgroundClip = container.css('backgroundClip'), borderArgs = []; switch (backgroundClip) {case 'content-box': case 'padding-box': parseCorner( borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width, ); parseCorner( borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width, ); parseCorner( borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width, ); parseCorner( borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width, ); break; default: parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top); parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top); parseCorner( borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height, ); parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height); break;}return borderArgs;}; function getCurvePoints(x, y, r1, r2) {var kappa = 4 * ((Math.sqrt(2) - 1) / 3); var ox = r1 * kappa, oy = r2 * kappa, xm = x + r1, ym = y + r2; return {topLeft: bezierCurve({x: x, y: ym }, {x: x, y: ym - oy }, {x: xm - ox, y: y }, {x: xm, y: y }), topRight: bezierCurve({x: x, y: y }, {x: x + ox, y: y }, {x: xm, y: ym - oy }, {x: xm, y: ym }), bottomRight: bezierCurve({x: xm, y: y }, {x: xm, y: y + oy }, {x: x + ox, y: ym }, {x: x, y: ym }), bottomLeft: bezierCurve({x: xm, y: ym }, {x: xm - ox, y: ym }, {x: x, y: y + oy }, {x: x, y: y }), };}function calculateCurvePoints(bounds, borderRadius, borders) {var x = bounds.left, y = bounds.top, width = bounds.width, height = bounds.height, tlh = borderRadius[0][0], tlv = borderRadius[0][1], trh = borderRadius[1][0], trv = borderRadius[1][1], brh = borderRadius[2][0], brv = borderRadius[2][1], blh = borderRadius[3][0], blv = borderRadius[3][1]; var topWidth = width - trh, rightHeight = height - brv, bottomWidth = width - brh, leftHeight = height - blv; return {topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5), topLeftInner: getCurvePoints( x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width), ).topLeft.subdivide(0.5), topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5), topRightInner: getCurvePoints( x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, topWidth > width + borders[3].width ? 0 : trh - borders[3].width, trv - borders[0].width, ).topRight.subdivide(0.5), bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5), bottomRightInner: getCurvePoints( x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), brv - borders[2].width, ).bottomRight.subdivide(0.5), bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5), bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide( 0.5, ), };}function bezierCurve(start, startControl, endControl, end) {var lerp = function (a, b, t) {return {x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t, };}; return {start: start, startControl: startControl, endControl: endControl, end: end, subdivide: function (t) {var ab = lerp(start, startControl, t), bc = lerp(startControl, endControl, t), cd = lerp(endControl, end, t), abbc = lerp(ab, bc, t), bccd = lerp(bc, cd, t), dest = lerp(abbc, bccd, t); return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];}, curveTo: function (borderArgs) {borderArgs.push(['bezierCurve', startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);}, curveToReversed: function (borderArgs) {borderArgs.push(['bezierCurve', endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);}, };}function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {var borderArgs = []; if (radius1[0] > 0 || radius1[1] > 0) {borderArgs.push(['line', outer1[1].start.x, outer1[1].start.y]); outer1[1].curveTo(borderArgs);}else {borderArgs.push(['line', borderData.c1[0], borderData.c1[1]]);}if (radius2[0] > 0 || radius2[1] > 0) {borderArgs.push(['line', outer2[0].start.x, outer2[0].start.y]); outer2[0].curveTo(borderArgs); borderArgs.push(['line', inner2[0].end.x, inner2[0].end.y]); inner2[0].curveToReversed(borderArgs);}else {borderArgs.push(['line', borderData.c2[0], borderData.c2[1]]); borderArgs.push(['line', borderData.c3[0], borderData.c3[1]]);}if (radius1[0] > 0 || radius1[1] > 0) {borderArgs.push(['line', inner1[1].end.x, inner1[1].end.y]); inner1[1].curveToReversed(borderArgs);}else {borderArgs.push(['line', borderData.c4[0], borderData.c4[1]]);}return borderArgs;}function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {if (radius1[0] > 0 || radius1[1] > 0) {borderArgs.push(['line', corner1[0].start.x, corner1[0].start.y]); corner1[0].curveTo(borderArgs); corner1[1].curveTo(borderArgs);}else {borderArgs.push(['line', x, y]);}if (radius2[0] > 0 || radius2[1] > 0) {borderArgs.push(['line', corner2[0].start.x, corner2[0].start.y]);}}function negativeZIndex(container) {return container.cssInt('zIndex') < 0;}function positiveZIndex(container) {return container.cssInt('zIndex') > 0;}function zIndex0(container) {return container.cssInt('zIndex') === 0;}function inlineLevel(container) {return ['inline', 'inline-block', 'inline-table'].indexOf(container.css('display')) !== -1;}function isStackingContext(container) {return container instanceof StackingContext;}function hasText(container) {return container.node.data.trim().length > 0;}function noLetterSpacing(container) {return /^(normal|none|0px)$/.test(container.parent.css('letterSpacing'));}function getBorderRadiusData(container) {return ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].map(function (side) {var value = container.css('border' + side + 'Radius'); var arr = value.split(' '); if (arr.length <= 1) {arr[1] = arr[0];}return arr.map(asInt);});}function renderableNode(node) {return node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE;}function isPositionedForStacking(container) {var position = container.css('position'); var zIndex = ['absolute', 'relative', 'fixed'].indexOf(position) !== -1 ? container.css('zIndex') : 'auto'; return zIndex !== 'auto';}function isPositioned(container) {return container.css('position') !== 'static';}function isFloating(container) {return container.css('float') !== 'none';}function isInlineBlock(container) {return ['inline-block', 'inline-table'].indexOf(container.css('display')) !== -1;}function not(callback) {var context = this; return function () {return !callback.apply(context, arguments);};}function isElement(container) {return container.node.nodeType === Node.ELEMENT_NODE;}function isPseudoElement(container) {return container.isPseudoElement === true;}function isTextNode(container) {return container.node.nodeType === Node.TEXT_NODE;}function zIndexSort(contexts) {return function (a, b) {return a.cssInt('zIndex') + contexts.indexOf(a) / contexts.length - (b.cssInt('zIndex') + contexts.indexOf(b) / contexts.length);};}function hasOpacity(container) {return container.getOpacity() < 1;}function bind(callback, context) {return function () {return callback.apply(context, arguments);};}function asInt(value) {return parseInt(value, 10);}function getWidth(border) {return border.width;}function nonIgnoredElement(nodeContainer) {return ( nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ['SCRIPT', 'HEAD', 'TITLE', 'OBJECT', 'BR', 'OPTION'].indexOf(nodeContainer.node.nodeName) === -1 );}function flatten(arrays) {return [].concat.apply([], arrays);}function stripQuotes(content) {var first = content.substr(0, 1); return first === content.substr(content.length - 1) && first.match(/'|"/) ? content.substr(1, content.length - 2) : content;}function getWords(characters) {var words = [], i = 0, onWordBoundary = false, word; while (characters.length) {if (isWordBoundary(characters[i]) === onWordBoundary) {word = characters.splice(0, i); if (word.length) {words.push(window.html2canvas.punycode.ucs2.encode(word));}onWordBoundary = !onWordBoundary; i = 0;}else {i++;}if (i >= characters.length) {word = characters.splice(0, i); if (word.length) {words.push(window.html2canvas.punycode.ucs2.encode(word));}}}return words;}function isWordBoundary(characterCode) {return ( [ 32, 13, 10, 9, 45, ].indexOf(characterCode) !== -1 );}function hasUnicode(string) {return /[^\u0000-\u00ff]/.test(string);}function Proxy(src, proxyUrl, document) {if (!proxyUrl) {return Promise.reject('No proxy configured');}var callback = createCallback(supportsCORS); var url = createProxyUrl(proxyUrl, src, callback); return supportsCORS ? XHR(url) : jsonp(document, url, callback).then(function (response) {return decode64(response.content);});}var proxyCount = 0; var supportsCORS = 'withCredentials' in new XMLHttpRequest(); var supportsCORSImage = 'crossOrigin' in new Image(); function ProxyURL(src, proxyUrl, document) {var callback = createCallback(supportsCORSImage); var url = createProxyUrl(proxyUrl, src, callback); return supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function (response) {return 'data:' + response.type + ';base64,' + response.content;});}function jsonp(document, url, callback) {return new Promise(function (resolve, reject) {var s = document.createElement('script'); var cleanup = function () {delete window.html2canvas.proxy[callback]; document.body.removeChild(s);}; window.html2canvas.proxy[callback] = function (response) {cleanup(); resolve(response);}; s.src = url; s.onerror = function (e) {cleanup(); reject(e);}; document.body.appendChild(s);});}function createCallback(useCORS) {return !useCORS ? 'html2canvas_' + Date.now() + '_' + ++proxyCount + '_' + Math.round(Math.random() * 100000) : '';}function createProxyUrl(proxyUrl, src, callback) {return proxyUrl + '?url=' + encodeURIComponent(src) + (callback.length ? '&callback=html2canvas.proxy.' + callback : '');}function ProxyImageContainer(src, proxy) {var script = document.createElement('script'); var link = document.createElement('a'); link.href = src; src = link.href; this.src = src; this.image = new Image(); var self = this; this.promise = new Promise(function (resolve, reject) {self.image.crossOrigin = 'Anonymous'; self.image.onload = resolve; self.image.onerror = reject; new ProxyURL(src, proxy, document) .then(function (url) {self.image.src = url;}) ['catch'](reject);});}function PseudoElementContainer(node, parent, type) {NodeContainer.call(this, node, parent); this.isPseudoElement = true; this.before = type === ':before';}PseudoElementContainer.prototype.cloneTo = function (stack) {PseudoElementContainer.prototype.cloneTo.call(this, stack); stack.isPseudoElement = true; stack.before = this.before;}; PseudoElementContainer.prototype = Object.create(NodeContainer.prototype); PseudoElementContainer.prototype.appendToDOM = function () {if (this.before) {this.parent.node.insertBefore(this.node, this.parent.node.firstChild);}else {this.parent.node.appendChild(this.node);}this.parent.node.className += ' ' + this.getHideClass();}; PseudoElementContainer.prototype.cleanDOM = function () {this.node.parentNode.removeChild(this.node); this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), '');}; PseudoElementContainer.prototype.getHideClass = function () {return this['PSEUDO_HIDE_ELEMENT_CLASS_' + (this.before ? 'BEFORE' : 'AFTER')];}; PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before'; PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after'; function Renderer(width, height, images, options, document) {this.width = width; this.height = height; this.images = images; this.options = options; this.document = document;}Renderer.prototype.renderImage = function (container, bounds, borderData, imageContainer) {var paddingLeft = container.cssInt('paddingLeft'), paddingTop = container.cssInt('paddingTop'), paddingRight = container.cssInt('paddingRight'), paddingBottom = container.cssInt('paddingBottom'), borders = borderData.borders; var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight); var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom); this.drawImage( imageContainer, 0, 0, imageContainer.image.width || width, imageContainer.image.height || height, bounds.left + paddingLeft + borders[3].width, bounds.top + paddingTop + borders[0].width, width, height, );}; Renderer.prototype.renderBackground = function (container, bounds, borderData) {if (bounds.height > 0 && bounds.width > 0) {this.renderBackgroundColor(container, bounds); this.renderBackgroundImage(container, bounds, borderData);}}; Renderer.prototype.renderBackgroundColor = function (container, bounds) {var color = container.color('backgroundColor'); if (!color.isTransparent()) {this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);}}; Renderer.prototype.renderBorders = function (borders) {borders.forEach(this.renderBorder, this);}; Renderer.prototype.renderBorder = function (data) {if (!data.color.isTransparent() && data.args !== null) {this.drawShape(data.args, data.color);}}; Renderer.prototype.renderBackgroundImage = function (container, bounds, borderData) {var backgroundImages = container.parseBackgroundImages(); backgroundImages.reverse().forEach(function (backgroundImage, index, arr) {switch (backgroundImage.method) {case 'url': var image = this.images.get(backgroundImage.args[0]); if (image) {this.renderBackgroundRepeating(container, bounds, image, arr.length - (index + 1), borderData);}else {log('Error loading background-image', backgroundImage.args[0]);}break; case 'linear-gradient': case 'gradient': var gradientImage = this.images.get(backgroundImage.value); if (gradientImage) {this.renderBackgroundGradient(gradientImage, bounds, borderData);}else {log('Error loading background-image', backgroundImage.args[0]);}break; case 'none': break; default: log('Unknown background-image type', backgroundImage.args[0]);}}, this);}; Renderer.prototype.renderBackgroundRepeating = function (container, bounds, imageContainer, index, borderData) {var size = container.parseBackgroundSize(bounds, imageContainer.image, index); var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size); var repeat = container.parseBackgroundRepeat(index); switch (repeat) {case 'repeat-x': case 'repeat no-repeat': this.backgroundRepeatShape( imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData, ); break; case 'repeat-y': case 'no-repeat repeat': this.backgroundRepeatShape( imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData, ); break; case 'no-repeat': this.backgroundRepeatShape( imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData, ); break; default: this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left }, borderData[3], borderData[0]); break;}}; function StackingContext(hasOwnStacking, opacity, element, parent) {NodeContainer.call(this, element, parent); this.ownStacking = hasOwnStacking; this.contexts = []; this.children = []; this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;}StackingContext.prototype = Object.create(NodeContainer.prototype); StackingContext.prototype.getParentStack = function (context) {var parentStack = this.parent ? this.parent.stack : null; return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;}; function Support(document) {this.rangeBounds = this.testRangeBounds(document); this.cors = this.testCORS(); this.svg = this.testSVG();}Support.prototype.testRangeBounds = function (document) {var range, testElement, rangeBounds, rangeHeight, support = false; if (document.createRange) {range = document.createRange(); if (range.getBoundingClientRect) {testElement = document.createElement('boundtest'); testElement.style.height = '123px'; testElement.style.display = 'block'; document.body.appendChild(testElement); range.selectNode(testElement); rangeBounds = range.getBoundingClientRect(); rangeHeight = rangeBounds.height; if (rangeHeight === 123) {support = true;}document.body.removeChild(testElement);}}return support;}; Support.prototype.testCORS = function () {return typeof new Image().crossOrigin !== 'undefined';}; Support.prototype.testSVG = function () {var img = new Image(); var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); img.src = "data:image/svg+xml,<svg xmlns='http: try {ctx.drawImage(img, 0, 0); canvas.toDataURL();}catch (e) {return false;}return true;}; function SVGContainer(src) {this.src = src; this.image = null; var self = this; this.promise = this.hasFabric() .then(function () {return self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src);}) .then(function (svg) {return new Promise(function (resolve) {html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));});});}SVGContainer.prototype.hasFabric = function () {return !html2canvas.fabric ? Promise.reject(new Error('html2canvas.svg.js is not loaded, cannot render svg')) : Promise.resolve();}; SVGContainer.prototype.inlineFormatting = function (src) {return /^data:image\/svg\+xml;base64,/.test(src) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);}; SVGContainer.prototype.removeContentType = function (src) {return src.replace(/^data:image\/svg\+xml(;base64)?,/, '');}; SVGContainer.prototype.isInline = function (src) {return /^data:image\/svg\+xml/i.test(src);}; SVGContainer.prototype.createCanvas = function (resolve) {var self = this; return function (objects, options) {var canvas = new html2canvas.fabric.StaticCanvas('c'); self.image = canvas.lowerCanvasEl; canvas.setWidth(options.width).setHeight(options.height).add(html2canvas.fabric.util.groupSVGElements(objects, options)).renderAll(); resolve(canvas.lowerCanvasEl);};}; SVGContainer.prototype.decode64 = function (str) {return typeof window.atob === 'function' ? window.atob(str) : decode64(str);}; function decode64(base64) {var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3; var output = ''; for (i = 0; i < len; i += 4) {encoded1 = chars.indexOf(base64[i]); encoded2 = chars.indexOf(base64[i + 1]); encoded3 = chars.indexOf(base64[i + 2]); encoded4 = chars.indexOf(base64[i + 3]); byte1 = (encoded1 << 2) | (encoded2 >> 4); byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2); byte3 = ((encoded3 & 3) << 6) | encoded4; if (encoded3 === 64) {output += String.fromCharCode(byte1);}else if (encoded4 === 64 || encoded4 === -1) {output += String.fromCharCode(byte1, byte2);}else {output += String.fromCharCode(byte1, byte2, byte3);}}return output;}function SVGNodeContainer(node, native) {this.src = node; this.image = null; var self = this; this.promise = native ? new Promise(function (resolve, reject) {self.image = new Image(); self.image.onload = resolve; self.image.onerror = reject; self.image.src = 'data:image/svg+xml,' + new XMLSerializer().serializeToString(node); if (self.image.complete === true) {resolve(self.image);}}) : this.hasFabric().then(function () {return new Promise(function (resolve) {html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));});});}SVGNodeContainer.prototype = Object.create(SVGContainer.prototype); function TextContainer(node, parent) {NodeContainer.call(this, node, parent);}TextContainer.prototype = Object.create(NodeContainer.prototype); TextContainer.prototype.applyTextTransform = function () {this.node.data = this.transform(this.parent.css('textTransform'));}; TextContainer.prototype.transform = function (transform) {var text = this.node.data; switch (transform) {case 'lowercase': return text.toLowerCase(); case 'capitalize': return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize); case 'uppercase': return text.toUpperCase(); default: return text;}}; function capitalize(m, p1, p2) {if (m.length > 0) {return p1 + p2.toUpperCase();}}function WebkitGradientContainer(imageData) {GradientContainer.apply(this, arguments); this.type = imageData.args[0] === 'linear' ? this.TYPES.LINEAR : this.TYPES.RADIAL;}WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype); function XHR(url) {return new Promise(function (resolve, reject) {var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload = function () {if (xhr.status === 200) {resolve(xhr.responseText);}else {reject(new Error(xhr.statusText));}}; xhr.onerror = function () {reject(new Error('Network Error'));}; xhr.send();});}function CanvasRenderer(width, height) {Renderer.apply(this, arguments); this.canvas = this.options.canvas || this.document.createElement('canvas'); if (!this.options.canvas) {this.canvas.width = width; this.canvas.height = height;}this.ctx = this.canvas.getContext('2d'); this.taintCtx = this.document.createElement('canvas').getContext('2d'); this.ctx.textBaseline = 'bottom'; this.variables = {}; log('Initialized CanvasRenderer with size', width, 'x', height);}CanvasRenderer.prototype = Object.create(Renderer.prototype); CanvasRenderer.prototype.setFillStyle = function (fillStyle) {this.ctx.fillStyle = typeof fillStyle === 'object' && !!fillStyle.isColor ? fillStyle.toString() : fillStyle; return this.ctx;}; CanvasRenderer.prototype.rectangle = function (left, top, width, height, color) {this.setFillStyle(color).fillRect(left, top, width, height);}; CanvasRenderer.prototype.circle = function (left, top, size, color) {this.setFillStyle(color); this.ctx.beginPath(); this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI * 2, true); this.ctx.closePath(); this.ctx.fill();}; CanvasRenderer.prototype.circleStroke = function (left, top, size, color, stroke, strokeColor) {this.circle(left, top, size, color); this.ctx.strokeStyle = strokeColor.toString(); this.ctx.stroke();}; CanvasRenderer.prototype.drawShape = function (shape, color) {this.shape(shape); this.setFillStyle(color).fill();}; CanvasRenderer.prototype.taints = function (imageContainer) {if (imageContainer.tainted === null) {this.taintCtx.drawImage(imageContainer.image, 0, 0); try {this.taintCtx.getImageData(0, 0, 1, 1); imageContainer.tainted = false;}catch (e) {this.taintCtx = document.createElement('canvas').getContext('2d'); imageContainer.tainted = true;}}return imageContainer.tainted;}; CanvasRenderer.prototype.drawImage = function (imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {if (!this.taints(imageContainer) || this.options.allowTaint) {this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);}}; CanvasRenderer.prototype.clip = function (shapes, callback, context) {this.ctx.save(); shapes.filter(hasEntries).forEach(function (shape) {this.shape(shape).clip();}, this); callback.call(context); this.ctx.restore();}; CanvasRenderer.prototype.shape = function (shape) {this.ctx.beginPath(); shape.forEach(function (point, index) {if (point[0] === 'rect') {this.ctx.rect.apply(this.ctx, point.slice(1));}else {this.ctx[index === 0 ? 'moveTo' : point[0] + 'To'].apply(this.ctx, point.slice(1));}}, this); this.ctx.closePath(); return this.ctx;}; CanvasRenderer.prototype.font = function (color, style, variant, weight, size, family) {this.setFillStyle(color).font = [style, variant, weight, size, family].join(' ').split(',')[0];}; CanvasRenderer.prototype.fontShadow = function (color, offsetX, offsetY, blur) {this.setVariable('shadowColor', color.toString()) .setVariable('shadowOffsetY', offsetX) .setVariable('shadowOffsetX', offsetY) .setVariable('shadowBlur', blur);}; CanvasRenderer.prototype.clearShadow = function () {this.setVariable('shadowColor', 'rgba(0,0,0,0)');}; CanvasRenderer.prototype.setOpacity = function (opacity) {this.ctx.globalAlpha = opacity;}; CanvasRenderer.prototype.setTransform = function (transform) {this.ctx.translate(transform.origin[0], transform.origin[1]); this.ctx.transform.apply(this.ctx, transform.matrix); this.ctx.translate(-transform.origin[0], -transform.origin[1]);}; CanvasRenderer.prototype.setVariable = function (property, value) {if (this.variables[property] !== value) {this.variables[property] = this.ctx[property] = value;}return this;}; CanvasRenderer.prototype.text = function (text, left, bottom) {this.ctx.fillText(text, left, bottom);}; CanvasRenderer.prototype.backgroundRepeatShape = function (imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {var shape = [ ['line', Math.round(left), Math.round(top)], ['line', Math.round(left + width), Math.round(top)], ['line', Math.round(left + width), Math.round(height + top)], ['line', Math.round(left), Math.round(height + top)], ]; this.clip( [shape], function () {this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);}, this, );}; CanvasRenderer.prototype.renderBackgroundRepeat = function (imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop); this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), 'repeat')); this.ctx.translate(offsetX, offsetY); this.ctx.fill(); this.ctx.translate(-offsetX, -offsetY);}; CanvasRenderer.prototype.renderBackgroundGradient = function (gradientImage, bounds) {if (gradientImage instanceof LinearGradientContainer) {var gradient = this.ctx.createLinearGradient( bounds.left + bounds.width * gradientImage.x0, bounds.top + bounds.height * gradientImage.y0, bounds.left + bounds.width * gradientImage.x1, bounds.top + bounds.height * gradientImage.y1, ); gradientImage.colorStops.forEach(function (colorStop) {gradient.addColorStop(colorStop.stop, colorStop.color.toString());}); this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);}}; CanvasRenderer.prototype.resizeImage = function (imageContainer, size) {var image = imageContainer.image; if (image.width === size.width && image.height === size.height) {return image;}var ctx, canvas = document.createElement('canvas'); canvas.width = size.width; canvas.height = size.height; ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height); return canvas;}; function hasEntries(array) {return array.length > 0;}}.call({}, typeof window !== 'undefined' ? window : undefined, typeof document !== 'undefined' ? document : undefined)); (function () {'use strict'; angular.module('ps.presentation').directive('backgroundVideo', function ($document, $timeout) {return {restrict: 'E', scope: {url: '=', }, template: '<div></div>', link: function (scope, element) {var currentUrl; var currentVideoElement; var timeoutPromise; scope.$watch('url', function (url) {if (timeoutPromise) {$timeout.cancel(timeoutPromise);}$document[0].body.classList.add('anim-video-delay-long'); timeoutPromise = $timeout(function () {$document[0].body.classList.remove('anim-video-delay-long'); timeoutPromise = null;}, 6000); if (url && url !== currentUrl) {var newVideoElement = document.createElement('video'); newVideoElement.classList.add('fullscreen-video'); if (window.location.search && window.location.search.indexOf('embedded=1') >= 0) {newVideoElement.muted = true;}newVideoElement.addEventListener('canplay', function () {newVideoElement.play(); element[0].appendChild(newVideoElement); currentUrl = url; try {$(currentVideoElement).remove();}catch (e) {}currentVideoElement = newVideoElement;}); newVideoElement.src = url; newVideoElement.load();}});}, };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('clip', function () {return {restrict: 'E', scope: {url: '=', startAt: '=', }, replace: true, template: '<div class="fullscreen-video fullscreen-clip" style="background: #000;display: none;"></div>', link: function (scope, element) {var currentUrl; var currentVideoElement; var destroy = function () {try {$(currentVideoElement).remove();}catch (e) {}currentVideoElement = null; currentUrl = null; element[0].style.display = 'none';}; var update = function (url) {if ((!url || url !== currentUrl) && currentVideoElement) {destroy();}if (url && url !== currentUrl) {currentVideoElement = document.createElement('video'); currentVideoElement.classList.add('fullscreen-video'); if (window.location.search && window.location.search.indexOf('embedded=1') >= 0) {currentVideoElement.muted = true;}currentVideoElement.addEventListener('canplay', function () {element[0].style.display = 'block'; currentVideoElement.play(); element[0].appendChild(currentVideoElement);}); currentVideoElement.addEventListener('ended', destroy); currentVideoElement.src = url; currentVideoElement.load(); currentUrl = url;}}; scope.$watch('startAt', function () {update(scope.url);});}, };});})(); (function () {'use strict'; angular.module('ps.presentation').directive('fullscreen', function ($mdDialog, env) {return {restrict: 'A', link: function () {if (env.runtime !== 'chrome' || (window.location.search && window.location.search.indexOf('embedded=1') >= 0)) return true; var confirm = $mdDialog.confirm().title('Vollbild').textContent('Vollbildmodus anschalten?').ok('Vollbild').cancel('Fenstermodus'); $mdDialog.show(confirm).then(function () {chrome.app.window.current().fullscreen();});}, };});})();